*** File /usr/include/c++/5/iomanip:
                // Standard stream manipulators -*- C++ -*-
                
                // Copyright (C) 1997-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/iomanip
                 *  This is a Standard C++ Library header.
                 */
                
                //
                // ISO C++ 14882: 27.6.3  Standard manipulators
                //
                
                #ifndef _GLIBCXX_IOMANIP
                #define _GLIBCXX_IOMANIP 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <iosfwd>
                #include <bits/ios_base.h>
                
                #if __cplusplus >= 201103L
                #include <locale>
                #if __cplusplus > 201103L
                #include <bits/quoted_string.h>
                #endif
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // [27.6.3] standard manipulators
                  // Also see DR 183.
                
                  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
                
                  /**
                   *  @brief  Manipulator for @c setf.
                   *  @param  __mask  A format flags mask.
                   *
                   *  Sent to a stream object, this manipulator resets the specified flags,
                   *  via @e stream.setf(0,__mask).
                  */
                  inline _Resetiosflags 
                  resetiosflags(ios_base::fmtflags __mask)
                  { return { __mask }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
                    { 
                      __is.setf(ios_base::fmtflags(0), __f._M_mask); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
                    { 
                      __os.setf(ios_base::fmtflags(0), __f._M_mask); 
                      return __os; 
                    }
                
                
                  struct _Setiosflags { ios_base::fmtflags _M_mask; };
                
                  /**
                   *  @brief  Manipulator for @c setf.
                   *  @param  __mask  A format flags mask.
                   *
                   *  Sent to a stream object, this manipulator sets the format flags
                   *  to @a __mask.
                  */
                  inline _Setiosflags 
                  setiosflags(ios_base::fmtflags __mask)
                  { return { __mask }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
                    { 
                      __is.setf(__f._M_mask); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
                    { 
                      __os.setf(__f._M_mask); 
                      return __os; 
                    }
                
                
                  struct _Setbase { int _M_base; };
                
                  /**
                   *  @brief  Manipulator for @c setf.
                   *  @param  __base  A numeric base.
                   *
                   *  Sent to a stream object, this manipulator changes the
                   *  @c ios_base::basefield flags to @c oct, @c dec, or @c hex when @a base
                   *  is 8, 10, or 16, accordingly, and to 0 if @a __base is any other value.
                  */
                  inline _Setbase 
                  setbase(int __base)
                  { return { __base }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
                    {
                      __is.setf(__f._M_base ==  8 ? ios_base::oct : 
                		__f._M_base == 10 ? ios_base::dec : 
                		__f._M_base == 16 ? ios_base::hex : 
                		ios_base::fmtflags(0), ios_base::basefield);
                      return __is; 
                    }
                  
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
                    {
                      __os.setf(__f._M_base ==  8 ? ios_base::oct : 
                		__f._M_base == 10 ? ios_base::dec : 
                		__f._M_base == 16 ? ios_base::hex : 
                		ios_base::fmtflags(0), ios_base::basefield);
                      return __os; 
                    }
                  
                
                  template<typename _CharT>
                    struct _Setfill { _CharT _M_c; };
                
                  /**
                   *  @brief  Manipulator for @c fill.
                   *  @param  __c  The new fill character.
                   *
                   *  Sent to a stream object, this manipulator calls @c fill(__c) for that
                   *  object.
                  */
                  template<typename _CharT>
                    inline _Setfill<_CharT>
                    setfill(_CharT __c)
                    { return { __c }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
                    { 
                      __is.fill(__f._M_c); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
                    { 
                      __os.fill(__f._M_c); 
                      return __os; 
                    }
                
                
                  struct _Setprecision { int _M_n; };
                
                  /**
                   *  @brief  Manipulator for @c precision.
                   *  @param  __n  The new precision.
                   *
                   *  Sent to a stream object, this manipulator calls @c precision(__n) for
                   *  that object.
                  */
                  inline _Setprecision 
                  setprecision(int __n)
         116 ->   { return { __n }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
                    { 
                      __is.precision(__f._M_n); 
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
                    { 
                      __os.precision(__f._M_n); 
                      return __os; 
                    }
                
                
                  struct _Setw { int _M_n; };
                
                  /**
                   *  @brief  Manipulator for @c width.
                   *  @param  __n  The new width.
                   *
                   *  Sent to a stream object, this manipulator calls @c width(__n) for
                   *  that object.
                  */
                  inline _Setw 
                  setw(int __n)
         176 ->   { return { __n }; }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_istream<_CharT, _Traits>& 
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
                    {
                      __is.width(__f._M_n);
                      return __is; 
                    }
                
                  template<typename _CharT, typename _Traits>
                    inline basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
                    {
                      __os.width(__f._M_n);
                      return __os; 
                    }
                
                #if __cplusplus >= 201103L
                  
                  template<typename _MoneyT>
                    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
                
                  /**
                   *  @brief  Extended manipulator for extracting money.
                   *  @param  __mon  Either long double or a specialization of @c basic_string.
                   *  @param  __intl A bool indicating whether international format 
                   *                 is to be used.
                   *
                   *  Sent to a stream object, this manipulator extracts @a __mon.
                  */
                  template<typename _MoneyT>
                    inline _Get_money<_MoneyT>
                    get_money(_MoneyT& __mon, bool __intl = false)
                    { return { __mon, __intl }; }
                
                  template<typename _CharT, typename _Traits, typename _MoneyT>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
                    {
                      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
                      if (__cerb)
                	{
                	  ios_base::iostate __err = ios_base::goodbit;
                	  __try
                	    {
                	      typedef istreambuf_iterator<_CharT, _Traits>   _Iter;
                	      typedef money_get<_CharT, _Iter>               _MoneyGet;
                
                	      const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
                	      __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
                		       __is, __err, __f._M_mon);
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __is._M_setstate(ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    { __is._M_setstate(ios_base::badbit); }
                	  if (__err)
                	    __is.setstate(__err);
                	}
                      return __is; 
                    }
                
                
                  template<typename _MoneyT>
                    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
                
                  /**
                   *  @brief  Extended manipulator for inserting money.
                   *  @param  __mon  Either long double or a specialization of @c basic_string.
                   *  @param  __intl A bool indicating whether international format 
                   *                 is to be used.
                   *
                   *  Sent to a stream object, this manipulator inserts @a __mon.
                  */
                  template<typename _MoneyT>
                    inline _Put_money<_MoneyT>
                    put_money(const _MoneyT& __mon, bool __intl = false)
                    { return { __mon, __intl }; }
                
                  template<typename _CharT, typename _Traits, typename _MoneyT>
                    basic_ostream<_CharT, _Traits>& 
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
                    {
                      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
                      if (__cerb)
                	{
                	  ios_base::iostate __err = ios_base::goodbit;
                	  __try
                	    {
                	      typedef ostreambuf_iterator<_CharT, _Traits>   _Iter;
                	      typedef money_put<_CharT, _Iter>               _MoneyPut;
                
                	      const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
                	      if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
                			   __os.fill(), __f._M_mon).failed())
                		__err |= ios_base::badbit;
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __os._M_setstate(ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    { __os._M_setstate(ios_base::badbit); }
                	  if (__err)
                	    __os.setstate(__err);
                	}
                      return __os; 
                    }
                
                  template<typename _CharT>
                    struct _Put_time
                    {
                      const std::tm* _M_tmb;
                      const _CharT* _M_fmt;
                    };
                
                  /**
                   *  @brief  Extended manipulator for formatting time.
                   *
                   *  This manipulator uses time_put::put to format time.
                   *  [ext.manip]
                   *
                   *  @param __tmb  struct tm time data to format.
                   *  @param __fmt  format string.
                   */
                  template<typename _CharT>
                    inline _Put_time<_CharT>
                    put_time(const std::tm* __tmb, const _CharT* __fmt)
                    { return { __tmb, __fmt }; }
                
                  template<typename _CharT, typename _Traits>
                    basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
                    {
                      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
                      if (__cerb)
                        {
                          ios_base::iostate __err = ios_base::goodbit;
                          __try
                            {
                              typedef ostreambuf_iterator<_CharT, _Traits>   _Iter;
                              typedef time_put<_CharT, _Iter>                _TimePut;
                
                              const _CharT* const __fmt_end = __f._M_fmt +
                                _Traits::length(__f._M_fmt);
                
                              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
                              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                                __err |= ios_base::badbit;
                            }
                          __catch(__cxxabiv1::__forced_unwind&)
                            {
                              __os._M_setstate(ios_base::badbit);
                              __throw_exception_again;
                            }
                          __catch(...)
                            { __os._M_setstate(ios_base::badbit); }
                          if (__err)
                            __os.setstate(__err);
                        }
                      return __os;
                    }
                
                  template<typename _CharT>
                    struct _Get_time
                    {
                      std::tm*	    _M_tmb;
                      const _CharT* _M_fmt;
                    };
                
                  /**
                   *  @brief  Extended manipulator for extracting time.
                   *
                   *  This manipulator uses time_get::get to extract time.
                   *  [ext.manip]
                   *
                   *  @param __tmb  struct to extract the time data to.
                   *  @param __fmt  format string.
                   */
                  template<typename _CharT>
                    inline _Get_time<_CharT>
                    get_time(std::tm* __tmb, const _CharT* __fmt)
                    { return { __tmb, __fmt }; }
                
                  template<typename _CharT, typename _Traits>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
                    {
                      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
                      if (__cerb)
                        {
                          ios_base::iostate __err = ios_base::goodbit;
                          __try
                            {
                              typedef istreambuf_iterator<_CharT, _Traits>   _Iter;
                              typedef time_get<_CharT, _Iter>                _TimeGet;
                
                              const _CharT* const __fmt_end = __f._M_fmt +
                                _Traits::length(__f._M_fmt);
                
                              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
                              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
                            }
                          __catch(__cxxabiv1::__forced_unwind&)
                            {
                              __is._M_setstate(ios_base::badbit);
                              __throw_exception_again;
                            }
                          __catch(...)
                            { __is._M_setstate(ios_base::badbit); }
                          if (__err)
                            __is.setstate(__err);
                        }
                      return __is;
                    }
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_quoted_string_io 201304
                
                  /**
                   * @brief Manipulator for quoted strings.
                   * @param __string String to quote.
                   * @param __delim  Character to quote string with.
                   * @param __escape Escape character to escape itself or quote character.
                   */
                  template<typename _CharT>
                    inline auto
                    quoted(const _CharT* __string,
                	   _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
                    {
                      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
                							     __escape);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline auto
                    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
                	   _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
                    {
                      return __detail::_Quoted_string<
                			const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
                				__string, __delim, __escape);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline auto
                    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
                	   _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
                    {
                      return __detail::_Quoted_string<
                			basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
                				__string, __delim, __escape);
                    }
                
                #endif // __cplusplus > 201103L
                
                #endif // __cplusplus >= 201103L
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.  
                  // NB:  This syntax is a GNU extension.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template ostream& operator<<(ostream&, _Setfill<char>);
                  extern template ostream& operator<<(ostream&, _Setiosflags);
                  extern template ostream& operator<<(ostream&, _Resetiosflags);
                  extern template ostream& operator<<(ostream&, _Setbase);
                  extern template ostream& operator<<(ostream&, _Setprecision);
                  extern template ostream& operator<<(ostream&, _Setw);
                  extern template istream& operator>>(istream&, _Setfill<char>);
                  extern template istream& operator>>(istream&, _Setiosflags);
                  extern template istream& operator>>(istream&, _Resetiosflags);
                  extern template istream& operator>>(istream&, _Setbase);
                  extern template istream& operator>>(istream&, _Setprecision);
                  extern template istream& operator>>(istream&, _Setw);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
                  extern template wostream& operator<<(wostream&, _Setiosflags);
                  extern template wostream& operator<<(wostream&, _Resetiosflags);
                  extern template wostream& operator<<(wostream&, _Setbase);
                  extern template wostream& operator<<(wostream&, _Setprecision);
                  extern template wostream& operator<<(wostream&, _Setw);
                  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
                  extern template wistream& operator>>(wistream&, _Setiosflags);
                  extern template wistream& operator>>(wistream&, _Resetiosflags);
                  extern template wistream& operator>>(wistream&, _Setbase);
                  extern template wistream& operator>>(wistream&, _Setprecision);
                  extern template wistream& operator>>(wistream&, _Setw);
                #endif
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _GLIBCXX_IOMANIP */


Top 10 Lines:

     Line      Count

      226        176
      196        116

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

      292   Total number of line executions
   146.00   Average executions per line


*** File /home/sbillah/dmclock/sim/../src/dmclock_util.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                
                #include <unistd.h>
                #include <assert.h>
                #include <sys/time.h>
                
                #include <limits>
                #include <cmath>
                #include <chrono>
                
                
                namespace crimson {
                  namespace dmclock {
                    // we're using double to represent time, but we could change it by
                    // changing the following declarations (and by making sure a min
                    // function existed)
                    using Time = double;
                    static const Time TimeZero = 0.0;
                    static const Time TimeMax = std::numeric_limits<Time>::max();
                    static const double NaN = nan("");
                
                
        6707 ->     inline Time get_time() {
                      struct timeval now;
                      auto result = gettimeofday(&now, NULL);
                      (void) result;
                      assert(0 == result);
                      return now.tv_sec + (now.tv_usec / 1000000.0);
                    }
                
                    std::string format_time(const Time& time, uint modulo = 1000);
                
                    void debugger();
                
                  } // namespace dmclock
                } // namespace crimson


Top 10 Lines:

     Line      Count

       32       6707

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     6707   Total number of line executions
  6707.00   Average executions per line


*** File /usr/include/c++/5/bits/random.h:
                // random number generation -*- C++ -*-
                
                // Copyright (C) 2009-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /**
                 * @file bits/random.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{random}
                 */
                
                #ifndef _RANDOM_H
                #define _RANDOM_H 1
                
                #include <vector>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // [26.4] Random number generation
                
                  /**
                   * @defgroup random Random Number Generation
                   * @ingroup numerics
                   *
                   * A facility for generating random numbers on selected distributions.
                   * @{
                   */
                
                  /**
                   * @brief A function template for converting the output of a (integral)
                   * uniform random number generator to a floatng point result in the range
                   * [0-1).
                   */
                  template<typename _RealType, size_t __bits,
                	   typename _UniformRandomNumberGenerator>
                    _RealType
                    generate_canonical(_UniformRandomNumberGenerator& __g);
                
                _GLIBCXX_END_NAMESPACE_VERSION
                
                  /*
                   * Implementation-space details.
                   */
                  namespace __detail
                  {
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                    template<typename _UIntType, size_t __w,
                	     bool = __w < static_cast<size_t>
                			  (std::numeric_limits<_UIntType>::digits)>
                      struct _Shift
                      { static const _UIntType __value = 0; };
                
                    template<typename _UIntType, size_t __w>
                      struct _Shift<_UIntType, __w, true>
                      { static const _UIntType __value = _UIntType(1) << __w; };
                
                    template<int __s,
                	     int __which = ((__s <= __CHAR_BIT__ * sizeof (int))
                			    + (__s <= __CHAR_BIT__ * sizeof (long))
                			    + (__s <= __CHAR_BIT__ * sizeof (long long))
                			    /* assume long long no bigger than __int128 */
                			    + (__s <= 128))>
                      struct _Select_uint_least_t
                      {
                	static_assert(__which < 0, /* needs to be dependent */
                		      "sorry, would be too much trouble for a slow result");
                      };
                
                    template<int __s>
                      struct _Select_uint_least_t<__s, 4>
                      { typedef unsigned int type; };
                
                    template<int __s>
                      struct _Select_uint_least_t<__s, 3>
                      { typedef unsigned long type; };
                
                    template<int __s>
                      struct _Select_uint_least_t<__s, 2>
                      { typedef unsigned long long type; };
                
                #ifdef _GLIBCXX_USE_INT128
                    template<int __s>
                      struct _Select_uint_least_t<__s, 1>
                      { typedef unsigned __int128 type; };
                #endif
                
                    // Assume a != 0, a < m, c < m, x < m.
                    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c,
                	     bool __big_enough = (!(__m & (__m - 1))
                				  || (_Tp(-1) - __c) / __a >= __m - 1),
                             bool __schrage_ok = __m % __a < __m / __a>
                      struct _Mod
                      {
                	typedef typename _Select_uint_least_t<std::__lg(__a)
                					      + std::__lg(__m) + 2>::type _Tp2;
                	static _Tp
                	__calc(_Tp __x)
                	{ return static_cast<_Tp>((_Tp2(__a) * __x + __c) % __m); }
                      };
                
                    // Schrage.
                    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
                      struct _Mod<_Tp, __m, __a, __c, false, true>
                      {
                	static _Tp
                	__calc(_Tp __x);
                      };
                
                    // Special cases:
                    // - for m == 2^n or m == 0, unsigned integer overflow is safe.
                    // - a * (m - 1) + c fits in _Tp, there is no overflow.
                    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s>
                      struct _Mod<_Tp, __m, __a, __c, true, __s>
                      {
                	static _Tp
           3 -> 	__calc(_Tp __x)
                	{
                	  _Tp __res = __a * __x + __c;
                	  if (__m)
                	    __res %= __m;
                	  return __res;
                	}
                      };
                
                    template<typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0>
                      inline _Tp
           3 ->       __mod(_Tp __x)
                      { return _Mod<_Tp, __m, __a, __c>::__calc(__x); }
                
                    /* Determine whether number is a power of 2.  */
                    template<typename _Tp>
                      inline bool
                      _Power_of_2(_Tp __x)
                      {
                	return ((__x - 1) & __x) == 0;
                      };
                
                    /*
                     * An adaptor class for converting the output of any Generator into
                     * the input for a specific Distribution.
                     */
                    template<typename _Engine, typename _DInputType>
                      struct _Adaptor
                      {
                	static_assert(std::is_floating_point<_DInputType>::value,
                		      "template argument not a floating point type");
                
                      public:
                	_Adaptor(_Engine& __g)
                	: _M_g(__g) { }
                
                	_DInputType
                	min() const
                	{ return _DInputType(0); }
                
                	_DInputType
                	max() const
                	{ return _DInputType(1); }
                
                	/*
                	 * Converts a value generated by the adapted random number generator
                	 * into a value in the input domain for the dependent random number
                	 * distribution.
                	 */
                	_DInputType
                	operator()()
                	{
                	  return std::generate_canonical<_DInputType,
                	                            std::numeric_limits<_DInputType>::digits,
                	                            _Engine>(_M_g);
                	}
                
                      private:
                	_Engine& _M_g;
                      };
                
                  _GLIBCXX_END_NAMESPACE_VERSION
                  } // namespace __detail
                
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup random_generators Random Number Generators
                   * @ingroup random
                   *
                   * These classes define objects which provide random or pseudorandom
                   * numbers, either from a discrete or a continuous interval.  The
                   * random number generator supplied as a part of this library are
                   * all uniform random number generators which provide a sequence of
                   * random number uniformly distributed over their range.
                   *
                   * A number generator is a function object with an operator() that
                   * takes zero arguments and returns a number.
                   *
                   * A compliant random number generator must satisfy the following
                   * requirements.  <table border=1 cellpadding=10 cellspacing=0>
                   * <caption align=top>Random Number Generator Requirements</caption>
                   * <tr><td>To be documented.</td></tr> </table>
                   *
                   * @{
                   */
                
                  /**
                   * @brief A model of a linear congruential random number generator.
                   *
                   * A random number generator that produces pseudorandom numbers via
                   * linear function:
                   * @f[
                   *     x_{i+1}\leftarrow(ax_{i} + c) \bmod m 
                   * @f]
                   *
                   * The template parameter @p _UIntType must be an unsigned integral type
                   * large enough to store values up to (__m-1). If the template parameter
                   * @p __m is 0, the modulus @p __m used is
                   * std::numeric_limits<_UIntType>::max() plus 1. Otherwise, the template
                   * parameters @p __a and @p __c must be less than @p __m.
                   *
                   * The size of the state is @f$1@f$.
                   */
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    class linear_congruential_engine
                    {
                      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
                		    "substituting _UIntType not an unsigned integral type");
                      static_assert(__m == 0u || (__a < __m && __c < __m),
                		    "template argument substituting __m out of bounds");
                
                    public:
                      /** The type of the generated random value. */
                      typedef _UIntType result_type;
                
                      /** The multiplier. */
                      static constexpr result_type multiplier   = __a;
                      /** An increment. */
                      static constexpr result_type increment    = __c;
                      /** The modulus. */
                      static constexpr result_type modulus      = __m;
                      static constexpr result_type default_seed = 1u;
                
                      /**
                       * @brief Constructs a %linear_congruential_engine random number
                       *        generator engine with seed @p __s.  The default seed value
                       *        is 1.
                       *
                       * @param __s The initial seed value.
                       */
                      explicit
           1 ->       linear_congruential_engine(result_type __s = default_seed)
                      { seed(__s); }
                
                      /**
                       * @brief Constructs a %linear_congruential_engine random number
                       *        generator engine seeded from the seed sequence @p __q.
                       *
                       * @param __q the seed sequence.
                       */
                      template<typename _Sseq, typename = typename
                	std::enable_if<!std::is_same<_Sseq, linear_congruential_engine>::value>
                	       ::type>
                        explicit
                        linear_congruential_engine(_Sseq& __q)
                        { seed(__q); }
                
                      /**
                       * @brief Reseeds the %linear_congruential_engine random number generator
                       *        engine sequence to the seed @p __s.
                       *
                       * @param __s The new seed.
                       */
                      void
                      seed(result_type __s = default_seed);
                
                      /**
                       * @brief Reseeds the %linear_congruential_engine random number generator
                       *        engine
                       * sequence using values from the seed sequence @p __q.
                       *
                       * @param __q the seed sequence.
                       */
                      template<typename _Sseq>
                        typename std::enable_if<std::is_class<_Sseq>::value>::type
                        seed(_Sseq& __q);
                
                      /**
                       * @brief Gets the smallest possible value in the output range.
                       *
                       * The minimum depends on the @p __c parameter: if it is zero, the
                       * minimum generated must be > 0, otherwise 0 is allowed.
                       */
                      static constexpr result_type
                      min()
                      { return __c == 0u ? 1u : 0u; }
                
                      /**
                       * @brief Gets the largest possible value in the output range.
                       */
                      static constexpr result_type
                      max()
                      { return __m - 1u; }
                
                      /**
                       * @brief Discard a sequence of random numbers.
                       */
                      void
                      discard(unsigned long long __z)
                      {
                	for (; __z != 0ULL; --__z)
                	  (*this)();
                      }
                
                      /**
                       * @brief Gets the next random number in the sequence.
                       */
                      result_type
                      operator()()
                      {
                	_M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
                	return _M_x;
                      }
                
                      /**
                       * @brief Compares two linear congruential random number generator
                       * objects of the same type for equality.
                       *
                       * @param __lhs A linear congruential random number generator object.
                       * @param __rhs Another linear congruential random number generator
                       *              object.
                       *
                       * @returns true if the infinite sequences of generated values
                       *          would be equal, false otherwise.
                       */
                      friend bool
                      operator==(const linear_congruential_engine& __lhs,
                		 const linear_congruential_engine& __rhs)
                      { return __lhs._M_x == __rhs._M_x; }
                
                      /**
                       * @brief Writes the textual representation of the state x(i) of x to
                       *        @p __os.
                       *
                       * @param __os  The output stream.
                       * @param __lcr A % linear_congruential_engine random number generator.
                       * @returns __os.
                       */
                      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
                	       _UIntType1 __m1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::linear_congruential_engine<_UIntType1,
                		   __a1, __c1, __m1>& __lcr);
                
                      /**
                       * @brief Sets the state of the engine by reading its textual
                       *        representation from @p __is.
                       *
                       * The textual representation must have been previously written using
                       * an output stream whose imbued locale and whose type's template
                       * specialization arguments _CharT and _Traits were the same as those
                       * of @p __is.
                       *
                       * @param __is  The input stream.
                       * @param __lcr A % linear_congruential_engine random number generator.
                       * @returns __is.
                       */
                      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
                	       _UIntType1 __m1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::linear_congruential_engine<_UIntType1, __a1,
                		   __c1, __m1>& __lcr);
                
                    private:
                      _UIntType _M_x;
                    };
                
                  /**
                   * @brief Compares two linear congruential random number generator
                   * objects of the same type for inequality.
                   *
                   * @param __lhs A linear congruential random number generator object.
                   * @param __rhs Another linear congruential random number generator
                   *              object.
                   *
                   * @returns true if the infinite sequences of generated values
                   *          would be different, false otherwise.
                   */
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    inline bool
                    operator!=(const std::linear_congruential_engine<_UIntType, __a,
                	       __c, __m>& __lhs,
                	       const std::linear_congruential_engine<_UIntType, __a,
                	       __c, __m>& __rhs)
                    { return !(__lhs == __rhs); }
                
                
                  /**
                   * A generalized feedback shift register discrete random number generator.
                   *
                   * This algorithm avoids multiplication and division and is designed to be
                   * friendly to a pipelined architecture.  If the parameters are chosen
                   * correctly, this generator will produce numbers with a very long period and
                   * fairly good apparent entropy, although still not cryptographically strong.
                   *
                   * The best way to use this generator is with the predefined mt19937 class.
                   *
                   * This algorithm was originally invented by Makoto Matsumoto and
                   * Takuji Nishimura.
                   *
                   * @tparam __w  Word size, the number of bits in each element of 
                   *              the state vector.
                   * @tparam __n  The degree of recursion.
                   * @tparam __m  The period parameter.
                   * @tparam __r  The separation point bit index.
                   * @tparam __a  The last row of the twist matrix.
                   * @tparam __u  The first right-shift tempering matrix parameter.
                   * @tparam __d  The first right-shift tempering matrix mask.
                   * @tparam __s  The first left-shift tempering matrix parameter.
                   * @tparam __b  The first left-shift tempering matrix mask.
                   * @tparam __t  The second left-shift tempering matrix parameter.
                   * @tparam __c  The second left-shift tempering matrix mask.
                   * @tparam __l  The second right-shift tempering matrix parameter.
                   * @tparam __f  Initialization multiplier.
                   */
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t,
                	   _UIntType __c, size_t __l, _UIntType __f>
                    class mersenne_twister_engine
                    {
                      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
                		    "substituting _UIntType not an unsigned integral type");
                      static_assert(1u <= __m && __m <= __n,
                		    "template argument substituting __m out of bounds");
                      static_assert(__r <= __w, "template argument substituting "
                		    "__r out of bound");
                      static_assert(__u <= __w, "template argument substituting "
                		    "__u out of bound");
                      static_assert(__s <= __w, "template argument substituting "
                		    "__s out of bound");
                      static_assert(__t <= __w, "template argument substituting "
                		    "__t out of bound");
                      static_assert(__l <= __w, "template argument substituting "
                		    "__l out of bound");
                      static_assert(__w <= std::numeric_limits<_UIntType>::digits,
                		    "template argument substituting __w out of bound");
                      static_assert(__a <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                		    "template argument substituting __a out of bound");
                      static_assert(__b <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                		    "template argument substituting __b out of bound");
                      static_assert(__c <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                		    "template argument substituting __c out of bound");
                      static_assert(__d <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                		    "template argument substituting __d out of bound");
                      static_assert(__f <= (__detail::_Shift<_UIntType, __w>::__value - 1),
                		    "template argument substituting __f out of bound");
                
                    public:
                      /** The type of the generated random value. */
                      typedef _UIntType result_type;
                
                      // parameter values
                      static constexpr size_t      word_size                 = __w;
                      static constexpr size_t      state_size                = __n;
                      static constexpr size_t      shift_size                = __m;
                      static constexpr size_t      mask_bits                 = __r;
                      static constexpr result_type xor_mask                  = __a;
                      static constexpr size_t      tempering_u               = __u;
                      static constexpr result_type tempering_d               = __d;
                      static constexpr size_t      tempering_s               = __s;
                      static constexpr result_type tempering_b               = __b;
                      static constexpr size_t      tempering_t               = __t;
                      static constexpr result_type tempering_c               = __c;
                      static constexpr size_t      tempering_l               = __l;
                      static constexpr result_type initialization_multiplier = __f;
                      static constexpr result_type default_seed = 5489u;
                
                      // constructors and member function
                      explicit
                      mersenne_twister_engine(result_type __sd = default_seed)
                      { seed(__sd); }
                
                      /**
                       * @brief Constructs a %mersenne_twister_engine random number generator
                       *        engine seeded from the seed sequence @p __q.
                       *
                       * @param __q the seed sequence.
                       */
                      template<typename _Sseq, typename = typename
                        std::enable_if<!std::is_same<_Sseq, mersenne_twister_engine>::value>
                	       ::type>
                        explicit
                        mersenne_twister_engine(_Sseq& __q)
                        { seed(__q); }
                
                      void
                      seed(result_type __sd = default_seed);
                
                      template<typename _Sseq>
                	typename std::enable_if<std::is_class<_Sseq>::value>::type
                        seed(_Sseq& __q);
                
                      /**
                       * @brief Gets the smallest possible value in the output range.
                       */
                      static constexpr result_type
                      min()
                      { return 0; };
                
                      /**
                       * @brief Gets the largest possible value in the output range.
                       */
                      static constexpr result_type
                      max()
                      { return __detail::_Shift<_UIntType, __w>::__value - 1; }
                
                      /**
                       * @brief Discard a sequence of random numbers.
                       */
                      void
                      discard(unsigned long long __z);
                
                      result_type
                      operator()();
                
                      /**
                       * @brief Compares two % mersenne_twister_engine random number generator
                       *        objects of the same type for equality.
                       *
                       * @param __lhs A % mersenne_twister_engine random number generator
                       *              object.
                       * @param __rhs Another % mersenne_twister_engine random number
                       *              generator object.
                       *
                       * @returns true if the infinite sequences of generated values
                       *          would be equal, false otherwise.
                       */
                      friend bool
                      operator==(const mersenne_twister_engine& __lhs,
                		 const mersenne_twister_engine& __rhs)
                      { return (std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x)
                		&& __lhs._M_p == __rhs._M_p); }
                
                      /**
                       * @brief Inserts the current state of a % mersenne_twister_engine
                       *        random number generator engine @p __x into the output stream
                       *        @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A % mersenne_twister_engine random number generator
                       *             engine.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _UIntType1,
                	       size_t __w1, size_t __n1,
                	       size_t __m1, size_t __r1,
                	       _UIntType1 __a1, size_t __u1,
                	       _UIntType1 __d1, size_t __s1,
                	       _UIntType1 __b1, size_t __t1,
                	       _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::mersenne_twister_engine<_UIntType1, __w1, __n1,
                		   __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
                		   __l1, __f1>& __x);
                
                      /**
                       * @brief Extracts the current state of a % mersenne_twister_engine
                       *        random number generator engine @p __x from the input stream
                       *        @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A % mersenne_twister_engine random number generator
                       *             engine.
                       *
                       * @returns The input stream with the state of @p __x extracted or in
                       * an error state.
                       */
                      template<typename _UIntType1,
                	       size_t __w1, size_t __n1,
                	       size_t __m1, size_t __r1,
                	       _UIntType1 __a1, size_t __u1,
                	       _UIntType1 __d1, size_t __s1,
                	       _UIntType1 __b1, size_t __t1,
                	       _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1,
                		   __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
                		   __l1, __f1>& __x);
                
                    private:
                      void _M_gen_rand();
                
                      _UIntType _M_x[state_size];
                      size_t    _M_p;
                    };
                
                  /**
                   * @brief Compares two % mersenne_twister_engine random number generator
                   *        objects of the same type for inequality.
                   *
                   * @param __lhs A % mersenne_twister_engine random number generator
                   *              object.
                   * @param __rhs Another % mersenne_twister_engine random number
                   *              generator object.
                   *
                   * @returns true if the infinite sequences of generated values
                   *          would be different, false otherwise.
                   */
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t,
                	   _UIntType __c, size_t __l, _UIntType __f>
                    inline bool
                    operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
                	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __lhs,
                	       const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
                	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __rhs)
                    { return !(__lhs == __rhs); }
                
                
                  /**
                   * @brief The Marsaglia-Zaman generator.
                   *
                   * This is a model of a Generalized Fibonacci discrete random number
                   * generator, sometimes referred to as the SWC generator.
                   *
                   * A discrete random number generator that produces pseudorandom
                   * numbers using:
                   * @f[
                   *     x_{i}\leftarrow(x_{i - s} - x_{i - r} - carry_{i-1}) \bmod m 
                   * @f]
                   *
                   * The size of the state is @f$r@f$
                   * and the maximum period of the generator is @f$(m^r - m^s - 1)@f$.
                   */
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    class subtract_with_carry_engine
                    {
                      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
                		    "substituting _UIntType not an unsigned integral type");
                      static_assert(0u < __s && __s < __r,
                		    "template argument substituting __s out of bounds");
                      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
                		    "template argument substituting __w out of bounds");
                
                    public:
                      /** The type of the generated random value. */
                      typedef _UIntType result_type;
                
                      // parameter values
                      static constexpr size_t      word_size    = __w;
                      static constexpr size_t      short_lag    = __s;
                      static constexpr size_t      long_lag     = __r;
                      static constexpr result_type default_seed = 19780503u;
                
                      /**
                       * @brief Constructs an explicitly seeded % subtract_with_carry_engine
                       *        random number generator.
                       */
                      explicit
                      subtract_with_carry_engine(result_type __sd = default_seed)
                      { seed(__sd); }
                
                      /**
                       * @brief Constructs a %subtract_with_carry_engine random number engine
                       *        seeded from the seed sequence @p __q.
                       *
                       * @param __q the seed sequence.
                       */
                      template<typename _Sseq, typename = typename
                        std::enable_if<!std::is_same<_Sseq, subtract_with_carry_engine>::value>
                	       ::type>
                        explicit
                        subtract_with_carry_engine(_Sseq& __q)
                        { seed(__q); }
                
                      /**
                       * @brief Seeds the initial state @f$x_0@f$ of the random number
                       *        generator.
                       *
                       * N1688[4.19] modifies this as follows.  If @p __value == 0,
                       * sets value to 19780503.  In any case, with a linear
                       * congruential generator lcg(i) having parameters @f$ m_{lcg} =
                       * 2147483563, a_{lcg} = 40014, c_{lcg} = 0, and lcg(0) = value
                       * @f$, sets @f$ x_{-r} \dots x_{-1} @f$ to @f$ lcg(1) \bmod m
                       * \dots lcg(r) \bmod m @f$ respectively.  If @f$ x_{-1} = 0 @f$
                       * set carry to 1, otherwise sets carry to 0.
                       */
                      void
                      seed(result_type __sd = default_seed);
                
                      /**
                       * @brief Seeds the initial state @f$x_0@f$ of the
                       * % subtract_with_carry_engine random number generator.
                       */
                      template<typename _Sseq>
                	typename std::enable_if<std::is_class<_Sseq>::value>::type
                        seed(_Sseq& __q);
                
                      /**
                       * @brief Gets the inclusive minimum value of the range of random
                       * integers returned by this generator.
                       */
                      static constexpr result_type
                      min()
                      { return 0; }
                
                      /**
                       * @brief Gets the inclusive maximum value of the range of random
                       * integers returned by this generator.
                       */
                      static constexpr result_type
                      max()
                      { return __detail::_Shift<_UIntType, __w>::__value - 1; }
                
                      /**
                       * @brief Discard a sequence of random numbers.
                       */
                      void
                      discard(unsigned long long __z)
                      {
                	for (; __z != 0ULL; --__z)
                	  (*this)();
                      }
                
                      /**
                       * @brief Gets the next random number in the sequence.
                       */
                      result_type
                      operator()();
                
                      /**
                       * @brief Compares two % subtract_with_carry_engine random number
                       *        generator objects of the same type for equality.
                       *
                       * @param __lhs A % subtract_with_carry_engine random number generator
                       *              object.
                       * @param __rhs Another % subtract_with_carry_engine random number
                       *              generator object.
                       *
                       * @returns true if the infinite sequences of generated values
                       *          would be equal, false otherwise.
                      */
                      friend bool
                      operator==(const subtract_with_carry_engine& __lhs,
                		 const subtract_with_carry_engine& __rhs)
                      { return (std::equal(__lhs._M_x, __lhs._M_x + long_lag, __rhs._M_x)
                		&& __lhs._M_carry == __rhs._M_carry
                		&& __lhs._M_p == __rhs._M_p); }
                
                      /**
                       * @brief Inserts the current state of a % subtract_with_carry_engine
                       *        random number generator engine @p __x into the output stream
                       *        @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A % subtract_with_carry_engine random number generator
                       *             engine.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::subtract_with_carry_engine<_UIntType1, __w1,
                		   __s1, __r1>& __x);
                
                      /**
                       * @brief Extracts the current state of a % subtract_with_carry_engine
                       *        random number generator engine @p __x from the input stream
                       *        @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A % subtract_with_carry_engine random number generator
                       *             engine.
                       *
                       * @returns The input stream with the state of @p __x extracted or in
                       * an error state.
                       */
                      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::subtract_with_carry_engine<_UIntType1, __w1,
                		   __s1, __r1>& __x);
                
                    private:
                      /// The state of the generator.  This is a ring buffer.
                      _UIntType  _M_x[long_lag];
                      _UIntType  _M_carry;		///< The carry
                      size_t     _M_p;			///< Current index of x(i - r).
                    };
                
                  /**
                   * @brief Compares two % subtract_with_carry_engine random number
                   *        generator objects of the same type for inequality.
                   *
                   * @param __lhs A % subtract_with_carry_engine random number generator
                   *              object.
                   * @param __rhs Another % subtract_with_carry_engine random number
                   *              generator object.
                   *
                   * @returns true if the infinite sequences of generated values
                   *          would be different, false otherwise.
                   */
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    inline bool
                    operator!=(const std::subtract_with_carry_engine<_UIntType, __w,
                	       __s, __r>& __lhs,
                	       const std::subtract_with_carry_engine<_UIntType, __w,
                	       __s, __r>& __rhs)
                    { return !(__lhs == __rhs); }
                
                
                  /**
                   * Produces random numbers from some base engine by discarding blocks of
                   * data.
                   *
                   * 0 <= @p __r <= @p __p
                   */
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    class discard_block_engine
                    {
                      static_assert(1 <= __r && __r <= __p,
                		    "template argument substituting __r out of bounds");
                
                    public:
                      /** The type of the generated random value. */
                      typedef typename _RandomNumberEngine::result_type result_type;
                
                      // parameter values
                      static constexpr size_t block_size = __p;
                      static constexpr size_t used_block = __r;
                
                      /**
                       * @brief Constructs a default %discard_block_engine engine.
                       *
                       * The underlying engine is default constructed as well.
                       */
                      discard_block_engine()
                      : _M_b(), _M_n(0) { }
                
                      /**
                       * @brief Copy constructs a %discard_block_engine engine.
                       *
                       * Copies an existing base class random number generator.
                       * @param __rng An existing (base class) engine object.
                       */
                      explicit
                      discard_block_engine(const _RandomNumberEngine& __rng)
                      : _M_b(__rng), _M_n(0) { }
                
                      /**
                       * @brief Move constructs a %discard_block_engine engine.
                       *
                       * Copies an existing base class random number generator.
                       * @param __rng An existing (base class) engine object.
                       */
                      explicit
                      discard_block_engine(_RandomNumberEngine&& __rng)
                      : _M_b(std::move(__rng)), _M_n(0) { }
                
                      /**
                       * @brief Seed constructs a %discard_block_engine engine.
                       *
                       * Constructs the underlying generator engine seeded with @p __s.
                       * @param __s A seed value for the base class engine.
                       */
                      explicit
                      discard_block_engine(result_type __s)
                      : _M_b(__s), _M_n(0) { }
                
                      /**
                       * @brief Generator construct a %discard_block_engine engine.
                       *
                       * @param __q A seed sequence.
                       */
                      template<typename _Sseq, typename = typename
                	std::enable_if<!std::is_same<_Sseq, discard_block_engine>::value
                		       && !std::is_same<_Sseq, _RandomNumberEngine>::value>
                	       ::type>
                        explicit
                        discard_block_engine(_Sseq& __q)
                	: _M_b(__q), _M_n(0)
                        { }
                
                      /**
                       * @brief Reseeds the %discard_block_engine object with the default
                       *        seed for the underlying base class generator engine.
                       */
                      void
                      seed()
                      {
                	_M_b.seed();
                	_M_n = 0;
                      }
                
                      /**
                       * @brief Reseeds the %discard_block_engine object with the default
                       *        seed for the underlying base class generator engine.
                       */
                      void
                      seed(result_type __s)
                      {
                	_M_b.seed(__s);
                	_M_n = 0;
                      }
                
                      /**
                       * @brief Reseeds the %discard_block_engine object with the given seed
                       *        sequence.
                       * @param __q A seed generator function.
                       */
                      template<typename _Sseq>
                        void
                        seed(_Sseq& __q)
                        {
                	  _M_b.seed(__q);
                	  _M_n = 0;
                	}
                
                      /**
                       * @brief Gets a const reference to the underlying generator engine
                       *        object.
                       */
                      const _RandomNumberEngine&
                      base() const noexcept
                      { return _M_b; }
                
                      /**
                       * @brief Gets the minimum value in the generated random number range.
                       */
                      static constexpr result_type
                      min()
                      { return _RandomNumberEngine::min(); }
                
                      /**
                       * @brief Gets the maximum value in the generated random number range.
                       */
                      static constexpr result_type
                      max()
                      { return _RandomNumberEngine::max(); }
                
                      /**
                       * @brief Discard a sequence of random numbers.
                       */
                      void
                      discard(unsigned long long __z)
                      {
                	for (; __z != 0ULL; --__z)
                	  (*this)();
                      }
                
                      /**
                       * @brief Gets the next value in the generated random number sequence.
                       */
                      result_type
                      operator()();
                
                      /**
                       * @brief Compares two %discard_block_engine random number generator
                       *        objects of the same type for equality.
                       *
                       * @param __lhs A %discard_block_engine random number generator object.
                       * @param __rhs Another %discard_block_engine random number generator
                       *              object.
                       *
                       * @returns true if the infinite sequences of generated values
                       *          would be equal, false otherwise.
                       */
                      friend bool
                      operator==(const discard_block_engine& __lhs,
                		 const discard_block_engine& __rhs)
                      { return __lhs._M_b == __rhs._M_b && __lhs._M_n == __rhs._M_n; }
                
                      /**
                       * @brief Inserts the current state of a %discard_block_engine random
                       *        number generator engine @p __x into the output stream
                       *        @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %discard_block_engine random number generator engine.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::discard_block_engine<_RandomNumberEngine1,
                		   __p1, __r1>& __x);
                
                      /**
                       * @brief Extracts the current state of a % subtract_with_carry_engine
                       *        random number generator engine @p __x from the input stream
                       *        @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %discard_block_engine random number generator engine.
                       *
                       * @returns The input stream with the state of @p __x extracted or in
                       * an error state.
                       */
                      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::discard_block_engine<_RandomNumberEngine1,
                		   __p1, __r1>& __x);
                
                    private:
                      _RandomNumberEngine _M_b;
                      size_t _M_n;
                    };
                
                  /**
                   * @brief Compares two %discard_block_engine random number generator
                   *        objects of the same type for inequality.
                   *
                   * @param __lhs A %discard_block_engine random number generator object.
                   * @param __rhs Another %discard_block_engine random number generator
                   *              object.
                   *
                   * @returns true if the infinite sequences of generated values
                   *          would be different, false otherwise.
                   */
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    inline bool
                    operator!=(const std::discard_block_engine<_RandomNumberEngine, __p,
                	       __r>& __lhs,
                	       const std::discard_block_engine<_RandomNumberEngine, __p,
                	       __r>& __rhs)
                    { return !(__lhs == __rhs); }
                
                
                  /**
                   * Produces random numbers by combining random numbers from some base
                   * engine to produce random numbers with a specifies number of bits @p __w.
                   */
                  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
                    class independent_bits_engine
                    {
                      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
                		    "substituting _UIntType not an unsigned integral type");
                      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
                		    "template argument substituting __w out of bounds");
                
                    public:
                      /** The type of the generated random value. */
                      typedef _UIntType result_type;
                
                      /**
                       * @brief Constructs a default %independent_bits_engine engine.
                       *
                       * The underlying engine is default constructed as well.
                       */
                      independent_bits_engine()
                      : _M_b() { }
                
                      /**
                       * @brief Copy constructs a %independent_bits_engine engine.
                       *
                       * Copies an existing base class random number generator.
                       * @param __rng An existing (base class) engine object.
                       */
                      explicit
                      independent_bits_engine(const _RandomNumberEngine& __rng)
                      : _M_b(__rng) { }
                
                      /**
                       * @brief Move constructs a %independent_bits_engine engine.
                       *
                       * Copies an existing base class random number generator.
                       * @param __rng An existing (base class) engine object.
                       */
                      explicit
                      independent_bits_engine(_RandomNumberEngine&& __rng)
                      : _M_b(std::move(__rng)) { }
                
                      /**
                       * @brief Seed constructs a %independent_bits_engine engine.
                       *
                       * Constructs the underlying generator engine seeded with @p __s.
                       * @param __s A seed value for the base class engine.
                       */
                      explicit
                      independent_bits_engine(result_type __s)
                      : _M_b(__s) { }
                
                      /**
                       * @brief Generator construct a %independent_bits_engine engine.
                       *
                       * @param __q A seed sequence.
                       */
                      template<typename _Sseq, typename = typename
                	std::enable_if<!std::is_same<_Sseq, independent_bits_engine>::value
                		       && !std::is_same<_Sseq, _RandomNumberEngine>::value>
                               ::type>
                        explicit
                        independent_bits_engine(_Sseq& __q)
                        : _M_b(__q)
                        { }
                
                      /**
                       * @brief Reseeds the %independent_bits_engine object with the default
                       *        seed for the underlying base class generator engine.
                       */
                      void
                      seed()
                      { _M_b.seed(); }
                
                      /**
                       * @brief Reseeds the %independent_bits_engine object with the default
                       *        seed for the underlying base class generator engine.
                       */
                      void
                      seed(result_type __s)
                      { _M_b.seed(__s); }
                
                      /**
                       * @brief Reseeds the %independent_bits_engine object with the given
                       *        seed sequence.
                       * @param __q A seed generator function.
                       */
                      template<typename _Sseq>
                        void
                        seed(_Sseq& __q)
                        { _M_b.seed(__q); }
                
                      /**
                       * @brief Gets a const reference to the underlying generator engine
                       *        object.
                       */
                      const _RandomNumberEngine&
                      base() const noexcept
                      { return _M_b; }
                
                      /**
                       * @brief Gets the minimum value in the generated random number range.
                       */
                      static constexpr result_type
                      min()
                      { return 0U; }
                
                      /**
                       * @brief Gets the maximum value in the generated random number range.
                       */
                      static constexpr result_type
                      max()
                      { return __detail::_Shift<_UIntType, __w>::__value - 1; }
                
                      /**
                       * @brief Discard a sequence of random numbers.
                       */
                      void
                      discard(unsigned long long __z)
                      {
                	for (; __z != 0ULL; --__z)
                	  (*this)();
                      }
                
                      /**
                       * @brief Gets the next value in the generated random number sequence.
                       */
                      result_type
                      operator()();
                
                      /**
                       * @brief Compares two %independent_bits_engine random number generator
                       * objects of the same type for equality.
                       *
                       * @param __lhs A %independent_bits_engine random number generator
                       *              object.
                       * @param __rhs Another %independent_bits_engine random number generator
                       *              object.
                       *
                       * @returns true if the infinite sequences of generated values
                       *          would be equal, false otherwise.
                       */
                      friend bool
                      operator==(const independent_bits_engine& __lhs,
                		 const independent_bits_engine& __rhs)
                      { return __lhs._M_b == __rhs._M_b; }
                
                      /**
                       * @brief Extracts the current state of a % subtract_with_carry_engine
                       *        random number generator engine @p __x from the input stream
                       *        @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %independent_bits_engine random number generator
                       *             engine.
                       *
                       * @returns The input stream with the state of @p __x extracted or in
                       *          an error state.
                       */
                      template<typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::independent_bits_engine<_RandomNumberEngine,
                		   __w, _UIntType>& __x)
                	{
                	  __is >> __x._M_b;
                	  return __is;
                	}
                
                    private:
                      _RandomNumberEngine _M_b;
                    };
                
                  /**
                   * @brief Compares two %independent_bits_engine random number generator
                   * objects of the same type for inequality.
                   *
                   * @param __lhs A %independent_bits_engine random number generator
                   *              object.
                   * @param __rhs Another %independent_bits_engine random number generator
                   *              object.
                   *
                   * @returns true if the infinite sequences of generated values
                   *          would be different, false otherwise.
                   */
                  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
                    inline bool
                    operator!=(const std::independent_bits_engine<_RandomNumberEngine, __w,
                	       _UIntType>& __lhs,
                	       const std::independent_bits_engine<_RandomNumberEngine, __w,
                	       _UIntType>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   * @brief Inserts the current state of a %independent_bits_engine random
                   *        number generator engine @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %independent_bits_engine random number generator engine.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   *          an error state.
                   */
                  template<typename _RandomNumberEngine, size_t __w, typename _UIntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const std::independent_bits_engine<_RandomNumberEngine,
                	       __w, _UIntType>& __x)
                    {
                      __os << __x.base();
                      return __os;
                    }
                
                
                  /**
                   * @brief Produces random numbers by combining random numbers from some
                   * base engine to produce random numbers with a specifies number of bits
                   * @p __w.
                   */
                  template<typename _RandomNumberEngine, size_t __k>
                    class shuffle_order_engine
                    {
                      static_assert(1u <= __k, "template argument substituting "
                		    "__k out of bound");
                
                    public:
                      /** The type of the generated random value. */
                      typedef typename _RandomNumberEngine::result_type result_type;
                
                      static constexpr size_t table_size = __k;
                
                      /**
                       * @brief Constructs a default %shuffle_order_engine engine.
                       *
                       * The underlying engine is default constructed as well.
                       */
                      shuffle_order_engine()
                      : _M_b()
                      { _M_initialize(); }
                
                      /**
                       * @brief Copy constructs a %shuffle_order_engine engine.
                       *
                       * Copies an existing base class random number generator.
                       * @param __rng An existing (base class) engine object.
                       */
                      explicit
                      shuffle_order_engine(const _RandomNumberEngine& __rng)
                      : _M_b(__rng)
                      { _M_initialize(); }
                
                      /**
                       * @brief Move constructs a %shuffle_order_engine engine.
                       *
                       * Copies an existing base class random number generator.
                       * @param __rng An existing (base class) engine object.
                       */
                      explicit
                      shuffle_order_engine(_RandomNumberEngine&& __rng)
                      : _M_b(std::move(__rng))
                      { _M_initialize(); }
                
                      /**
                       * @brief Seed constructs a %shuffle_order_engine engine.
                       *
                       * Constructs the underlying generator engine seeded with @p __s.
                       * @param __s A seed value for the base class engine.
                       */
                      explicit
                      shuffle_order_engine(result_type __s)
                      : _M_b(__s)
                      { _M_initialize(); }
                
                      /**
                       * @brief Generator construct a %shuffle_order_engine engine.
                       *
                       * @param __q A seed sequence.
                       */
                      template<typename _Sseq, typename = typename
                	std::enable_if<!std::is_same<_Sseq, shuffle_order_engine>::value
                		       && !std::is_same<_Sseq, _RandomNumberEngine>::value>
                	       ::type>
                        explicit
                        shuffle_order_engine(_Sseq& __q)
                        : _M_b(__q)
                        { _M_initialize(); }
                
                      /**
                       * @brief Reseeds the %shuffle_order_engine object with the default seed
                                for the underlying base class generator engine.
                       */
                      void
                      seed()
                      {
                	_M_b.seed();
                	_M_initialize();
                      }
                
                      /**
                       * @brief Reseeds the %shuffle_order_engine object with the default seed
                       *        for the underlying base class generator engine.
                       */
                      void
                      seed(result_type __s)
                      {
                	_M_b.seed(__s);
                	_M_initialize();
                      }
                
                      /**
                       * @brief Reseeds the %shuffle_order_engine object with the given seed
                       *        sequence.
                       * @param __q A seed generator function.
                       */
                      template<typename _Sseq>
                        void
                        seed(_Sseq& __q)
                        {
                	  _M_b.seed(__q);
                	  _M_initialize();
                	}
                
                      /**
                       * Gets a const reference to the underlying generator engine object.
                       */
                      const _RandomNumberEngine&
                      base() const noexcept
                      { return _M_b; }
                
                      /**
                       * Gets the minimum value in the generated random number range.
                       */
                      static constexpr result_type
                      min()
                      { return _RandomNumberEngine::min(); }
                
                      /**
                       * Gets the maximum value in the generated random number range.
                       */
                      static constexpr result_type
                      max()
                      { return _RandomNumberEngine::max(); }
                
                      /**
                       * Discard a sequence of random numbers.
                       */
                      void
                      discard(unsigned long long __z)
                      {
                	for (; __z != 0ULL; --__z)
                	  (*this)();
                      }
                
                      /**
                       * Gets the next value in the generated random number sequence.
                       */
                      result_type
                      operator()();
                
                      /**
                       * Compares two %shuffle_order_engine random number generator objects
                       * of the same type for equality.
                       *
                       * @param __lhs A %shuffle_order_engine random number generator object.
                       * @param __rhs Another %shuffle_order_engine random number generator
                       *              object.
                       *
                       * @returns true if the infinite sequences of generated values
                       *          would be equal, false otherwise.
                      */
                      friend bool
                      operator==(const shuffle_order_engine& __lhs,
                		 const shuffle_order_engine& __rhs)
                      { return (__lhs._M_b == __rhs._M_b
                		&& std::equal(__lhs._M_v, __lhs._M_v + __k, __rhs._M_v)
                		&& __lhs._M_y == __rhs._M_y); }
                
                      /**
                       * @brief Inserts the current state of a %shuffle_order_engine random
                       *        number generator engine @p __x into the output stream
                	@p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %shuffle_order_engine random number generator engine.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RandomNumberEngine1, size_t __k1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::shuffle_order_engine<_RandomNumberEngine1,
                		   __k1>& __x);
                
                      /**
                       * @brief Extracts the current state of a % subtract_with_carry_engine
                       *        random number generator engine @p __x from the input stream
                       *        @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %shuffle_order_engine random number generator engine.
                       *
                       * @returns The input stream with the state of @p __x extracted or in
                       * an error state.
                       */
                      template<typename _RandomNumberEngine1, size_t __k1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::shuffle_order_engine<_RandomNumberEngine1, __k1>& __x);
                
                    private:
                      void _M_initialize()
                      {
                	for (size_t __i = 0; __i < __k; ++__i)
                	  _M_v[__i] = _M_b();
                	_M_y = _M_b();
                      }
                
                      _RandomNumberEngine _M_b;
                      result_type _M_v[__k];
                      result_type _M_y;
                    };
                
                  /**
                   * Compares two %shuffle_order_engine random number generator objects
                   * of the same type for inequality.
                   *
                   * @param __lhs A %shuffle_order_engine random number generator object.
                   * @param __rhs Another %shuffle_order_engine random number generator
                   *              object.
                   *
                   * @returns true if the infinite sequences of generated values
                   *          would be different, false otherwise.
                   */
                  template<typename _RandomNumberEngine, size_t __k>
                    inline bool
                    operator!=(const std::shuffle_order_engine<_RandomNumberEngine,
                	       __k>& __lhs,
                	       const std::shuffle_order_engine<_RandomNumberEngine,
                	       __k>& __rhs)
                    { return !(__lhs == __rhs); }
                
                
                  /**
                   * The classic Minimum Standard rand0 of Lewis, Goodman, and Miller.
                   */
                  typedef linear_congruential_engine<uint_fast32_t, 16807UL, 0UL, 2147483647UL>
                  minstd_rand0;
                
                  /**
                   * An alternative LCR (Lehmer Generator function).
                   */
                  typedef linear_congruential_engine<uint_fast32_t, 48271UL, 0UL, 2147483647UL>
                  minstd_rand;
                
                  /**
                   * The classic Mersenne Twister.
                   *
                   * Reference:
                   * M. Matsumoto and T. Nishimura, Mersenne Twister: A 623-Dimensionally
                   * Equidistributed Uniform Pseudo-Random Number Generator, ACM Transactions
                   * on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3-30.
                   */
                  typedef mersenne_twister_engine<
                    uint_fast32_t,
                    32, 624, 397, 31,
                    0x9908b0dfUL, 11,
                    0xffffffffUL, 7,
                    0x9d2c5680UL, 15,
                    0xefc60000UL, 18, 1812433253UL> mt19937;
                
                  /**
                   * An alternative Mersenne Twister.
                   */
                  typedef mersenne_twister_engine<
                    uint_fast64_t,
                    64, 312, 156, 31,
                    0xb5026f5aa96619e9ULL, 29,
                    0x5555555555555555ULL, 17,
                    0x71d67fffeda60000ULL, 37,
                    0xfff7eee000000000ULL, 43,
                    6364136223846793005ULL> mt19937_64;
                
                  typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>
                    ranlux24_base;
                
                  typedef subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>
                    ranlux48_base;
                
                  typedef discard_block_engine<ranlux24_base, 223, 23> ranlux24;
                
                  typedef discard_block_engine<ranlux48_base, 389, 11> ranlux48;
                
                  typedef shuffle_order_engine<minstd_rand0, 256> knuth_b;
                
                  typedef minstd_rand0 default_random_engine;
                
                  /**
                   * A standard interface to a platform-specific non-deterministic
                   * random number generator (if any are available).
                   */
                  class random_device
                  {
                  public:
                    /** The type of the generated random value. */
                    typedef unsigned int result_type;
                
                    // constructors, destructors and member functions
                
                #ifdef _GLIBCXX_USE_RANDOM_TR1
                
                    explicit
                    random_device(const std::string& __token = "default")
                    {
                      _M_init(__token);
                    }
                
                    ~random_device()
                    { _M_fini(); }
                
                #else
                
                    explicit
                    random_device(const std::string& __token = "mt19937")
                    { _M_init_pretr1(__token); }
                
                  public:
                
                #endif
                
                    static constexpr result_type
                    min()
                    { return std::numeric_limits<result_type>::min(); }
                
                    static constexpr result_type
                    max()
                    { return std::numeric_limits<result_type>::max(); }
                
                    double
                    entropy() const noexcept
                    { return 0.0; }
                
                    result_type
                    operator()()
                    {
                #ifdef _GLIBCXX_USE_RANDOM_TR1
                      return this->_M_getval();
                #else
                      return this->_M_getval_pretr1();
                #endif
                    }
                
                    // No copy functions.
                    random_device(const random_device&) = delete;
                    void operator=(const random_device&) = delete;
                
                  private:
                
                    void _M_init(const std::string& __token);
                    void _M_init_pretr1(const std::string& __token);
                    void _M_fini();
                
                    result_type _M_getval();
                    result_type _M_getval_pretr1();
                
                    union
                    {
                      void*      _M_file;
                      mt19937    _M_mt;
                    };
                  };
                
                  /* @} */ // group random_generators
                
                  /**
                   * @addtogroup random_distributions Random Number Distributions
                   * @ingroup random
                   * @{
                   */
                
                  /**
                   * @addtogroup random_distributions_uniform Uniform Distributions
                   * @ingroup random_distributions
                   * @{
                   */
                
                  /**
                   * @brief Uniform discrete distribution for random numbers.
                   * A discrete random distribution on the range @f$[min, max]@f$ with equal
                   * probability throughout the range.
                   */
                  template<typename _IntType = int>
                    class uniform_int_distribution
                    {
                      static_assert(std::is_integral<_IntType>::value,
                		    "template argument not an integral type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _IntType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef uniform_int_distribution<_IntType> distribution_type;
                
                	explicit
                	param_type(_IntType __a = 0,
                		   _IntType __b = std::numeric_limits<_IntType>::max())
                	: _M_a(__a), _M_b(__b)
                	{
                	  _GLIBCXX_DEBUG_ASSERT(_M_a <= _M_b);
                	}
                
                	result_type
                	a() const
                	{ return _M_a; }
                
                	result_type
                	b() const
                	{ return _M_b; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
                
                      private:
                	_IntType _M_a;
                	_IntType _M_b;
                      };
                
                    public:
                      /**
                       * @brief Constructs a uniform distribution object.
                       */
                      explicit
                      uniform_int_distribution(_IntType __a = 0,
                			   _IntType __b = std::numeric_limits<_IntType>::max())
                      : _M_param(__a, __b)
                      { }
                
                      explicit
                      uniform_int_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       *
                       * Does nothing for the uniform integer distribution.
                       */
                      void
                      reset() { }
                
                      result_type
                      a() const
                      { return _M_param.a(); }
                
                      result_type
                      b() const
                      { return _M_param.b(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the inclusive lower bound of the distribution range.
                       */
                      result_type
                      min() const
                      { return this->a(); }
                
                      /**
                       * @brief Returns the inclusive upper bound of the distribution range.
                       */
                      result_type
                      max() const
                      { return this->b(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                        { return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two uniform integer distributions have
                       *        the same parameters.
                       */
                      friend bool
                      operator==(const uniform_int_distribution& __d1,
                		 const uniform_int_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                   * @brief Return true if two uniform integer distributions have
                   *        different parameters.
                   */
                  template<typename _IntType>
                    inline bool
                    operator!=(const std::uniform_int_distribution<_IntType>& __d1,
                	       const std::uniform_int_distribution<_IntType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %uniform_int_distribution random number
                   *        distribution @p __x into the output stream @p os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %uniform_int_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   * an error state.
                   */
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>&,
                	       const std::uniform_int_distribution<_IntType>&);
                
                  /**
                   * @brief Extracts a %uniform_int_distribution random number distribution
                   * @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x  A %uniform_int_distribution random number generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>&,
                	       std::uniform_int_distribution<_IntType>&);
                
                
                  /**
                   * @brief Uniform continuous distribution for random numbers.
                   *
                   * A continuous random distribution on the range [min, max) with equal
                   * probability throughout the range.  The URNG should be real-valued and
                   * deliver number in the range [0, 1).
                   */
                  template<typename _RealType = double>
                    class uniform_real_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef uniform_real_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __a = _RealType(0),
                		   _RealType __b = _RealType(1))
                	: _M_a(__a), _M_b(__b)
                	{
                	  _GLIBCXX_DEBUG_ASSERT(_M_a <= _M_b);
                	}
                
                	result_type
                	a() const
                	{ return _M_a; }
                
                	result_type
                	b() const
                	{ return _M_b; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
                
                      private:
                	_RealType _M_a;
                	_RealType _M_b;
                      };
                
                    public:
                      /**
                       * @brief Constructs a uniform_real_distribution object.
                       *
                       * @param __a [IN]  The lower bound of the distribution.
                       * @param __b [IN]  The upper bound of the distribution.
                       */
                      explicit
                      uniform_real_distribution(_RealType __a = _RealType(0),
                				_RealType __b = _RealType(1))
                      : _M_param(__a, __b)
                      { }
                
                      explicit
                      uniform_real_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       *
                       * Does nothing for the uniform real distribution.
                       */
                      void
                      reset() { }
                
                      result_type
                      a() const
                      { return _M_param.a(); }
                
                      result_type
                      b() const
                      { return _M_param.b(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the inclusive lower bound of the distribution range.
                       */
                      result_type
                      min() const
                      { return this->a(); }
                
                      /**
                       * @brief Returns the inclusive upper bound of the distribution range.
                       */
                      result_type
                      max() const
                      { return this->b(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                        { return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{
                	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	    __aurng(__urng);
                	  return (__aurng() * (__p.b() - __p.a())) + __p.a();
                	}
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two uniform real distributions have
                       *        the same parameters.
                       */
                      friend bool
                      operator==(const uniform_real_distribution& __d1,
                		 const uniform_real_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                   * @brief Return true if two uniform real distributions have
                   *        different parameters.
                   */
                  template<typename _IntType>
                    inline bool
                    operator!=(const std::uniform_real_distribution<_IntType>& __d1,
                	       const std::uniform_real_distribution<_IntType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %uniform_real_distribution random number
                   *        distribution @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %uniform_real_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   *          an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>&,
                	       const std::uniform_real_distribution<_RealType>&);
                
                  /**
                   * @brief Extracts a %uniform_real_distribution random number distribution
                   * @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x  A %uniform_real_distribution random number generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>&,
                	       std::uniform_real_distribution<_RealType>&);
                
                  /* @} */ // group random_distributions_uniform
                
                  /**
                   * @addtogroup random_distributions_normal Normal Distributions
                   * @ingroup random_distributions
                   * @{
                   */
                
                  /**
                   * @brief A normal continuous distribution for random numbers.
                   *
                   * The formula for the normal probability density function is
                   * @f[
                   *     p(x|\mu,\sigma) = \frac{1}{\sigma \sqrt{2 \pi}}
                   *            e^{- \frac{{x - \mu}^ {2}}{2 \sigma ^ {2}} } 
                   * @f]
                   */
                  template<typename _RealType = double>
                    class normal_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef normal_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __mean = _RealType(0),
                		   _RealType __stddev = _RealType(1))
                	: _M_mean(__mean), _M_stddev(__stddev)
                	{
                	  _GLIBCXX_DEBUG_ASSERT(_M_stddev > _RealType(0));
                	}
                
                	_RealType
                	mean() const
                	{ return _M_mean; }
                
                	_RealType
                	stddev() const
                	{ return _M_stddev; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return (__p1._M_mean == __p2._M_mean
                		  && __p1._M_stddev == __p2._M_stddev); }
                
                      private:
                	_RealType _M_mean;
                	_RealType _M_stddev;
                      };
                
                    public:
                      /**
                       * Constructs a normal distribution with parameters @f$mean@f$ and
                       * standard deviation.
                       */
                      explicit
                      normal_distribution(result_type __mean = result_type(0),
                			  result_type __stddev = result_type(1))
                      : _M_param(__mean, __stddev), _M_saved_available(false)
                      { }
                
                      explicit
                      normal_distribution(const param_type& __p)
                      : _M_param(__p), _M_saved_available(false)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { _M_saved_available = false; }
                
                      /**
                       * @brief Returns the mean of the distribution.
                       */
                      _RealType
                      mean() const
                      { return _M_param.mean(); }
                
                      /**
                       * @brief Returns the standard deviation of the distribution.
                       */
                      _RealType
                      stddev() const
                      { return _M_param.stddev(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return std::numeric_limits<result_type>::lowest(); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two normal distributions have
                       *        the same parameters and the sequences that would
                       *        be generated are equal.
                       */
                      template<typename _RealType1>
                	friend bool
                        operator==(const std::normal_distribution<_RealType1>& __d1,
                		   const std::normal_distribution<_RealType1>& __d2);
                
                      /**
                       * @brief Inserts a %normal_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %normal_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::normal_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %normal_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %normal_distribution random number generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error
                       *          state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::normal_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type  _M_param;
                      result_type _M_saved;
                      bool        _M_saved_available;
                    };
                
                  /**
                   * @brief Return true if two normal distributions are different.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::normal_distribution<_RealType>& __d1,
                	       const std::normal_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief A lognormal_distribution random number distribution.
                   *
                   * The formula for the normal probability mass function is
                   * @f[
                   *     p(x|m,s) = \frac{1}{sx\sqrt{2\pi}}
                   *                \exp{-\frac{(\ln{x} - m)^2}{2s^2}} 
                   * @f]
                   */
                  template<typename _RealType = double>
                    class lognormal_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef lognormal_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __m = _RealType(0),
                		   _RealType __s = _RealType(1))
                	: _M_m(__m), _M_s(__s)
                	{ }
                
                	_RealType
                	m() const
                	{ return _M_m; }
                
                	_RealType
                	s() const
                	{ return _M_s; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_m == __p2._M_m && __p1._M_s == __p2._M_s; }
                
                      private:
                	_RealType _M_m;
                	_RealType _M_s;
                      };
                
                      explicit
                      lognormal_distribution(_RealType __m = _RealType(0),
                			     _RealType __s = _RealType(1))
                      : _M_param(__m, __s), _M_nd()
                      { }
                
                      explicit
                      lognormal_distribution(const param_type& __p)
                      : _M_param(__p), _M_nd()
                      { }
                
                      /**
                       * Resets the distribution state.
                       */
                      void
                      reset()
                      { _M_nd.reset(); }
                
                      /**
                       *
                       */
                      _RealType
                      m() const
                      { return _M_param.m(); }
                
                      _RealType
                      s() const
                      { return _M_param.s(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                        { return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                        { return std::exp(__p.s() * _M_nd(__urng) + __p.m()); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two lognormal distributions have
                       *        the same parameters and the sequences that would
                       *        be generated are equal.
                       */
                      friend bool
                      operator==(const lognormal_distribution& __d1,
                		 const lognormal_distribution& __d2)
                      { return (__d1._M_param == __d2._M_param
                		&& __d1._M_nd == __d2._M_nd); }
                
                      /**
                       * @brief Inserts a %lognormal_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %lognormal_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::lognormal_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %lognormal_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x A %lognormal_distribution random number
                       *            generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::lognormal_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                
                      std::normal_distribution<result_type> _M_nd;
                    };
                
                  /**
                   * @brief Return true if two lognormal distributions are different.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::lognormal_distribution<_RealType>& __d1,
                	       const std::lognormal_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief A gamma continuous distribution for random numbers.
                   *
                   * The formula for the gamma probability density function is:
                   * @f[
                   *     p(x|\alpha,\beta) = \frac{1}{\beta\Gamma(\alpha)}
                   *                         (x/\beta)^{\alpha - 1} e^{-x/\beta} 
                   * @f]
                   */
                  template<typename _RealType = double>
                    class gamma_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef gamma_distribution<_RealType> distribution_type;
                	friend class gamma_distribution<_RealType>;
                
                	explicit
                	param_type(_RealType __alpha_val = _RealType(1),
                		   _RealType __beta_val = _RealType(1))
                	: _M_alpha(__alpha_val), _M_beta(__beta_val)
                	{
                	  _GLIBCXX_DEBUG_ASSERT(_M_alpha > _RealType(0));
                	  _M_initialize();
                	}
                
                	_RealType
                	alpha() const
                	{ return _M_alpha; }
                
                	_RealType
                	beta() const
                	{ return _M_beta; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return (__p1._M_alpha == __p2._M_alpha
                		  && __p1._M_beta == __p2._M_beta); }
                
                      private:
                	void
                	_M_initialize();
                
                	_RealType _M_alpha;
                	_RealType _M_beta;
                
                	_RealType _M_malpha, _M_a2;
                      };
                
                    public:
                      /**
                       * @brief Constructs a gamma distribution with parameters
                       * @f$\alpha@f$ and @f$\beta@f$.
                       */
                      explicit
                      gamma_distribution(_RealType __alpha_val = _RealType(1),
                			 _RealType __beta_val = _RealType(1))
                      : _M_param(__alpha_val, __beta_val), _M_nd()
                      { }
                
                      explicit
                      gamma_distribution(const param_type& __p)
                      : _M_param(__p), _M_nd()
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { _M_nd.reset(); }
                
                      /**
                       * @brief Returns the @f$\alpha@f$ of the distribution.
                       */
                      _RealType
                      alpha() const
                      { return _M_param.alpha(); }
                
                      /**
                       * @brief Returns the @f$\beta@f$ of the distribution.
                       */
                      _RealType
                      beta() const
                      { return _M_param.beta(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two gamma distributions have the same
                       *        parameters and the sequences that would be generated
                       *        are equal.
                       */
                      friend bool
                      operator==(const gamma_distribution& __d1,
                		 const gamma_distribution& __d2)
                      { return (__d1._M_param == __d2._M_param
                		&& __d1._M_nd == __d2._M_nd); }
                
                      /**
                       * @brief Inserts a %gamma_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %gamma_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::gamma_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %gamma_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %gamma_distribution random number generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::gamma_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                
                      std::normal_distribution<result_type> _M_nd;
                    };
                
                  /**
                   * @brief Return true if two gamma distributions are different.
                   */
                   template<typename _RealType>
                     inline bool
                     operator!=(const std::gamma_distribution<_RealType>& __d1,
                		const std::gamma_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief A chi_squared_distribution random number distribution.
                   *
                   * The formula for the normal probability mass function is
                   * @f$p(x|n) = \frac{x^{(n/2) - 1}e^{-x/2}}{\Gamma(n/2) 2^{n/2}}@f$
                   */
                  template<typename _RealType = double>
                    class chi_squared_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef chi_squared_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __n = _RealType(1))
                	: _M_n(__n)
                	{ }
                
                	_RealType
                	n() const
                	{ return _M_n; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_n == __p2._M_n; }
                
                      private:
                	_RealType _M_n;
                      };
                
                      explicit
                      chi_squared_distribution(_RealType __n = _RealType(1))
                      : _M_param(__n), _M_gd(__n / 2)
                      { }
                
                      explicit
                      chi_squared_distribution(const param_type& __p)
                      : _M_param(__p), _M_gd(__p.n() / 2)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { _M_gd.reset(); }
                
                      /**
                       *
                       */
                      _RealType
                      n() const
                      { return _M_param.n(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return 2 * _M_gd(__urng); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                        {
                	  typedef typename std::gamma_distribution<result_type>::param_type
                	    param_type;
                	  return 2 * _M_gd(__urng, param_type(__p.n() / 2));
                	}
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                        { this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ typename std::gamma_distribution<result_type>::param_type
                	    __p2(__p.n() / 2);
                	  this->__generate_impl(__f, __t, __urng, __p2); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng)
                        { this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ typename std::gamma_distribution<result_type>::param_type
                	    __p2(__p.n() / 2);
                	  this->__generate_impl(__f, __t, __urng, __p2); }
                
                      /**
                       * @brief Return true if two Chi-squared distributions have
                       *        the same parameters and the sequences that would be
                       *        generated are equal.
                       */
                      friend bool
                      operator==(const chi_squared_distribution& __d1,
                		 const chi_squared_distribution& __d2)
                      { return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd; }
                
                      /**
                       * @brief Inserts a %chi_squared_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %chi_squared_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::chi_squared_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %chi_squared_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x A %chi_squared_distribution random number
                       *            generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::chi_squared_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const typename
                			std::gamma_distribution<result_type>::param_type& __p);
                
                      param_type _M_param;
                
                      std::gamma_distribution<result_type> _M_gd;
                    };
                
                  /**
                   * @brief Return true if two Chi-squared distributions are different.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::chi_squared_distribution<_RealType>& __d1,
                	       const std::chi_squared_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief A cauchy_distribution random number distribution.
                   *
                   * The formula for the normal probability mass function is
                   * @f$p(x|a,b) = (\pi b (1 + (\frac{x-a}{b})^2))^{-1}@f$
                   */
                  template<typename _RealType = double>
                    class cauchy_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef cauchy_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __a = _RealType(0),
                		   _RealType __b = _RealType(1))
                	: _M_a(__a), _M_b(__b)
                	{ }
                
                	_RealType
                	a() const
                	{ return _M_a; }
                
                	_RealType
                	b() const
                	{ return _M_b; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
                
                      private:
                	_RealType _M_a;
                	_RealType _M_b;
                      };
                
                      explicit
                      cauchy_distribution(_RealType __a = _RealType(0),
                			  _RealType __b = _RealType(1))
                      : _M_param(__a, __b)
                      { }
                
                      explicit
                      cauchy_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { }
                
                      /**
                       *
                       */
                      _RealType
                      a() const
                      { return _M_param.a(); }
                
                      _RealType
                      b() const
                      { return _M_param.b(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return std::numeric_limits<result_type>::lowest(); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two Cauchy distributions have
                       *        the same parameters.
                       */
                      friend bool
                      operator==(const cauchy_distribution& __d1,
                		 const cauchy_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                   * @brief Return true if two Cauchy distributions have
                   *        different parameters.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::cauchy_distribution<_RealType>& __d1,
                	       const std::cauchy_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %cauchy_distribution random number distribution
                   * @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %cauchy_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   * an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const std::cauchy_distribution<_RealType>& __x);
                
                  /**
                   * @brief Extracts a %cauchy_distribution random number distribution
                   * @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x A %cauchy_distribution random number
                   *            generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       std::cauchy_distribution<_RealType>& __x);
                
                
                  /**
                   * @brief A fisher_f_distribution random number distribution.
                   *
                   * The formula for the normal probability mass function is
                   * @f[
                   *     p(x|m,n) = \frac{\Gamma((m+n)/2)}{\Gamma(m/2)\Gamma(n/2)}
                   *                (\frac{m}{n})^{m/2} x^{(m/2)-1}
                   *                (1 + \frac{mx}{n})^{-(m+n)/2} 
                   * @f]
                   */
                  template<typename _RealType = double>
                    class fisher_f_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef fisher_f_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __m = _RealType(1),
                		   _RealType __n = _RealType(1))
                	: _M_m(__m), _M_n(__n)
                	{ }
                
                	_RealType
                	m() const
                	{ return _M_m; }
                
                	_RealType
                	n() const
                	{ return _M_n; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_m == __p2._M_m && __p1._M_n == __p2._M_n; }
                
                      private:
                	_RealType _M_m;
                	_RealType _M_n;
                      };
                
                      explicit
                      fisher_f_distribution(_RealType __m = _RealType(1),
                			    _RealType __n = _RealType(1))
                      : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2)
                      { }
                
                      explicit
                      fisher_f_distribution(const param_type& __p)
                      : _M_param(__p), _M_gd_x(__p.m() / 2), _M_gd_y(__p.n() / 2)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      {
                	_M_gd_x.reset();
                	_M_gd_y.reset();
                      }
                
                      /**
                       *
                       */
                      _RealType
                      m() const
                      { return _M_param.m(); }
                
                      _RealType
                      n() const
                      { return _M_param.n(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return (_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                        {
                	  typedef typename std::gamma_distribution<result_type>::param_type
                	    param_type;
                	  return ((_M_gd_x(__urng, param_type(__p.m() / 2)) * n())
                		  / (_M_gd_y(__urng, param_type(__p.n() / 2)) * m()));
                	}
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two Fisher f distributions have
                       *        the same parameters and the sequences that would
                       *        be generated are equal.
                       */
                      friend bool
                      operator==(const fisher_f_distribution& __d1,
                		 const fisher_f_distribution& __d2)
                      { return (__d1._M_param == __d2._M_param
                		&& __d1._M_gd_x == __d2._M_gd_x
                		&& __d1._M_gd_y == __d2._M_gd_y); }
                
                      /**
                       * @brief Inserts a %fisher_f_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %fisher_f_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::fisher_f_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %fisher_f_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x A %fisher_f_distribution random number
                       *            generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::fisher_f_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                
                      std::gamma_distribution<result_type> _M_gd_x, _M_gd_y;
                    };
                
                  /**
                   * @brief Return true if two Fisher f distributions are different.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::fisher_f_distribution<_RealType>& __d1,
                	       const std::fisher_f_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief A student_t_distribution random number distribution.
                   *
                   * The formula for the normal probability mass function is:
                   * @f[
                   *     p(x|n) = \frac{1}{\sqrt(n\pi)} \frac{\Gamma((n+1)/2)}{\Gamma(n/2)}
                   *              (1 + \frac{x^2}{n}) ^{-(n+1)/2} 
                   * @f]
                   */
                  template<typename _RealType = double>
                    class student_t_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef student_t_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __n = _RealType(1))
                	: _M_n(__n)
                	{ }
                
                	_RealType
                	n() const
                	{ return _M_n; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_n == __p2._M_n; }
                
                      private:
                	_RealType _M_n;
                      };
                
                      explicit
                      student_t_distribution(_RealType __n = _RealType(1))
                      : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2)
                      { }
                
                      explicit
                      student_t_distribution(const param_type& __p)
                      : _M_param(__p), _M_nd(), _M_gd(__p.n() / 2, 2)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      {
                	_M_nd.reset();
                	_M_gd.reset();
                      }
                
                      /**
                       *
                       */
                      _RealType
                      n() const
                      { return _M_param.n(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return std::numeric_limits<result_type>::lowest(); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                        operator()(_UniformRandomNumberGenerator& __urng)
                        { return _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng)); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                        {
                	  typedef typename std::gamma_distribution<result_type>::param_type
                	    param_type;
                	
                	  const result_type __g = _M_gd(__urng, param_type(__p.n() / 2, 2));
                	  return _M_nd(__urng) * std::sqrt(__p.n() / __g);
                        }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two Student t distributions have
                       *        the same parameters and the sequences that would
                       *        be generated are equal.
                       */
                      friend bool
                      operator==(const student_t_distribution& __d1,
                		 const student_t_distribution& __d2)
                      { return (__d1._M_param == __d2._M_param
                		&& __d1._M_nd == __d2._M_nd && __d1._M_gd == __d2._M_gd); }
                
                      /**
                       * @brief Inserts a %student_t_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %student_t_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::student_t_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %student_t_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x A %student_t_distribution random number
                       *            generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::student_t_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng);
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                
                      std::normal_distribution<result_type> _M_nd;
                      std::gamma_distribution<result_type> _M_gd;
                    };
                
                  /**
                   * @brief Return true if two Student t distributions are different.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::student_t_distribution<_RealType>& __d1,
                	       const std::student_t_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /* @} */ // group random_distributions_normal
                
                  /**
                   * @addtogroup random_distributions_bernoulli Bernoulli Distributions
                   * @ingroup random_distributions
                   * @{
                   */
                
                  /**
                   * @brief A Bernoulli random number distribution.
                   *
                   * Generates a sequence of true and false values with likelihood @f$p@f$
                   * that true will come up and @f$(1 - p)@f$ that false will appear.
                   */
                  class bernoulli_distribution
                  {
                  public:
                    /** The type of the range of the distribution. */
                    typedef bool result_type;
                    /** Parameter type. */
                    struct param_type
                    {
                      typedef bernoulli_distribution distribution_type;
                
                      explicit
                      param_type(double __p = 0.5)
                      : _M_p(__p)
                      {
                	_GLIBCXX_DEBUG_ASSERT((_M_p >= 0.0) && (_M_p <= 1.0));
                      }
                
                      double
                      p() const
                      { return _M_p; }
                
                      friend bool
                      operator==(const param_type& __p1, const param_type& __p2)
                      { return __p1._M_p == __p2._M_p; }
                
                    private:
                      double _M_p;
                    };
                
                  public:
                    /**
                     * @brief Constructs a Bernoulli distribution with likelihood @p p.
                     *
                     * @param __p  [IN]  The likelihood of a true result being returned.
                     *                   Must be in the interval @f$[0, 1]@f$.
                     */
                    explicit
                    bernoulli_distribution(double __p = 0.5)
                    : _M_param(__p)
                    { }
                
                    explicit
                    bernoulli_distribution(const param_type& __p)
                    : _M_param(__p)
                    { }
                
                    /**
                     * @brief Resets the distribution state.
                     *
                     * Does nothing for a Bernoulli distribution.
                     */
                    void
                    reset() { }
                
                    /**
                     * @brief Returns the @p p parameter of the distribution.
                     */
                    double
                    p() const
                    { return _M_param.p(); }
                
                    /**
                     * @brief Returns the parameter set of the distribution.
                     */
                    param_type
                    param() const
                    { return _M_param; }
                
                    /**
                     * @brief Sets the parameter set of the distribution.
                     * @param __param The new parameter set of the distribution.
                     */
                    void
                    param(const param_type& __param)
                    { _M_param = __param; }
                
                    /**
                     * @brief Returns the greatest lower bound value of the distribution.
                     */
                    result_type
                    min() const
                    { return std::numeric_limits<result_type>::min(); }
                
                    /**
                     * @brief Returns the least upper bound value of the distribution.
                     */
                    result_type
                    max() const
                    { return std::numeric_limits<result_type>::max(); }
                
                    /**
                     * @brief Generating functions.
                     */
                    template<typename _UniformRandomNumberGenerator>
                      result_type
                      operator()(_UniformRandomNumberGenerator& __urng)
                      { return this->operator()(__urng, _M_param); }
                
                    template<typename _UniformRandomNumberGenerator>
                      result_type
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                	if ((__aurng() - __aurng.min())
                	     < __p.p() * (__aurng.max() - __aurng.min()))
                	  return true;
                	return false;
                      }
                
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      __generate(_ForwardIterator __f, _ForwardIterator __t,
                		 _UniformRandomNumberGenerator& __urng)
                      { this->__generate(__f, __t, __urng, _M_param); }
                
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      __generate(_ForwardIterator __f, _ForwardIterator __t,
                		 _UniformRandomNumberGenerator& __urng, const param_type& __p)
                      { this->__generate_impl(__f, __t, __urng, __p); }
                
                    template<typename _UniformRandomNumberGenerator>
                      void
                      __generate(result_type* __f, result_type* __t,
                		 _UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      { this->__generate_impl(__f, __t, __urng, __p); }
                
                    /**
                     * @brief Return true if two Bernoulli distributions have
                     *        the same parameters.
                     */
                    friend bool
                    operator==(const bernoulli_distribution& __d1,
                	       const bernoulli_distribution& __d2)
                    { return __d1._M_param == __d2._M_param; }
                
                  private:
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p);
                
                    param_type _M_param;
                  };
                
                  /**
                   * @brief Return true if two Bernoulli distributions have
                   *        different parameters.
                   */
                  inline bool
                  operator!=(const std::bernoulli_distribution& __d1,
                	     const std::bernoulli_distribution& __d2)
                  { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %bernoulli_distribution random number distribution
                   * @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %bernoulli_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   * an error state.
                   */
                  template<typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const std::bernoulli_distribution& __x);
                
                  /**
                   * @brief Extracts a %bernoulli_distribution random number distribution
                   * @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x  A %bernoulli_distribution random number generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       std::bernoulli_distribution& __x)
                    {
                      double __p;
                      __is >> __p;
                      __x.param(bernoulli_distribution::param_type(__p));
                      return __is;
                    }
                
                
                  /**
                   * @brief A discrete binomial random number distribution.
                   *
                   * The formula for the binomial probability density function is
                   * @f$p(i|t,p) = \binom{t}{i} p^i (1 - p)^{t - i}@f$ where @f$t@f$
                   * and @f$p@f$ are the parameters of the distribution.
                   */
                  template<typename _IntType = int>
                    class binomial_distribution
                    {
                      static_assert(std::is_integral<_IntType>::value,
                		    "template argument not an integral type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _IntType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef binomial_distribution<_IntType> distribution_type;
                	friend class binomial_distribution<_IntType>;
                
                	explicit
                	param_type(_IntType __t = _IntType(1), double __p = 0.5)
                	: _M_t(__t), _M_p(__p)
                	{
                	  _GLIBCXX_DEBUG_ASSERT((_M_t >= _IntType(0))
                				&& (_M_p >= 0.0)
                				&& (_M_p <= 1.0));
                	  _M_initialize();
                	}
                
                	_IntType
                	t() const
                	{ return _M_t; }
                
                	double
                	p() const
                	{ return _M_p; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_t == __p2._M_t && __p1._M_p == __p2._M_p; }
                
                      private:
                	void
                	_M_initialize();
                
                	_IntType _M_t;
                	double _M_p;
                
                	double _M_q;
                #if _GLIBCXX_USE_C99_MATH_TR1
                	double _M_d1, _M_d2, _M_s1, _M_s2, _M_c,
                	       _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;
                #endif
                	bool   _M_easy;
                      };
                
                      // constructors and member function
                      explicit
                      binomial_distribution(_IntType __t = _IntType(1),
                			    double __p = 0.5)
                      : _M_param(__t, __p), _M_nd()
                      { }
                
                      explicit
                      binomial_distribution(const param_type& __p)
                      : _M_param(__p), _M_nd()
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { _M_nd.reset(); }
                
                      /**
                       * @brief Returns the distribution @p t parameter.
                       */
                      _IntType
                      t() const
                      { return _M_param.t(); }
                
                      /**
                       * @brief Returns the distribution @p p parameter.
                       */
                      double
                      p() const
                      { return _M_param.p(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return 0; }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return _M_param.t(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two binomial distributions have
                       *        the same parameters and the sequences that would
                       *        be generated are equal.
                       */
                	friend bool
                        operator==(const binomial_distribution& __d1,
                		   const binomial_distribution& __d2)
                #ifdef _GLIBCXX_USE_C99_MATH_TR1
                	{ return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
                #else
                        { return __d1._M_param == __d2._M_param; }
                #endif
                
                      /**
                       * @brief Inserts a %binomial_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %binomial_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _IntType1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::binomial_distribution<_IntType1>& __x);
                
                      /**
                       * @brief Extracts a %binomial_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %binomial_distribution random number generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error
                       *          state.
                       */
                      template<typename _IntType1,
                	       typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::binomial_distribution<_IntType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	_M_waiting(_UniformRandomNumberGenerator& __urng,
                		   _IntType __t, double __q);
                
                      param_type _M_param;
                
                      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.
                      std::normal_distribution<double> _M_nd;
                    };
                
                  /**
                   * @brief Return true if two binomial distributions are different.
                   */
                  template<typename _IntType>
                    inline bool
                    operator!=(const std::binomial_distribution<_IntType>& __d1,
                	       const std::binomial_distribution<_IntType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief A discrete geometric random number distribution.
                   *
                   * The formula for the geometric probability density function is
                   * @f$p(i|p) = p(1 - p)^{i}@f$ where @f$p@f$ is the parameter of the
                   * distribution.
                   */
                  template<typename _IntType = int>
                    class geometric_distribution
                    {
                      static_assert(std::is_integral<_IntType>::value,
                		    "template argument not an integral type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _IntType  result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef geometric_distribution<_IntType> distribution_type;
                	friend class geometric_distribution<_IntType>;
                
                	explicit
                	param_type(double __p = 0.5)
                	: _M_p(__p)
                	{
                	  _GLIBCXX_DEBUG_ASSERT((_M_p > 0.0) && (_M_p < 1.0));
                	  _M_initialize();
                	}
                
                	double
                	p() const
                	{ return _M_p; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_p == __p2._M_p; }
                
                      private:
                	void
                	_M_initialize()
                	{ _M_log_1_p = std::log(1.0 - _M_p); }
                
                	double _M_p;
                
                	double _M_log_1_p;
                      };
                
                      // constructors and member function
                      explicit
                      geometric_distribution(double __p = 0.5)
                      : _M_param(__p)
                      { }
                
                      explicit
                      geometric_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       *
                       * Does nothing for the geometric distribution.
                       */
                      void
                      reset() { }
                
                      /**
                       * @brief Returns the distribution parameter @p p.
                       */
                      double
                      p() const
                      { return _M_param.p(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return 0; }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two geometric distributions have
                       *        the same parameters.
                       */
                      friend bool
                      operator==(const geometric_distribution& __d1,
                		 const geometric_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                   * @brief Return true if two geometric distributions have
                   *        different parameters.
                   */
                  template<typename _IntType>
                    inline bool
                    operator!=(const std::geometric_distribution<_IntType>& __d1,
                	       const std::geometric_distribution<_IntType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %geometric_distribution random number distribution
                   * @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %geometric_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   * an error state.
                   */
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const std::geometric_distribution<_IntType>& __x);
                
                  /**
                   * @brief Extracts a %geometric_distribution random number distribution
                   * @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x  A %geometric_distribution random number generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       std::geometric_distribution<_IntType>& __x);
                
                
                  /**
                   * @brief A negative_binomial_distribution random number distribution.
                   *
                   * The formula for the negative binomial probability mass function is
                   * @f$p(i) = \binom{n}{i} p^i (1 - p)^{t - i}@f$ where @f$t@f$
                   * and @f$p@f$ are the parameters of the distribution.
                   */
                  template<typename _IntType = int>
                    class negative_binomial_distribution
                    {
                      static_assert(std::is_integral<_IntType>::value,
                		    "template argument not an integral type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _IntType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef negative_binomial_distribution<_IntType> distribution_type;
                
                	explicit
                	param_type(_IntType __k = 1, double __p = 0.5)
                	: _M_k(__k), _M_p(__p)
                	{
                	  _GLIBCXX_DEBUG_ASSERT((_M_k > 0) && (_M_p > 0.0) && (_M_p <= 1.0));
                	}
                
                	_IntType
                	k() const
                	{ return _M_k; }
                
                	double
                	p() const
                	{ return _M_p; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_k == __p2._M_k && __p1._M_p == __p2._M_p; }
                
                      private:
                	_IntType _M_k;
                	double _M_p;
                      };
                
                      explicit
                      negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)
                      : _M_param(__k, __p), _M_gd(__k, (1.0 - __p) / __p)
                      { }
                
                      explicit
                      negative_binomial_distribution(const param_type& __p)
                      : _M_param(__p), _M_gd(__p.k(), (1.0 - __p.p()) / __p.p())
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { _M_gd.reset(); }
                
                      /**
                       * @brief Return the @f$k@f$ parameter of the distribution.
                       */
                      _IntType
                      k() const
                      { return _M_param.k(); }
                
                      /**
                       * @brief Return the @f$p@f$ parameter of the distribution.
                       */
                      double
                      p() const
                      { return _M_param.p(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                        operator()(_UniformRandomNumberGenerator& __urng);
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate_impl(__f, __t, __urng); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two negative binomial distributions have
                       *        the same parameters and the sequences that would be
                       *        generated are equal.
                       */
                      friend bool
                      operator==(const negative_binomial_distribution& __d1,
                		 const negative_binomial_distribution& __d2)
                      { return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd; }
                
                      /**
                       * @brief Inserts a %negative_binomial_distribution random
                       *        number distribution @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %negative_binomial_distribution random number
                       *             distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       *          an error state.
                       */
                      template<typename _IntType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::negative_binomial_distribution<_IntType1>& __x);
                
                      /**
                       * @brief Extracts a %negative_binomial_distribution random number
                       *        distribution @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x A %negative_binomial_distribution random number
                       *            generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error state.
                       */
                      template<typename _IntType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::negative_binomial_distribution<_IntType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng);
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                
                      std::gamma_distribution<double> _M_gd;
                    };
                
                  /**
                   * @brief Return true if two negative binomial distributions are different.
                   */
                  template<typename _IntType>
                    inline bool
                    operator!=(const std::negative_binomial_distribution<_IntType>& __d1,
                	       const std::negative_binomial_distribution<_IntType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /* @} */ // group random_distributions_bernoulli
                
                  /**
                   * @addtogroup random_distributions_poisson Poisson Distributions
                   * @ingroup random_distributions
                   * @{
                   */
                
                  /**
                   * @brief A discrete Poisson random number distribution.
                   *
                   * The formula for the Poisson probability density function is
                   * @f$p(i|\mu) = \frac{\mu^i}{i!} e^{-\mu}@f$ where @f$\mu@f$ is the
                   * parameter of the distribution.
                   */
                  template<typename _IntType = int>
                    class poisson_distribution
                    {
                      static_assert(std::is_integral<_IntType>::value,
                		    "template argument not an integral type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _IntType  result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef poisson_distribution<_IntType> distribution_type;
                	friend class poisson_distribution<_IntType>;
                
                	explicit
                	param_type(double __mean = 1.0)
                	: _M_mean(__mean)
                	{
                	  _GLIBCXX_DEBUG_ASSERT(_M_mean > 0.0);
                	  _M_initialize();
                	}
                
                	double
                	mean() const
                	{ return _M_mean; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_mean == __p2._M_mean; }
                
                      private:
                	// Hosts either log(mean) or the threshold of the simple method.
                	void
                	_M_initialize();
                
                	double _M_mean;
                
                	double _M_lm_thr;
                #if _GLIBCXX_USE_C99_MATH_TR1
                	double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;
                #endif
                      };
                
                      // constructors and member function
                      explicit
                      poisson_distribution(double __mean = 1.0)
                      : _M_param(__mean), _M_nd()
                      { }
                
                      explicit
                      poisson_distribution(const param_type& __p)
                      : _M_param(__p), _M_nd()
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { _M_nd.reset(); }
                
                      /**
                       * @brief Returns the distribution parameter @p mean.
                       */
                      double
                      mean() const
                      { return _M_param.mean(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return 0; }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                       /**
                	* @brief Return true if two Poisson distributions have the same
                	*        parameters and the sequences that would be generated
                	*        are equal.
                	*/
                      friend bool
                      operator==(const poisson_distribution& __d1,
                		 const poisson_distribution& __d2)
                #ifdef _GLIBCXX_USE_C99_MATH_TR1
                      { return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
                #else
                      { return __d1._M_param == __d2._M_param; }
                #endif
                
                      /**
                       * @brief Inserts a %poisson_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %poisson_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _IntType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::poisson_distribution<_IntType1>& __x);
                
                      /**
                       * @brief Extracts a %poisson_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %poisson_distribution random number generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error
                       *          state.
                       */
                      template<typename _IntType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::poisson_distribution<_IntType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                
                      // NB: Unused when _GLIBCXX_USE_C99_MATH_TR1 is undefined.
                      std::normal_distribution<double> _M_nd;
                    };
                
                  /**
                   * @brief Return true if two Poisson distributions are different.
                   */
                  template<typename _IntType>
                    inline bool
                    operator!=(const std::poisson_distribution<_IntType>& __d1,
                	       const std::poisson_distribution<_IntType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief An exponential continuous distribution for random numbers.
                   *
                   * The formula for the exponential probability density function is
                   * @f$p(x|\lambda) = \lambda e^{-\lambda x}@f$.
                   *
                   * <table border=1 cellpadding=10 cellspacing=0>
                   * <caption align=top>Distribution Statistics</caption>
                   * <tr><td>Mean</td><td>@f$\frac{1}{\lambda}@f$</td></tr>
                   * <tr><td>Median</td><td>@f$\frac{\ln 2}{\lambda}@f$</td></tr>
                   * <tr><td>Mode</td><td>@f$zero@f$</td></tr>
                   * <tr><td>Range</td><td>@f$[0, \infty]@f$</td></tr>
                   * <tr><td>Standard Deviation</td><td>@f$\frac{1}{\lambda}@f$</td></tr>
                   * </table>
                   */
                  template<typename _RealType = double>
                    class exponential_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef exponential_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __lambda = _RealType(1))
                	: _M_lambda(__lambda)
                	{
                	  _GLIBCXX_DEBUG_ASSERT(_M_lambda > _RealType(0));
                	}
                
                	_RealType
                	lambda() const
                	{ return _M_lambda; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_lambda == __p2._M_lambda; }
                
                      private:
                	_RealType _M_lambda;
                      };
                
                    public:
                      /**
                       * @brief Constructs an exponential distribution with inverse scale
                       *        parameter @f$\lambda@f$.
                       */
                      explicit
                      exponential_distribution(const result_type& __lambda = result_type(1))
                      : _M_param(__lambda)
                      { }
                
                      explicit
                      exponential_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       *
                       * Has no effect on exponential distributions.
                       */
                      void
                      reset() { }
                
                      /**
                       * @brief Returns the inverse scale parameter of the distribution.
                       */
                      _RealType
                      lambda() const
                      { return _M_param.lambda(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                        { return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{
                	  __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	    __aurng(__urng);
                	  return -std::log(result_type(1) - __aurng()) / __p.lambda();
                	}
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two exponential distributions have the same
                       *        parameters.
                       */
                      friend bool
                      operator==(const exponential_distribution& __d1,
                		 const exponential_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                   * @brief Return true if two exponential distributions have different
                   *        parameters.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::exponential_distribution<_RealType>& __d1,
                	       const std::exponential_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %exponential_distribution random number distribution
                   * @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %exponential_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   * an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const std::exponential_distribution<_RealType>& __x);
                
                  /**
                   * @brief Extracts a %exponential_distribution random number distribution
                   * @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x A %exponential_distribution random number
                   *            generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       std::exponential_distribution<_RealType>& __x);
                
                
                  /**
                   * @brief A weibull_distribution random number distribution.
                   *
                   * The formula for the normal probability density function is:
                   * @f[
                   *     p(x|\alpha,\beta) = \frac{\alpha}{\beta} (\frac{x}{\beta})^{\alpha-1}
                   *                         \exp{(-(\frac{x}{\beta})^\alpha)} 
                   * @f]
                   */
                  template<typename _RealType = double>
                    class weibull_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef weibull_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __a = _RealType(1),
                		   _RealType __b = _RealType(1))
                	: _M_a(__a), _M_b(__b)
                	{ }
                
                	_RealType
                	a() const
                	{ return _M_a; }
                
                	_RealType
                	b() const
                	{ return _M_b; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
                
                      private:
                	_RealType _M_a;
                	_RealType _M_b;
                      };
                
                      explicit
                      weibull_distribution(_RealType __a = _RealType(1),
                			   _RealType __b = _RealType(1))
                      : _M_param(__a, __b)
                      { }
                
                      explicit
                      weibull_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { }
                
                      /**
                       * @brief Return the @f$a@f$ parameter of the distribution.
                       */
                      _RealType
                      a() const
                      { return _M_param.a(); }
                
                      /**
                       * @brief Return the @f$b@f$ parameter of the distribution.
                       */
                      _RealType
                      b() const
                      { return _M_param.b(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two Weibull distributions have the same
                       *        parameters.
                       */
                      friend bool
                      operator==(const weibull_distribution& __d1,
                		 const weibull_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                   /**
                    * @brief Return true if two Weibull distributions have different
                    *        parameters.
                    */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::weibull_distribution<_RealType>& __d1,
                	       const std::weibull_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %weibull_distribution random number distribution
                   * @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %weibull_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   * an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const std::weibull_distribution<_RealType>& __x);
                
                  /**
                   * @brief Extracts a %weibull_distribution random number distribution
                   * @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x A %weibull_distribution random number
                   *            generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       std::weibull_distribution<_RealType>& __x);
                
                
                  /**
                   * @brief A extreme_value_distribution random number distribution.
                   *
                   * The formula for the normal probability mass function is
                   * @f[
                   *     p(x|a,b) = \frac{1}{b}
                   *                \exp( \frac{a-x}{b} - \exp(\frac{a-x}{b})) 
                   * @f]
                   */
                  template<typename _RealType = double>
                    class extreme_value_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef extreme_value_distribution<_RealType> distribution_type;
                
                	explicit
                	param_type(_RealType __a = _RealType(0),
                		   _RealType __b = _RealType(1))
                	: _M_a(__a), _M_b(__b)
                	{ }
                
                	_RealType
                	a() const
                	{ return _M_a; }
                
                	_RealType
                	b() const
                	{ return _M_b; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
                
                      private:
                	_RealType _M_a;
                	_RealType _M_b;
                      };
                
                      explicit
                      extreme_value_distribution(_RealType __a = _RealType(0),
                				 _RealType __b = _RealType(1))
                      : _M_param(__a, __b)
                      { }
                
                      explicit
                      extreme_value_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { }
                
                      /**
                       * @brief Return the @f$a@f$ parameter of the distribution.
                       */
                      _RealType
                      a() const
                      { return _M_param.a(); }
                
                      /**
                       * @brief Return the @f$b@f$ parameter of the distribution.
                       */
                      _RealType
                      b() const
                      { return _M_param.b(); }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return std::numeric_limits<result_type>::lowest(); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      { return std::numeric_limits<result_type>::max(); }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two extreme value distributions have the same
                       *        parameters.
                       */
                      friend bool
                      operator==(const extreme_value_distribution& __d1,
                		 const extreme_value_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                    * @brief Return true if two extreme value distributions have different
                    *        parameters.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::extreme_value_distribution<_RealType>& __d1,
                	       const std::extreme_value_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                  /**
                   * @brief Inserts a %extreme_value_distribution random number distribution
                   * @p __x into the output stream @p __os.
                   *
                   * @param __os An output stream.
                   * @param __x  A %extreme_value_distribution random number distribution.
                   *
                   * @returns The output stream with the state of @p __x inserted or in
                   * an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const std::extreme_value_distribution<_RealType>& __x);
                
                  /**
                   * @brief Extracts a %extreme_value_distribution random number
                   *        distribution @p __x from the input stream @p __is.
                   *
                   * @param __is An input stream.
                   * @param __x A %extreme_value_distribution random number
                   *            generator engine.
                   *
                   * @returns The input stream with @p __x extracted or in an error state.
                   */
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       std::extreme_value_distribution<_RealType>& __x);
                
                
                  /**
                   * @brief A discrete_distribution random number distribution.
                   *
                   * The formula for the discrete probability mass function is
                   *
                   */
                  template<typename _IntType = int>
                    class discrete_distribution
                    {
                      static_assert(std::is_integral<_IntType>::value,
                		    "template argument not an integral type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _IntType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef discrete_distribution<_IntType> distribution_type;
                	friend class discrete_distribution<_IntType>;
                
                	param_type()
                	: _M_prob(), _M_cp()
                	{ }
                
                	template<typename _InputIterator>
                	  param_type(_InputIterator __wbegin,
                		     _InputIterator __wend)
                	  : _M_prob(__wbegin, __wend), _M_cp()
                	  { _M_initialize(); }
                
                	param_type(initializer_list<double> __wil)
                	: _M_prob(__wil.begin(), __wil.end()), _M_cp()
                	{ _M_initialize(); }
                
                	template<typename _Func>
                	  param_type(size_t __nw, double __xmin, double __xmax,
                		     _Func __fw);
                
                	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/
                	param_type(const param_type&) = default;
                	param_type& operator=(const param_type&) = default;
                
                	std::vector<double>
                	probabilities() const
                	{ return _M_prob.empty() ? std::vector<double>(1, 1.0) : _M_prob; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_prob == __p2._M_prob; }
                
                      private:
                	void
                	_M_initialize();
                
                	std::vector<double> _M_prob;
                	std::vector<double> _M_cp;
                      };
                
                      discrete_distribution()
                      : _M_param()
                      { }
                
                      template<typename _InputIterator>
                	discrete_distribution(_InputIterator __wbegin,
                			      _InputIterator __wend)
                	: _M_param(__wbegin, __wend)
                	{ }
                
                      discrete_distribution(initializer_list<double> __wl)
                      : _M_param(__wl)
                      { }
                
                      template<typename _Func>
                	discrete_distribution(size_t __nw, double __xmin, double __xmax,
                			      _Func __fw)
                	: _M_param(__nw, __xmin, __xmax, __fw)
                	{ }
                
                      explicit
                      discrete_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { }
                
                      /**
                       * @brief Returns the probabilities of the distribution.
                       */
                      std::vector<double>
                      probabilities() const
                      {
                	return _M_param._M_prob.empty()
                	  ? std::vector<double>(1, 1.0) : _M_param._M_prob;
                      }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      { return result_type(0); }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      {
                	return _M_param._M_prob.empty()
                	  ? result_type(0) : result_type(_M_param._M_prob.size() - 1);
                      }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two discrete distributions have the same
                       *        parameters.
                       */
                      friend bool
                      operator==(const discrete_distribution& __d1,
                		 const discrete_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                      /**
                       * @brief Inserts a %discrete_distribution random number distribution
                       * @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %discrete_distribution random number distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _IntType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::discrete_distribution<_IntType1>& __x);
                
                      /**
                       * @brief Extracts a %discrete_distribution random number distribution
                       * @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x A %discrete_distribution random number
                       *            generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error
                       *          state.
                       */
                      template<typename _IntType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::discrete_distribution<_IntType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                    * @brief Return true if two discrete distributions have different
                    *        parameters.
                    */
                  template<typename _IntType>
                    inline bool
                    operator!=(const std::discrete_distribution<_IntType>& __d1,
                	       const std::discrete_distribution<_IntType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief A piecewise_constant_distribution random number distribution.
                   *
                   * The formula for the piecewise constant probability mass function is
                   *
                   */
                  template<typename _RealType = double>
                    class piecewise_constant_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef piecewise_constant_distribution<_RealType> distribution_type;
                	friend class piecewise_constant_distribution<_RealType>;
                
                	param_type()
                	: _M_int(), _M_den(), _M_cp()
                	{ }
                
                	template<typename _InputIteratorB, typename _InputIteratorW>
                	  param_type(_InputIteratorB __bfirst,
                		     _InputIteratorB __bend,
                		     _InputIteratorW __wbegin);
                
                	template<typename _Func>
                	  param_type(initializer_list<_RealType> __bi, _Func __fw);
                
                	template<typename _Func>
                	  param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
                		     _Func __fw);
                
                	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/
                	param_type(const param_type&) = default;
                	param_type& operator=(const param_type&) = default;
                
                	std::vector<_RealType>
                	intervals() const
                	{
                	  if (_M_int.empty())
                	    {
                	      std::vector<_RealType> __tmp(2);
                	      __tmp[1] = _RealType(1);
                	      return __tmp;
                	    }
                	  else
                	    return _M_int;
                	}
                
                	std::vector<double>
                	densities() const
                	{ return _M_den.empty() ? std::vector<double>(1, 1.0) : _M_den; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den; }
                
                      private:
                	void
                	_M_initialize();
                
                	std::vector<_RealType> _M_int;
                	std::vector<double> _M_den;
                	std::vector<double> _M_cp;
                      };
                
                      explicit
                      piecewise_constant_distribution()
                      : _M_param()
                      { }
                
                      template<typename _InputIteratorB, typename _InputIteratorW>
                	piecewise_constant_distribution(_InputIteratorB __bfirst,
                					_InputIteratorB __bend,
                					_InputIteratorW __wbegin)
                	: _M_param(__bfirst, __bend, __wbegin)
                	{ }
                
                      template<typename _Func>
                	piecewise_constant_distribution(initializer_list<_RealType> __bl,
                					_Func __fw)
                	: _M_param(__bl, __fw)
                	{ }
                
                      template<typename _Func>
                	piecewise_constant_distribution(size_t __nw,
                					_RealType __xmin, _RealType __xmax,
                					_Func __fw)
                	: _M_param(__nw, __xmin, __xmax, __fw)
                	{ }
                
                      explicit
                      piecewise_constant_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * @brief Resets the distribution state.
                       */
                      void
                      reset()
                      { }
                
                      /**
                       * @brief Returns a vector of the intervals.
                       */
                      std::vector<_RealType>
                      intervals() const
                      {
                	if (_M_param._M_int.empty())
                	  {
                	    std::vector<_RealType> __tmp(2);
                	    __tmp[1] = _RealType(1);
                	    return __tmp;
                	  }
                	else
                	  return _M_param._M_int;
                      }
                
                      /**
                       * @brief Returns a vector of the probability densities.
                       */
                      std::vector<double>
                      densities() const
                      {
                	return _M_param._M_den.empty()
                	  ? std::vector<double>(1, 1.0) : _M_param._M_den;
                      }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      {
                	return _M_param._M_int.empty()
                	  ? result_type(0) : _M_param._M_int.front();
                      }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      {
                	return _M_param._M_int.empty()
                	  ? result_type(1) : _M_param._M_int.back();
                      }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two piecewise constant distributions have the
                       *        same parameters.
                       */
                      friend bool
                      operator==(const piecewise_constant_distribution& __d1,
                		 const piecewise_constant_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                      /**
                       * @brief Inserts a %piecewise_constant_distribution random
                       *        number distribution @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %piecewise_constant_distribution random number
                       *             distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       * an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::piecewise_constant_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %piecewise_constant_distribution random
                       *        number distribution @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x A %piecewise_constant_distribution random number
                       *            generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error
                       *          state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::piecewise_constant_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                    * @brief Return true if two piecewise constant distributions have 
                    *        different parameters.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::piecewise_constant_distribution<_RealType>& __d1,
                	       const std::piecewise_constant_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /**
                   * @brief A piecewise_linear_distribution random number distribution.
                   *
                   * The formula for the piecewise linear probability mass function is
                   *
                   */
                  template<typename _RealType = double>
                    class piecewise_linear_distribution
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                    public:
                      /** The type of the range of the distribution. */
                      typedef _RealType result_type;
                      /** Parameter type. */
                      struct param_type
                      {
                	typedef piecewise_linear_distribution<_RealType> distribution_type;
                	friend class piecewise_linear_distribution<_RealType>;
                
                	param_type()
                	: _M_int(), _M_den(), _M_cp(), _M_m()
                	{ }
                
                	template<typename _InputIteratorB, typename _InputIteratorW>
                	  param_type(_InputIteratorB __bfirst,
                		     _InputIteratorB __bend,
                		     _InputIteratorW __wbegin);
                
                	template<typename _Func>
                	  param_type(initializer_list<_RealType> __bl, _Func __fw);
                
                	template<typename _Func>
                	  param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
                		     _Func __fw);
                
                	// See: http://cpp-next.com/archive/2010/10/implicit-move-must-go/
                	param_type(const param_type&) = default;
                	param_type& operator=(const param_type&) = default;
                
                	std::vector<_RealType>
                	intervals() const
                	{
                	  if (_M_int.empty())
                	    {
                	      std::vector<_RealType> __tmp(2);
                	      __tmp[1] = _RealType(1);
                	      return __tmp;
                	    }
                	  else
                	    return _M_int;
                	}
                
                	std::vector<double>
                	densities() const
                	{ return _M_den.empty() ? std::vector<double>(2, 1.0) : _M_den; }
                
                	friend bool
                	operator==(const param_type& __p1, const param_type& __p2)
                	{ return (__p1._M_int == __p2._M_int
                		  && __p1._M_den == __p2._M_den); }
                
                      private:
                	void
                	_M_initialize();
                
                	std::vector<_RealType> _M_int;
                	std::vector<double> _M_den;
                	std::vector<double> _M_cp;
                	std::vector<double> _M_m;
                      };
                
                      explicit
                      piecewise_linear_distribution()
                      : _M_param()
                      { }
                
                      template<typename _InputIteratorB, typename _InputIteratorW>
                	piecewise_linear_distribution(_InputIteratorB __bfirst,
                				      _InputIteratorB __bend,
                				      _InputIteratorW __wbegin)
                	: _M_param(__bfirst, __bend, __wbegin)
                	{ }
                
                      template<typename _Func>
                	piecewise_linear_distribution(initializer_list<_RealType> __bl,
                				      _Func __fw)
                	: _M_param(__bl, __fw)
                	{ }
                
                      template<typename _Func>
                	piecewise_linear_distribution(size_t __nw,
                				      _RealType __xmin, _RealType __xmax,
                				      _Func __fw)
                	: _M_param(__nw, __xmin, __xmax, __fw)
                	{ }
                
                      explicit
                      piecewise_linear_distribution(const param_type& __p)
                      : _M_param(__p)
                      { }
                
                      /**
                       * Resets the distribution state.
                       */
                      void
                      reset()
                      { }
                
                      /**
                       * @brief Return the intervals of the distribution.
                       */
                      std::vector<_RealType>
                      intervals() const
                      {
                	if (_M_param._M_int.empty())
                	  {
                	    std::vector<_RealType> __tmp(2);
                	    __tmp[1] = _RealType(1);
                	    return __tmp;
                	  }
                	else
                	  return _M_param._M_int;
                      }
                
                      /**
                       * @brief Return a vector of the probability densities of the
                       *        distribution.
                       */
                      std::vector<double>
                      densities() const
                      {
                	return _M_param._M_den.empty()
                	  ? std::vector<double>(2, 1.0) : _M_param._M_den;
                      }
                
                      /**
                       * @brief Returns the parameter set of the distribution.
                       */
                      param_type
                      param() const
                      { return _M_param; }
                
                      /**
                       * @brief Sets the parameter set of the distribution.
                       * @param __param The new parameter set of the distribution.
                       */
                      void
                      param(const param_type& __param)
                      { _M_param = __param; }
                
                      /**
                       * @brief Returns the greatest lower bound value of the distribution.
                       */
                      result_type
                      min() const
                      {
                	return _M_param._M_int.empty()
                	  ? result_type(0) : _M_param._M_int.front();
                      }
                
                      /**
                       * @brief Returns the least upper bound value of the distribution.
                       */
                      result_type
                      max() const
                      {
                	return _M_param._M_int.empty()
                	  ? result_type(1) : _M_param._M_int.back();
                      }
                
                      /**
                       * @brief Generating functions.
                       */
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng)
                	{ return this->operator()(__urng, _M_param); }
                
                      template<typename _UniformRandomNumberGenerator>
                	result_type
                	operator()(_UniformRandomNumberGenerator& __urng,
                		   const param_type& __p);
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng)
                	{ this->__generate(__f, __t, __urng, _M_param); }
                
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate(_ForwardIterator __f, _ForwardIterator __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      template<typename _UniformRandomNumberGenerator>
                	void
                	__generate(result_type* __f, result_type* __t,
                		   _UniformRandomNumberGenerator& __urng,
                		   const param_type& __p)
                	{ this->__generate_impl(__f, __t, __urng, __p); }
                
                      /**
                       * @brief Return true if two piecewise linear distributions have the
                       *        same parameters.
                       */
                      friend bool
                      operator==(const piecewise_linear_distribution& __d1,
                		 const piecewise_linear_distribution& __d2)
                      { return __d1._M_param == __d2._M_param; }
                
                      /**
                       * @brief Inserts a %piecewise_linear_distribution random number
                       *        distribution @p __x into the output stream @p __os.
                       *
                       * @param __os An output stream.
                       * @param __x  A %piecewise_linear_distribution random number
                       *             distribution.
                       *
                       * @returns The output stream with the state of @p __x inserted or in
                       *          an error state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_ostream<_CharT, _Traits>&
                	operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                		   const std::piecewise_linear_distribution<_RealType1>& __x);
                
                      /**
                       * @brief Extracts a %piecewise_linear_distribution random number
                       *        distribution @p __x from the input stream @p __is.
                       *
                       * @param __is An input stream.
                       * @param __x  A %piecewise_linear_distribution random number
                       *             generator engine.
                       *
                       * @returns The input stream with @p __x extracted or in an error
                       *          state.
                       */
                      template<typename _RealType1, typename _CharT, typename _Traits>
                	friend std::basic_istream<_CharT, _Traits>&
                	operator>>(std::basic_istream<_CharT, _Traits>& __is,
                		   std::piecewise_linear_distribution<_RealType1>& __x);
                
                    private:
                      template<typename _ForwardIterator,
                	       typename _UniformRandomNumberGenerator>
                	void
                	__generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                			_UniformRandomNumberGenerator& __urng,
                			const param_type& __p);
                
                      param_type _M_param;
                    };
                
                  /**
                    * @brief Return true if two piecewise linear distributions have
                    *        different parameters.
                   */
                  template<typename _RealType>
                    inline bool
                    operator!=(const std::piecewise_linear_distribution<_RealType>& __d1,
                	       const std::piecewise_linear_distribution<_RealType>& __d2)
                    { return !(__d1 == __d2); }
                
                
                  /* @} */ // group random_distributions_poisson
                
                  /* @} */ // group random_distributions
                
                  /**
                   * @addtogroup random_utilities Random Number Utilities
                   * @ingroup random
                   * @{
                   */
                
                  /**
                   * @brief The seed_seq class generates sequences of seeds for random
                   *        number generators.
                   */
                  class seed_seq
                  {
                
                  public:
                    /** The type of the seed vales. */
                    typedef uint_least32_t result_type;
                
                    /** Default constructor. */
                    seed_seq()
                    : _M_v()
                    { }
                
                    template<typename _IntType>
                      seed_seq(std::initializer_list<_IntType> il);
                
                    template<typename _InputIterator>
                      seed_seq(_InputIterator __begin, _InputIterator __end);
                
                    // generating functions
                    template<typename _RandomAccessIterator>
                      void
                      generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);
                
                    // property functions
                    size_t size() const
                    { return _M_v.size(); }
                
                    template<typename OutputIterator>
                      void
                      param(OutputIterator __dest) const
                      { std::copy(_M_v.begin(), _M_v.end(), __dest); }
                
                  private:
                    ///
                    std::vector<result_type> _M_v;
                  };
                
                  /* @} */ // group random_utilities
                
                  /* @} */ // group random
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      138          3
      149          3
      270          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        7   Total number of line executions
     2.33   Average executions per line


*** File /usr/include/c++/5/ext/string_conversions.h:
                // String Conversions -*- C++ -*-
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/string_conversions.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _STRING_CONVERSIONS_H
                #define _STRING_CONVERSIONS_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <bits/c++config.h>
                #include <ext/numeric_traits.h>
                #include <bits/functexcept.h>
                #include <cstdlib>
                #include <cwchar>
                #include <cstdio>
                #include <cerrno>
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Helper for all the sto* functions.
                  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
                	   typename... _Base>
                    _Ret
                    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
                	   const char* __name, const _CharT* __str, std::size_t* __idx,
                	   _Base... __base)
                    {
                      _Ret __ret;
                
                      _CharT* __endptr;
                      errno = 0;
                      const _TRet __tmp = __convf(__str, &__endptr, __base...);
                
                      if (__endptr == __str)
                	std::__throw_invalid_argument(__name);
                      else if (errno == ERANGE
                	       || (std::__are_same<_Ret, int>::__value
                		   && (__tmp < __numeric_traits<int>::__min
                		       || __tmp > __numeric_traits<int>::__max)))
                	std::__throw_out_of_range(__name);
                      else
                	__ret = __tmp;
                
                      if (__idx)
                	*__idx = __endptr - __str;
                
                      return __ret;
                    }
                
                  // Helper for the to_string / to_wstring functions.
                  template<typename _String, typename _CharT = typename _String::value_type>
                    _String
          16 ->     __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
                				 __builtin_va_list), std::size_t __n,
                		 const _CharT* __fmt, ...)
                    {
                      // XXX Eventually the result will be constructed in place in
                      // the C++0x string, likely with the help of internal hooks.
                      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                							  * __n));
                
                      __builtin_va_list __args;
                      __builtin_va_start(__args, __fmt);
                
                      const int __len = __convf(__s, __n, __fmt, __args);
                
                      __builtin_va_end(__args);
                
                      return _String(__s, __s + __len);
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif // C++11
                
                #endif // _STRING_CONVERSIONS_H


Top 10 Lines:

     Line      Count

       83         16

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       16   Total number of line executions
    16.00   Average executions per line


*** File /usr/include/c++/5/bits/random.tcc:
                // random number generation (out of line) -*- C++ -*-
                
                // Copyright (C) 2009-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/random.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{random}
                 */
                
                #ifndef _RANDOM_TCC
                #define _RANDOM_TCC 1
                
                #include <numeric> // std::accumulate and std::partial_sum
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                  /*
                   * (Further) implementation-space details.
                   */
                  namespace __detail
                  {
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                    // General case for x = (ax + c) mod m -- use Schrage's algorithm
                    // to avoid integer overflow.
                    //
                    // Preconditions:  a > 0, m > 0.
                    //
                    // Note: only works correctly for __m % __a < __m / __a.
                    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
                      _Tp
                      _Mod<_Tp, __m, __a, __c, false, true>::
                      __calc(_Tp __x)
                      {
                	if (__a == 1)
                	  __x %= __m;
                	else
                	  {
                	    static const _Tp __q = __m / __a;
                	    static const _Tp __r = __m % __a;
                
                	    _Tp __t1 = __a * (__x % __q);
                	    _Tp __t2 = __r * (__x / __q);
                	    if (__t1 >= __t2)
                	      __x = __t1 - __t2;
                	    else
                	      __x = __m - __t2 + __t1;
                	  }
                
                	if (__c != 0)
                	  {
                	    const _Tp __d = __m - __x;
                	    if (__d > __c)
                	      __x += __c;
                	    else
                	      __x = __c - __d;
                	  }
                	return __x;
                      }
                
                    template<typename _InputIterator, typename _OutputIterator,
                	     typename _Tp>
                      _OutputIterator
                      __normalize(_InputIterator __first, _InputIterator __last,
                		  _OutputIterator __result, const _Tp& __factor)
                      {
                	for (; __first != __last; ++__first, ++__result)
                	  *__result = *__first / __factor;
                	return __result;
                      }
                
                  _GLIBCXX_END_NAMESPACE_VERSION
                  } // namespace __detail
                
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::increment;
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    constexpr _UIntType
                    linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;
                
                  /**
                   * Seeds the LCR with integral value @p __s, adjusted so that the
                   * ring identity is never a member of the convergence set.
                   */
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    void
           1 ->     linear_congruential_engine<_UIntType, __a, __c, __m>::
                    seed(result_type __s)
                    {
                      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
                	  && (__detail::__mod<_UIntType, __m>(__s) == 0))
                	_M_x = 1;
                      else
                	_M_x = __detail::__mod<_UIntType, __m>(__s);
                    }
                
                  /**
                   * Seeds the LCR engine with a value generated by @p __q.
                   */
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
                    template<typename _Sseq>
                      typename std::enable_if<std::is_class<_Sseq>::value>::type
                      linear_congruential_engine<_UIntType, __a, __c, __m>::
                      seed(_Sseq& __q)
                      {
                	const _UIntType __k0 = __m == 0 ? std::numeric_limits<_UIntType>::digits
                	                                : std::__lg(__m);
                	const _UIntType __k = (__k0 + 31) / 32;
                	uint_least32_t __arr[__k + 3];
                	__q.generate(__arr + 0, __arr + __k + 3);
                	_UIntType __factor = 1u;
                	_UIntType __sum = 0u;
                	for (size_t __j = 0; __j < __k; ++__j)
                	  {
                	    __sum += __arr[__j + 3] * __factor;
                	    __factor *= __detail::_Shift<_UIntType, 32>::__value;
                	  }
                	seed(__sum);
                      }
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const linear_congruential_engine<_UIntType,
                						__a, __c, __m>& __lcr)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__os.widen(' '));
                
                      __os << __lcr._M_x;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       linear_congruential_engine<_UIntType, __a, __c, __m>& __lcr)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec);
                
                      __is >> __lcr._M_x;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::word_size;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::state_size;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::shift_size;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::mask_bits;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::xor_mask;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_u;
                   
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_d;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_s;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_b;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_t;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_c;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr size_t
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::tempering_l;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                                                              initialization_multiplier;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    constexpr _UIntType
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::default_seed;
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    void
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    seed(result_type __sd)
                    {
                      _M_x[0] = __detail::__mod<_UIntType,
                	__detail::_Shift<_UIntType, __w>::__value>(__sd);
                
                      for (size_t __i = 1; __i < state_size; ++__i)
                	{
                	  _UIntType __x = _M_x[__i - 1];
                	  __x ^= __x >> (__w - 2);
                	  __x *= __f;
                	  __x += __detail::__mod<_UIntType, __n>(__i);
                	  _M_x[__i] = __detail::__mod<_UIntType,
                	    __detail::_Shift<_UIntType, __w>::__value>(__x);
                	}
                      _M_p = state_size;
                    }
                
                  template<typename _UIntType,
                	   size_t __w, size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    template<typename _Sseq>
                      typename std::enable_if<std::is_class<_Sseq>::value>::type
                      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			      __s, __b, __t, __c, __l, __f>::
                      seed(_Sseq& __q)
                      {
                	const _UIntType __upper_mask = (~_UIntType()) << __r;
                	const size_t __k = (__w + 31) / 32;
                	uint_least32_t __arr[__n * __k];
                	__q.generate(__arr + 0, __arr + __n * __k);
                
                	bool __zero = true;
                	for (size_t __i = 0; __i < state_size; ++__i)
                	  {
                	    _UIntType __factor = 1u;
                	    _UIntType __sum = 0u;
                	    for (size_t __j = 0; __j < __k; ++__j)
                	      {
                		__sum += __arr[__k * __i + __j] * __factor;
                		__factor *= __detail::_Shift<_UIntType, 32>::__value;
                	      }
                	    _M_x[__i] = __detail::__mod<_UIntType,
                	      __detail::_Shift<_UIntType, __w>::__value>(__sum);
                
                	    if (__zero)
                	      {
                		if (__i == 0)
                		  {
                		    if ((_M_x[0] & __upper_mask) != 0u)
                		      __zero = false;
                		  }
                		else if (_M_x[__i] != 0u)
                		  __zero = false;
                	      }
                	  }
                        if (__zero)
                          _M_x[0] = __detail::_Shift<_UIntType, __w - 1>::__value;
                	_M_p = state_size;
                      }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    void
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    _M_gen_rand(void)
                    {
                      const _UIntType __upper_mask = (~_UIntType()) << __r;
                      const _UIntType __lower_mask = ~__upper_mask;
                
                      for (size_t __k = 0; __k < (__n - __m); ++__k)
                        {
                	  _UIntType __y = ((_M_x[__k] & __upper_mask)
                			   | (_M_x[__k + 1] & __lower_mask));
                	  _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
                		       ^ ((__y & 0x01) ? __a : 0));
                        }
                
                      for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
                	{
                	  _UIntType __y = ((_M_x[__k] & __upper_mask)
                			   | (_M_x[__k + 1] & __lower_mask));
                	  _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
                		       ^ ((__y & 0x01) ? __a : 0));
                	}
                
                      _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
                		       | (_M_x[0] & __lower_mask));
                      _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
                		       ^ ((__y & 0x01) ? __a : 0));
                      _M_p = 0;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    void
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    discard(unsigned long long __z)
                    {
                      while (__z > state_size - _M_p)
                	{
                	  __z -= state_size - _M_p;
                	  _M_gen_rand();
                	}
                      _M_p += __z;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f>
                    typename
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::result_type
                    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
                			    __s, __b, __t, __c, __l, __f>::
                    operator()()
                    {
                      // Reload the vector - cost is O(n) amortized over n calls.
                      if (_M_p >= state_size)
                	_M_gen_rand();
                
                      // Calculate o(x(i)).
                      result_type __z = _M_x[_M_p++];
                      __z ^= (__z >> __u) & __d;
                      __z ^= (__z << __s) & __b;
                      __z ^= (__z << __t) & __c;
                      __z ^= (__z >> __l);
                
                      return __z;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const mersenne_twister_engine<_UIntType, __w, __n, __m,
                	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      for (size_t __i = 0; __i < __n; ++__i)
                	__os << __x._M_x[__i] << __space;
                      __os << __x._M_p;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _UIntType, size_t __w,
                	   size_t __n, size_t __m, size_t __r,
                	   _UIntType __a, size_t __u, _UIntType __d, size_t __s,
                	   _UIntType __b, size_t __t, _UIntType __c, size_t __l,
                	   _UIntType __f, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       mersenne_twister_engine<_UIntType, __w, __n, __m,
                	       __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      for (size_t __i = 0; __i < __n; ++__i)
                	__is >> __x._M_x[__i];
                      __is >> __x._M_p;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr size_t
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr size_t
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr size_t
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    constexpr _UIntType
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    void
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                    seed(result_type __value)
                    {
                      std::linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
                	__lcg(__value == 0u ? default_seed : __value);
                
                      const size_t __n = (__w + 31) / 32;
                
                      for (size_t __i = 0; __i < long_lag; ++__i)
                	{
                	  _UIntType __sum = 0u;
                	  _UIntType __factor = 1u;
                	  for (size_t __j = 0; __j < __n; ++__j)
                	    {
                	      __sum += __detail::__mod<uint_least32_t,
                		       __detail::_Shift<uint_least32_t, 32>::__value>
                			 (__lcg()) * __factor;
                	      __factor *= __detail::_Shift<_UIntType, 32>::__value;
                	    }
                	  _M_x[__i] = __detail::__mod<_UIntType,
                	    __detail::_Shift<_UIntType, __w>::__value>(__sum);
                	}
                      _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
                      _M_p = 0;
                    }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    template<typename _Sseq>
                      typename std::enable_if<std::is_class<_Sseq>::value>::type
                      subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                      seed(_Sseq& __q)
                      {
                	const size_t __k = (__w + 31) / 32;
                	uint_least32_t __arr[__r * __k];
                	__q.generate(__arr + 0, __arr + __r * __k);
                
                	for (size_t __i = 0; __i < long_lag; ++__i)
                	  {
                	    _UIntType __sum = 0u;
                	    _UIntType __factor = 1u;
                	    for (size_t __j = 0; __j < __k; ++__j)
                	      {
                		__sum += __arr[__k * __i + __j] * __factor;
                		__factor *= __detail::_Shift<_UIntType, 32>::__value;
                	      }
                	    _M_x[__i] = __detail::__mod<_UIntType,
                	      __detail::_Shift<_UIntType, __w>::__value>(__sum);
                	  }
                	_M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
                	_M_p = 0;
                      }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
                    typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                	     result_type
                    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
                    operator()()
                    {
                      // Derive short lag index from current index.
                      long __ps = _M_p - short_lag;
                      if (__ps < 0)
                	__ps += long_lag;
                
                      // Calculate new x(i) without overflow or division.
                      // NB: Thanks to the requirements for _UIntType, _M_x[_M_p] + _M_carry
                      // cannot overflow.
                      _UIntType __xi;
                      if (_M_x[__ps] >= _M_x[_M_p] + _M_carry)
                	{
                	  __xi = _M_x[__ps] - _M_x[_M_p] - _M_carry;
                	  _M_carry = 0;
                	}
                      else
                	{
                	  __xi = (__detail::_Shift<_UIntType, __w>::__value
                		  - _M_x[_M_p] - _M_carry + _M_x[__ps]);
                	  _M_carry = 1;
                	}
                      _M_x[_M_p] = __xi;
                
                      // Adjust current index to loop around in ring buffer.
                      if (++_M_p >= long_lag)
                	_M_p = 0;
                
                      return __xi;
                    }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const subtract_with_carry_engine<_UIntType,
                						__w, __s, __r>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      for (size_t __i = 0; __i < __r; ++__i)
                	__os << __x._M_x[__i] << __space;
                      __os << __x._M_carry << __space << __x._M_p;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       subtract_with_carry_engine<_UIntType, __w, __s, __r>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      for (size_t __i = 0; __i < __r; ++__i)
                	__is >> __x._M_x[__i];
                      __is >> __x._M_carry;
                      __is >> __x._M_p;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    constexpr size_t
                    discard_block_engine<_RandomNumberEngine, __p, __r>::block_size;
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    constexpr size_t
                    discard_block_engine<_RandomNumberEngine, __p, __r>::used_block;
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r>
                    typename discard_block_engine<_RandomNumberEngine,
                			   __p, __r>::result_type
                    discard_block_engine<_RandomNumberEngine, __p, __r>::
                    operator()()
                    {
                      if (_M_n >= used_block)
                	{
                	  _M_b.discard(block_size - _M_n);
                	  _M_n = 0;
                	}
                      ++_M_n;
                      return _M_b();
                    }
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const discard_block_engine<_RandomNumberEngine,
                	       __p, __r>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      __os << __x.base() << __space << __x._M_n;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _RandomNumberEngine, size_t __p, size_t __r,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       discard_block_engine<_RandomNumberEngine, __p, __r>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      __is >> __x._M_b >> __x._M_n;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
                    typename independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
                      result_type
                    independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
                    operator()()
                    {
                      typedef typename _RandomNumberEngine::result_type _Eresult_type;
                      const _Eresult_type __r
                	= (_M_b.max() - _M_b.min() < std::numeric_limits<_Eresult_type>::max()
                	   ? _M_b.max() - _M_b.min() + 1 : 0);
                      const unsigned __edig = std::numeric_limits<_Eresult_type>::digits;
                      const unsigned __m = __r ? std::__lg(__r) : __edig;
                
                      typedef typename std::common_type<_Eresult_type, result_type>::type
                	__ctype;
                      const unsigned __cdig = std::numeric_limits<__ctype>::digits;
                
                      unsigned __n, __n0;
                      __ctype __s0, __s1, __y0, __y1;
                
                      for (size_t __i = 0; __i < 2; ++__i)
                	{
                	  __n = (__w + __m - 1) / __m + __i;
                	  __n0 = __n - __w % __n;
                	  const unsigned __w0 = __w / __n;  // __w0 <= __m
                
                	  __s0 = 0;
                	  __s1 = 0;
                	  if (__w0 < __cdig)
                	    {
                	      __s0 = __ctype(1) << __w0;
                	      __s1 = __s0 << 1;
                	    }
                
                	  __y0 = 0;
                	  __y1 = 0;
                	  if (__r)
                	    {
                	      __y0 = __s0 * (__r / __s0);
                	      if (__s1)
                		__y1 = __s1 * (__r / __s1);
                
                	      if (__r - __y0 <= __y0 / __n)
                		break;
                	    }
                	  else
                	    break;
                	}
                
                      result_type __sum = 0;
                      for (size_t __k = 0; __k < __n0; ++__k)
                	{
                	  __ctype __u;
                	  do
                	    __u = _M_b() - _M_b.min();
                	  while (__y0 && __u >= __y0);
                	  __sum = __s0 * __sum + (__s0 ? __u % __s0 : __u);
                	}
                      for (size_t __k = __n0; __k < __n; ++__k)
                	{
                	  __ctype __u;
                	  do
                	    __u = _M_b() - _M_b.min();
                	  while (__y1 && __u >= __y1);
                	  __sum = __s1 * __sum + (__s1 ? __u % __s1 : __u);
                	}
                      return __sum;
                    }
                
                
                  template<typename _RandomNumberEngine, size_t __k>
                    constexpr size_t
                    shuffle_order_engine<_RandomNumberEngine, __k>::table_size;
                
                  template<typename _RandomNumberEngine, size_t __k>
                    typename shuffle_order_engine<_RandomNumberEngine, __k>::result_type
                    shuffle_order_engine<_RandomNumberEngine, __k>::
                    operator()()
                    {
                      size_t __j = __k * ((_M_y - _M_b.min())
                			  / (_M_b.max() - _M_b.min() + 1.0L));
                      _M_y = _M_v[__j];
                      _M_v[__j] = _M_b();
                
                      return _M_y;
                    }
                
                  template<typename _RandomNumberEngine, size_t __k,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const shuffle_order_engine<_RandomNumberEngine, __k>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
                      __os.fill(__space);
                
                      __os << __x.base();
                      for (size_t __i = 0; __i < __k; ++__i)
                	__os << __space << __x._M_v[__i];
                      __os << __space << __x._M_y;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _RandomNumberEngine, size_t __k,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       shuffle_order_engine<_RandomNumberEngine, __k>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      __is >> __x._M_b;
                      for (size_t __i = 0; __i < __k; ++__i)
                	__is >> __x._M_v[__i];
                      __is >> __x._M_y;
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename uniform_int_distribution<_IntType>::result_type
                      uniform_int_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	typedef typename _UniformRandomNumberGenerator::result_type
                	  _Gresult_type;
                	typedef typename std::make_unsigned<result_type>::type __utype;
                	typedef typename std::common_type<_Gresult_type, __utype>::type
                	  __uctype;
                
                	const __uctype __urngmin = __urng.min();
                	const __uctype __urngmax = __urng.max();
                	const __uctype __urngrange = __urngmax - __urngmin;
                	const __uctype __urange
                	  = __uctype(__param.b()) - __uctype(__param.a());
                
                	__uctype __ret;
                
                	if (__urngrange > __urange)
                	  {
                	    // downscaling
                	    const __uctype __uerange = __urange + 1; // __urange can be zero
                	    const __uctype __scaling = __urngrange / __uerange;
                	    const __uctype __past = __uerange * __scaling;
                	    do
                	      __ret = __uctype(__urng()) - __urngmin;
                	    while (__ret >= __past);
                	    __ret /= __scaling;
                	  }
                	else if (__urngrange < __urange)
                	  {
                	    // upscaling
                	    /*
                	      Note that every value in [0, urange]
                	      can be written uniquely as
                
                	      (urngrange + 1) * high + low
                
                	      where
                
                	      high in [0, urange / (urngrange + 1)]
                
                	      and
                	
                	      low in [0, urngrange].
                	    */
                	    __uctype __tmp; // wraparound control
                	    do
                	      {
                		const __uctype __uerngrange = __urngrange + 1;
                		__tmp = (__uerngrange * operator()
                			 (__urng, param_type(0, __urange / __uerngrange)));
                		__ret = __tmp + (__uctype(__urng()) - __urngmin);
                	      }
                	    while (__ret > __urange || __ret < __tmp);
                	  }
                	else
                	  __ret = __uctype(__urng()) - __urngmin;
                
                	return __ret + __param.a();
                      }
                
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      uniform_int_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	typedef typename _UniformRandomNumberGenerator::result_type
                	  _Gresult_type;
                	typedef typename std::make_unsigned<result_type>::type __utype;
                	typedef typename std::common_type<_Gresult_type, __utype>::type
                	  __uctype;
                
                	const __uctype __urngmin = __urng.min();
                	const __uctype __urngmax = __urng.max();
                	const __uctype __urngrange = __urngmax - __urngmin;
                	const __uctype __urange
                	  = __uctype(__param.b()) - __uctype(__param.a());
                
                	__uctype __ret;
                
                	if (__urngrange > __urange)
                	  {
                	    if (__detail::_Power_of_2(__urngrange + 1)
                		&& __detail::_Power_of_2(__urange + 1))
                	      {
                		while (__f != __t)
                		  {
                		    __ret = __uctype(__urng()) - __urngmin;
                		    *__f++ = (__ret & __urange) + __param.a();
                		  }
                	      }
                	    else
                	      {
                		// downscaling
                		const __uctype __uerange = __urange + 1; // __urange can be zero
                		const __uctype __scaling = __urngrange / __uerange;
                		const __uctype __past = __uerange * __scaling;
                		while (__f != __t)
                		  {
                		    do
                		      __ret = __uctype(__urng()) - __urngmin;
                		    while (__ret >= __past);
                		    *__f++ = __ret / __scaling + __param.a();
                		  }
                	      }
                	  }
                	else if (__urngrange < __urange)
                	  {
                	    // upscaling
                	    /*
                	      Note that every value in [0, urange]
                	      can be written uniquely as
                
                	      (urngrange + 1) * high + low
                
                	      where
                
                	      high in [0, urange / (urngrange + 1)]
                
                	      and
                
                	      low in [0, urngrange].
                	    */
                	    __uctype __tmp; // wraparound control
                	    while (__f != __t)
                	      {
                		do
                		  {
                		    const __uctype __uerngrange = __urngrange + 1;
                		    __tmp = (__uerngrange * operator()
                			     (__urng, param_type(0, __urange / __uerngrange)));
                		    __ret = __tmp + (__uctype(__urng()) - __urngmin);
                		  }
                		while (__ret > __urange || __ret < __tmp);
                		*__f++ = __ret;
                	      }
                	  }
                	else
                	  while (__f != __t)
                	    *__f++ = __uctype(__urng()) - __urngmin + __param.a();
                      }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const uniform_int_distribution<_IntType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      return __os;
                    }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       uniform_int_distribution<_IntType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _IntType __a, __b;
                      __is >> __a >> __b;
                      __x.param(typename uniform_int_distribution<_IntType>::
                		param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      uniform_real_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	auto __range = __p.b() - __p.a();
                	while (__f != __t)
                	  *__f++ = __aurng() * __range + __p.a();
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const uniform_real_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       uniform_real_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      _RealType __a, __b;
                      __is >> __a >> __b;
                      __x.param(typename uniform_real_distribution<_RealType>::
                		param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _ForwardIterator,
                	   typename _UniformRandomNumberGenerator>
                    void
                    std::bernoulli_distribution::
                    __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		    _UniformRandomNumberGenerator& __urng,
                		    const param_type& __p)
                    {
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	__aurng(__urng);
                      auto __limit = __p.p() * (__aurng.max() - __aurng.min());
                
                      while (__f != __t)
                	*__f++ = (__aurng() - __aurng.min()) < __limit;
                    }
                
                  template<typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const bernoulli_distribution& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.p();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename geometric_distribution<_IntType>::result_type
                      geometric_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	// About the epsilon thing see this thread:
                	// http://gcc.gnu.org/ml/gcc-patches/2006-10/msg00971.html
                	const double __naf =
                	  (1 - std::numeric_limits<double>::epsilon()) / 2;
                	// The largest _RealType convertible to _IntType.
                	const double __thr =
                	  std::numeric_limits<_IntType>::max() + __naf;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	double __cand;
                	do
                	  __cand = std::floor(std::log(1.0 - __aurng()) / __param._M_log_1_p);
                	while (__cand >= __thr);
                
                	return result_type(__cand + __naf);
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      geometric_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// About the epsilon thing see this thread:
                	// http://gcc.gnu.org/ml/gcc-patches/2006-10/msg00971.html
                	const double __naf =
                	  (1 - std::numeric_limits<double>::epsilon()) / 2;
                	// The largest _RealType convertible to _IntType.
                	const double __thr =
                	  std::numeric_limits<_IntType>::max() + __naf;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	while (__f != __t)
                	  {
                	    double __cand;
                	    do
                	      __cand = std::floor(std::log(1.0 - __aurng())
                				  / __param._M_log_1_p);
                	    while (__cand >= __thr);
                
                	    *__f++ = __cand + __naf;
                	  }
                      }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const geometric_distribution<_IntType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.p();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       geometric_distribution<_IntType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      double __p;
                      __is >> __p;
                      __x.param(typename geometric_distribution<_IntType>::param_type(__p));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                  // This is Leger's algorithm, also in Devroye, Ch. X, Example 1.5.
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename negative_binomial_distribution<_IntType>::result_type
                      negative_binomial_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng)
                      {
                	const double __y = _M_gd(__urng);
                
                	// XXX Is the constructor too slow?
                	std::poisson_distribution<result_type> __poisson(__y);
                	return __poisson(__urng);
                      }
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename negative_binomial_distribution<_IntType>::result_type
                      negative_binomial_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	typedef typename std::gamma_distribution<double>::param_type
                	  param_type;
                	
                	const double __y =
                	  _M_gd(__urng, param_type(__p.k(), (1.0 - __p.p()) / __p.p()));
                
                	std::poisson_distribution<result_type> __poisson(__y);
                	return __poisson(__urng);
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      negative_binomial_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  {
                	    const double __y = _M_gd(__urng);
                
                	    // XXX Is the constructor too slow?
                	    std::poisson_distribution<result_type> __poisson(__y);
                	    *__f++ = __poisson(__urng);
                	  }
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      negative_binomial_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	typename std::gamma_distribution<result_type>::param_type
                	  __p2(__p.k(), (1.0 - __p.p()) / __p.p());
                
                	while (__f != __t)
                	  {
                	    const double __y = _M_gd(__urng, __p2);
                
                	    std::poisson_distribution<result_type> __poisson(__y);
                	    *__f++ = __poisson(__urng);
                	  }
                      }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const negative_binomial_distribution<_IntType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.k() << __space << __x.p()
                	   << __space << __x._M_gd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       negative_binomial_distribution<_IntType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      _IntType __k;
                      double __p;
                      __is >> __k >> __p >> __x._M_gd;
                      __x.param(typename negative_binomial_distribution<_IntType>::
                		param_type(__k, __p));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    void
                    poisson_distribution<_IntType>::param_type::
                    _M_initialize()
                    {
                #if _GLIBCXX_USE_C99_MATH_TR1
                      if (_M_mean >= 12)
                	{
                	  const double __m = std::floor(_M_mean);
                	  _M_lm_thr = std::log(_M_mean);
                	  _M_lfm = std::lgamma(__m + 1);
                	  _M_sm = std::sqrt(__m);
                
                	  const double __pi_4 = 0.7853981633974483096156608458198757L;
                	  const double __dx = std::sqrt(2 * __m * std::log(32 * __m
                							      / __pi_4));
                	  _M_d = std::round(std::max(6.0, std::min(__m, __dx)));
                	  const double __cx = 2 * __m + _M_d;
                	  _M_scx = std::sqrt(__cx / 2);
                	  _M_1cx = 1 / __cx;
                
                	  _M_c2b = std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx);
                	  _M_cb = 2 * __cx * std::exp(-_M_d * _M_1cx * (1 + _M_d / 2))
                		/ _M_d;
                	}
                      else
                #endif
                	_M_lm_thr = std::exp(-_M_mean);
                      }
                
                  /**
                   * A rejection algorithm when mean >= 12 and a simple method based
                   * upon the multiplication of uniform random variates otherwise.
                   * NB: The former is available only if _GLIBCXX_USE_C99_MATH_TR1
                   * is defined.
                   *
                   * Reference:
                   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
                   * New York, 1986, Ch. X, Sects. 3.3 & 3.4 (+ Errata!).
                   */
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename poisson_distribution<_IntType>::result_type
                      poisson_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                #if _GLIBCXX_USE_C99_MATH_TR1
                	if (__param.mean() >= 12)
                	  {
                	    double __x;
                
                	    // See comments above...
                	    const double __naf =
                	      (1 - std::numeric_limits<double>::epsilon()) / 2;
                	    const double __thr =
                	      std::numeric_limits<_IntType>::max() + __naf;
                
                	    const double __m = std::floor(__param.mean());
                	    // sqrt(pi / 2)
                	    const double __spi_2 = 1.2533141373155002512078826424055226L;
                	    const double __c1 = __param._M_sm * __spi_2;
                	    const double __c2 = __param._M_c2b + __c1;
                	    const double __c3 = __c2 + 1;
                	    const double __c4 = __c3 + 1;
                	    // e^(1 / 78)
                	    const double __e178 = 1.0129030479320018583185514777512983L;
                	    const double __c5 = __c4 + __e178;
                	    const double __c = __param._M_cb + __c5;
                	    const double __2cx = 2 * (2 * __m + __param._M_d);
                
                	    bool __reject = true;
                	    do
                	      {
                		const double __u = __c * __aurng();
                		const double __e = -std::log(1.0 - __aurng());
                
                		double __w = 0.0;
                
                		if (__u <= __c1)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = -std::abs(__n) * __param._M_sm - 1;
                		    __x = std::floor(__y);
                		    __w = -__n * __n / 2;
                		    if (__x < -__m)
                		      continue;
                		  }
                		else if (__u <= __c2)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = 1 + std::abs(__n) * __param._M_scx;
                		    __x = std::ceil(__y);
                		    __w = __y * (2 - __y) * __param._M_1cx;
                		    if (__x > __param._M_d)
                		      continue;
                		  }
                		else if (__u <= __c3)
                		  // NB: This case not in the book, nor in the Errata,
                		  // but should be ok...
                		  __x = -1;
                		else if (__u <= __c4)
                		  __x = 0;
                		else if (__u <= __c5)
                		  __x = 1;
                		else
                		  {
                		    const double __v = -std::log(1.0 - __aurng());
                		    const double __y = __param._M_d
                				     + __v * __2cx / __param._M_d;
                		    __x = std::ceil(__y);
                		    __w = -__param._M_d * __param._M_1cx * (1 + __y / 2);
                		  }
                
                		__reject = (__w - __e - __x * __param._M_lm_thr
                			    > __param._M_lfm - std::lgamma(__x + __m + 1));
                
                		__reject |= __x + __m >= __thr;
                
                	      } while (__reject);
                
                	    return result_type(__x + __m + __naf);
                	  }
                	else
                #endif
                	  {
                	    _IntType     __x = 0;
                	    double __prod = 1.0;
                
                	    do
                	      {
                		__prod *= __aurng();
                		__x += 1;
                	      }
                	    while (__prod > __param._M_lm_thr);
                
                	    return __x - 1;
                	  }
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      poisson_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// We could duplicate everything from operator()...
                	while (__f != __t)
                	  *__f++ = this->operator()(__urng, __param);
                      }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const poisson_distribution<_IntType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.mean() << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       poisson_distribution<_IntType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::skipws);
                
                      double __mean;
                      __is >> __mean >> __x._M_nd;
                      __x.param(typename poisson_distribution<_IntType>::param_type(__mean));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    void
                    binomial_distribution<_IntType>::param_type::
                    _M_initialize()
                    {
                      const double __p12 = _M_p <= 0.5 ? _M_p : 1.0 - _M_p;
                
                      _M_easy = true;
                
                #if _GLIBCXX_USE_C99_MATH_TR1
                      if (_M_t * __p12 >= 8)
                	{
                	  _M_easy = false;
                	  const double __np = std::floor(_M_t * __p12);
                	  const double __pa = __np / _M_t;
                	  const double __1p = 1 - __pa;
                
                	  const double __pi_4 = 0.7853981633974483096156608458198757L;
                	  const double __d1x =
                	    std::sqrt(__np * __1p * std::log(32 * __np
                					     / (81 * __pi_4 * __1p)));
                	  _M_d1 = std::round(std::max(1.0, __d1x));
                	  const double __d2x =
                	    std::sqrt(__np * __1p * std::log(32 * _M_t * __1p
                					     / (__pi_4 * __pa)));
                	  _M_d2 = std::round(std::max(1.0, __d2x));
                
                	  // sqrt(pi / 2)
                	  const double __spi_2 = 1.2533141373155002512078826424055226L;
                	  _M_s1 = std::sqrt(__np * __1p) * (1 + _M_d1 / (4 * __np));
                	  _M_s2 = std::sqrt(__np * __1p) * (1 + _M_d2 / (4 * _M_t * __1p));
                	  _M_c = 2 * _M_d1 / __np;
                	  _M_a1 = std::exp(_M_c) * _M_s1 * __spi_2;
                	  const double __a12 = _M_a1 + _M_s2 * __spi_2;
                	  const double __s1s = _M_s1 * _M_s1;
                	  _M_a123 = __a12 + (std::exp(_M_d1 / (_M_t * __1p))
                			     * 2 * __s1s / _M_d1
                			     * std::exp(-_M_d1 * _M_d1 / (2 * __s1s)));
                	  const double __s2s = _M_s2 * _M_s2;
                	  _M_s = (_M_a123 + 2 * __s2s / _M_d2
                		  * std::exp(-_M_d2 * _M_d2 / (2 * __s2s)));
                	  _M_lf = (std::lgamma(__np + 1)
                		   + std::lgamma(_M_t - __np + 1));
                	  _M_lp1p = std::log(__pa / __1p);
                
                	  _M_q = -std::log(1 - (__p12 - __pa) / __1p);
                	}
                      else
                #endif
                	_M_q = -std::log(1 - __p12);
                    }
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename binomial_distribution<_IntType>::result_type
                      binomial_distribution<_IntType>::
                      _M_waiting(_UniformRandomNumberGenerator& __urng,
                		 _IntType __t, double __q)
                      {
                	_IntType __x = 0;
                	double __sum = 0.0;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	do
                	  {
                	    if (__t == __x)
                	      return __x;
                	    const double __e = -std::log(1.0 - __aurng());
                	    __sum += __e / (__t - __x);
                	    __x += 1;
                	  }
                	while (__sum <= __q);
                
                	return __x - 1;
                      }
                
                  /**
                   * A rejection algorithm when t * p >= 8 and a simple waiting time
                   * method - the second in the referenced book - otherwise.
                   * NB: The former is available only if _GLIBCXX_USE_C99_MATH_TR1
                   * is defined.
                   *
                   * Reference:
                   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
                   * New York, 1986, Ch. X, Sect. 4 (+ Errata!).
                   */
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename binomial_distribution<_IntType>::result_type
                      binomial_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	result_type __ret;
                	const _IntType __t = __param.t();
                	const double __p = __param.p();
                	const double __p12 = __p <= 0.5 ? __p : 1.0 - __p;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                #if _GLIBCXX_USE_C99_MATH_TR1
                	if (!__param._M_easy)
                	  {
                	    double __x;
                
                	    // See comments above...
                	    const double __naf =
                	      (1 - std::numeric_limits<double>::epsilon()) / 2;
                	    const double __thr =
                	      std::numeric_limits<_IntType>::max() + __naf;
                
                	    const double __np = std::floor(__t * __p12);
                
                	    // sqrt(pi / 2)
                	    const double __spi_2 = 1.2533141373155002512078826424055226L;
                	    const double __a1 = __param._M_a1;
                	    const double __a12 = __a1 + __param._M_s2 * __spi_2;
                	    const double __a123 = __param._M_a123;
                	    const double __s1s = __param._M_s1 * __param._M_s1;
                	    const double __s2s = __param._M_s2 * __param._M_s2;
                
                	    bool __reject;
                	    do
                	      {
                		const double __u = __param._M_s * __aurng();
                
                		double __v;
                
                		if (__u <= __a1)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = __param._M_s1 * std::abs(__n);
                		    __reject = __y >= __param._M_d1;
                		    if (!__reject)
                		      {
                			const double __e = -std::log(1.0 - __aurng());
                			__x = std::floor(__y);
                			__v = -__e - __n * __n / 2 + __param._M_c;
                		      }
                		  }
                		else if (__u <= __a12)
                		  {
                		    const double __n = _M_nd(__urng);
                		    const double __y = __param._M_s2 * std::abs(__n);
                		    __reject = __y >= __param._M_d2;
                		    if (!__reject)
                		      {
                			const double __e = -std::log(1.0 - __aurng());
                			__x = std::floor(-__y);
                			__v = -__e - __n * __n / 2;
                		      }
                		  }
                		else if (__u <= __a123)
                		  {
                		    const double __e1 = -std::log(1.0 - __aurng());
                		    const double __e2 = -std::log(1.0 - __aurng());
                
                		    const double __y = __param._M_d1
                				     + 2 * __s1s * __e1 / __param._M_d1;
                		    __x = std::floor(__y);
                		    __v = (-__e2 + __param._M_d1 * (1 / (__t - __np)
                						    -__y / (2 * __s1s)));
                		    __reject = false;
                		  }
                		else
                		  {
                		    const double __e1 = -std::log(1.0 - __aurng());
                		    const double __e2 = -std::log(1.0 - __aurng());
                
                		    const double __y = __param._M_d2
                				     + 2 * __s2s * __e1 / __param._M_d2;
                		    __x = std::floor(-__y);
                		    __v = -__e2 - __param._M_d2 * __y / (2 * __s2s);
                		    __reject = false;
                		  }
                
                		__reject = __reject || __x < -__np || __x > __t - __np;
                		if (!__reject)
                		  {
                		    const double __lfx =
                		      std::lgamma(__np + __x + 1)
                		      + std::lgamma(__t - (__np + __x) + 1);
                		    __reject = __v > __param._M_lf - __lfx
                			     + __x * __param._M_lp1p;
                		  }
                
                		__reject |= __x + __np >= __thr;
                	      }
                	    while (__reject);
                
                	    __x += __np + __naf;
                
                	    const _IntType __z = _M_waiting(__urng, __t - _IntType(__x),
                					    __param._M_q);
                	    __ret = _IntType(__x) + __z;
                	  }
                	else
                #endif
                	  __ret = _M_waiting(__urng, __t, __param._M_q);
                
                	if (__p12 != __p)
                	  __ret = __t - __ret;
                	return __ret;
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      binomial_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// We could duplicate everything from operator()...
                	while (__f != __t)
                	  *__f++ = this->operator()(__urng, __param);
                      }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const binomial_distribution<_IntType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      __os << __x.t() << __space << __x.p()
                	   << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType,
                	   typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       binomial_distribution<_IntType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _IntType __t;
                      double __p;
                      __is >> __t >> __p >> __x._M_nd;
                      __x.param(typename binomial_distribution<_IntType>::
                		param_type(__t, __p));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::exponential_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	while (__f != __t)
                	  *__f++ = -std::log(result_type(1) - __aurng()) / __p.lambda();
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const exponential_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__os.widen(' '));
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.lambda();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       exponential_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __lambda;
                      __is >> __lambda;
                      __x.param(typename exponential_distribution<_RealType>::
                		param_type(__lambda));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  /**
                   * Polar method due to Marsaglia.
                   *
                   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
                   * New York, 1986, Ch. V, Sect. 4.4.
                   */
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename normal_distribution<_RealType>::result_type
                      normal_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	result_type __ret;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	if (_M_saved_available)
                	  {
                	    _M_saved_available = false;
                	    __ret = _M_saved;
                	  }
                	else
                	  {
                	    result_type __x, __y, __r2;
                	    do
                	      {
                		__x = result_type(2.0) * __aurng() - 1.0;
                		__y = result_type(2.0) * __aurng() - 1.0;
                		__r2 = __x * __x + __y * __y;
                	      }
                	    while (__r2 > 1.0 || __r2 == 0.0);
                
                	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
                	    _M_saved = __x * __mult;
                	    _M_saved_available = true;
                	    __ret = __y * __mult;
                	  }
                
                	__ret = __ret * __param.stddev() + __param.mean();
                	return __ret;
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      normal_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                
                	if (__f == __t)
                	  return;
                
                	if (_M_saved_available)
                	  {
                	    _M_saved_available = false;
                	    *__f++ = _M_saved * __param.stddev() + __param.mean();
                
                	    if (__f == __t)
                	      return;
                	  }
                
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	while (__f + 1 < __t)
                	  {
                	    result_type __x, __y, __r2;
                	    do
                	      {
                		__x = result_type(2.0) * __aurng() - 1.0;
                		__y = result_type(2.0) * __aurng() - 1.0;
                		__r2 = __x * __x + __y * __y;
                	      }
                	    while (__r2 > 1.0 || __r2 == 0.0);
                
                	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
                	    *__f++ = __y * __mult * __param.stddev() + __param.mean();
                	    *__f++ = __x * __mult * __param.stddev() + __param.mean();
                	  }
                
                	if (__f != __t)
                	  {
                	    result_type __x, __y, __r2;
                	    do
                	      {
                		__x = result_type(2.0) * __aurng() - 1.0;
                		__y = result_type(2.0) * __aurng() - 1.0;
                		__r2 = __x * __x + __y * __y;
                	      }
                	    while (__r2 > 1.0 || __r2 == 0.0);
                
                	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
                	    _M_saved = __x * __mult;
                	    _M_saved_available = true;
                	    *__f = __y * __mult * __param.stddev() + __param.mean();
                	  }
                      }
                
                  template<typename _RealType>
                    bool
                    operator==(const std::normal_distribution<_RealType>& __d1,
                	       const std::normal_distribution<_RealType>& __d2)
                    {
                      if (__d1._M_param == __d2._M_param
                	  && __d1._M_saved_available == __d2._M_saved_available)
                	{
                	  if (__d1._M_saved_available
                	      && __d1._M_saved == __d2._M_saved)
                	    return true;
                	  else if(!__d1._M_saved_available)
                	    return true;
                	  else
                	    return false;
                	}
                      else
                	return false;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const normal_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.mean() << __space << __x.stddev()
                	   << __space << __x._M_saved_available;
                      if (__x._M_saved_available)
                	__os << __space << __x._M_saved;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       normal_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      double __mean, __stddev;
                      __is >> __mean >> __stddev
                	   >> __x._M_saved_available;
                      if (__x._M_saved_available)
                	__is >> __x._M_saved;
                      __x.param(typename normal_distribution<_RealType>::
                		param_type(__mean, __stddev));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      lognormal_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	  while (__f != __t)
                	    *__f++ = std::exp(__p.s() * _M_nd(__urng) + __p.m());
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const lognormal_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.m() << __space << __x.s()
                	   << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       lognormal_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __m, __s;
                      __is >> __m >> __s >> __x._M_nd;
                      __x.param(typename lognormal_distribution<_RealType>::
                		param_type(__m, __s));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::chi_squared_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = 2 * _M_gd(__urng);
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::chi_squared_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const typename
                		      std::gamma_distribution<result_type>::param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = 2 * _M_gd(__urng, __p);
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const chi_squared_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.n() << __space << __x._M_gd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       chi_squared_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __n;
                      __is >> __n >> __x._M_gd;
                      __x.param(typename chi_squared_distribution<_RealType>::
                		param_type(__n));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename cauchy_distribution<_RealType>::result_type
                      cauchy_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	_RealType __u;
                	do
                	  __u = __aurng();
                	while (__u == 0.5);
                
                	const _RealType __pi = 3.1415926535897932384626433832795029L;
                	return __p.a() + __p.b() * std::tan(__pi * __u);
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      cauchy_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	const _RealType __pi = 3.1415926535897932384626433832795029L;
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	while (__f != __t)
                	  {
                	    _RealType __u;
                	    do
                	      __u = __aurng();
                	    while (__u == 0.5);
                
                	    *__f++ = __p.a() + __p.b() * std::tan(__pi * __u);
                	  }
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const cauchy_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       cauchy_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __a, __b;
                      __is >> __a >> __b;
                      __x.param(typename cauchy_distribution<_RealType>::
                		param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::fisher_f_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = ((_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()));
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::fisher_f_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	typedef typename std::gamma_distribution<result_type>::param_type
                	  param_type;
                	param_type __p1(__p.m() / 2);
                	param_type __p2(__p.n() / 2);
                	while (__f != __t)
                	  *__f++ = ((_M_gd_x(__urng, __p1) * n())
                		    / (_M_gd_y(__urng, __p2) * m()));
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const fisher_f_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.m() << __space << __x.n()
                	   << __space << __x._M_gd_x << __space << __x._M_gd_y;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       fisher_f_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __m, __n;
                      __is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y;
                      __x.param(typename fisher_f_distribution<_RealType>::
                		param_type(__m, __n));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::student_t_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	while (__f != __t)
                	  *__f++ = _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng));
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      std::student_t_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	typename std::gamma_distribution<result_type>::param_type
                	  __p2(__p.n() / 2, 2);
                	while (__f != __t)
                	  *__f++ =  _M_nd(__urng) * std::sqrt(__p.n() / _M_gd(__urng, __p2));
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const student_t_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.n() << __space << __x._M_nd << __space << __x._M_gd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       student_t_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __n;
                      __is >> __n >> __x._M_nd >> __x._M_gd;
                      __x.param(typename student_t_distribution<_RealType>::param_type(__n));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    void
                    gamma_distribution<_RealType>::param_type::
                    _M_initialize()
                    {
                      _M_malpha = _M_alpha < 1.0 ? _M_alpha + _RealType(1.0) : _M_alpha;
                
                      const _RealType __a1 = _M_malpha - _RealType(1.0) / _RealType(3.0);
                      _M_a2 = _RealType(1.0) / std::sqrt(_RealType(9.0) * __a1);
                    }
                
                  /**
                   * Marsaglia, G. and Tsang, W. W.
                   * "A Simple Method for Generating Gamma Variables"
                   * ACM Transactions on Mathematical Software, 26, 3, 363-372, 2000.
                   */
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename gamma_distribution<_RealType>::result_type
                      gamma_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	result_type __u, __v, __n;
                	const result_type __a1 = (__param._M_malpha
                				  - _RealType(1.0) / _RealType(3.0));
                
                	do
                	  {
                	    do
                	      {
                		__n = _M_nd(__urng);
                		__v = result_type(1.0) + __param._M_a2 * __n; 
                	      }
                	    while (__v <= 0.0);
                
                	    __v = __v * __v * __v;
                	    __u = __aurng();
                	  }
                	while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
                	       && (std::log(__u) > (0.5 * __n * __n + __a1
                				    * (1.0 - __v + std::log(__v)))));
                
                	if (__param.alpha() == __param._M_malpha)
                	  return __a1 * __v * __param.beta();
                	else
                	  {
                	    do
                	      __u = __aurng();
                	    while (__u == 0.0);
                	    
                	    return (std::pow(__u, result_type(1.0) / __param.alpha())
                		    * __a1 * __v * __param.beta());
                	  }
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      gamma_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	result_type __u, __v, __n;
                	const result_type __a1 = (__param._M_malpha
                				  - _RealType(1.0) / _RealType(3.0));
                
                	if (__param.alpha() == __param._M_malpha)
                	  while (__f != __t)
                	    {
                	      do
                		{
                		  do
                		    {
                		      __n = _M_nd(__urng);
                		      __v = result_type(1.0) + __param._M_a2 * __n;
                		    }
                		  while (__v <= 0.0);
                
                		  __v = __v * __v * __v;
                		  __u = __aurng();
                		}
                	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
                		     && (std::log(__u) > (0.5 * __n * __n + __a1
                					  * (1.0 - __v + std::log(__v)))));
                
                	      *__f++ = __a1 * __v * __param.beta();
                	    }
                	else
                	  while (__f != __t)
                	    {
                	      do
                		{
                		  do
                		    {
                		      __n = _M_nd(__urng);
                		      __v = result_type(1.0) + __param._M_a2 * __n;
                		    }
                		  while (__v <= 0.0);
                
                		  __v = __v * __v * __v;
                		  __u = __aurng();
                		}
                	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
                		     && (std::log(__u) > (0.5 * __n * __n + __a1
                					  * (1.0 - __v + std::log(__v)))));
                
                	      do
                		__u = __aurng();
                	      while (__u == 0.0);
                
                	      *__f++ = (std::pow(__u, result_type(1.0) / __param.alpha())
                			* __a1 * __v * __param.beta());
                	    }
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const gamma_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.alpha() << __space << __x.beta()
                	   << __space << __x._M_nd;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       gamma_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __alpha_val, __beta_val;
                      __is >> __alpha_val >> __beta_val >> __x._M_nd;
                      __x.param(typename gamma_distribution<_RealType>::
                		param_type(__alpha_val, __beta_val));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename weibull_distribution<_RealType>::result_type
                      weibull_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	return __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
                				  result_type(1) / __p.a());
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      weibull_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	auto __inv_a = result_type(1) / __p.a();
                
                	while (__f != __t)
                	  *__f++ = __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
                				      __inv_a);
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const weibull_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       weibull_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __a, __b;
                      __is >> __a >> __b;
                      __x.param(typename weibull_distribution<_RealType>::
                		param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename extreme_value_distribution<_RealType>::result_type
                      extreme_value_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __p)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                	return __p.a() - __p.b() * std::log(-std::log(result_type(1)
                						      - __aurng()));
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      extreme_value_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __p)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
                	  __aurng(__urng);
                
                	while (__f != __t)
                	  *__f++ = __p.a() - __p.b() * std::log(-std::log(result_type(1)
                							  - __aurng()));
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const extreme_value_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      __os << __x.a() << __space << __x.b();
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       extreme_value_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      _RealType __a, __b;
                      __is >> __a >> __b;
                      __x.param(typename extreme_value_distribution<_RealType>::
                		param_type(__a, __b));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    void
                    discrete_distribution<_IntType>::param_type::
                    _M_initialize()
                    {
                      if (_M_prob.size() < 2)
                	{
                	  _M_prob.clear();
                	  return;
                	}
                
                      const double __sum = std::accumulate(_M_prob.begin(),
                					   _M_prob.end(), 0.0);
                      // Now normalize the probabilites.
                      __detail::__normalize(_M_prob.begin(), _M_prob.end(), _M_prob.begin(),
                			    __sum);
                      // Accumulate partial sums.
                      _M_cp.reserve(_M_prob.size());
                      std::partial_sum(_M_prob.begin(), _M_prob.end(),
                		       std::back_inserter(_M_cp));
                      // Make sure the last cumulative probability is one.
                      _M_cp[_M_cp.size() - 1] = 1.0;
                    }
                
                  template<typename _IntType>
                    template<typename _Func>
                      discrete_distribution<_IntType>::param_type::
                      param_type(size_t __nw, double __xmin, double __xmax, _Func __fw)
                      : _M_prob(), _M_cp()
                      {
                	const size_t __n = __nw == 0 ? 1 : __nw;
                	const double __delta = (__xmax - __xmin) / __n;
                
                	_M_prob.reserve(__n);
                	for (size_t __k = 0; __k < __nw; ++__k)
                	  _M_prob.push_back(__fw(__xmin + __k * __delta + 0.5 * __delta));
                
                	_M_initialize();
                      }
                
                  template<typename _IntType>
                    template<typename _UniformRandomNumberGenerator>
                      typename discrete_distribution<_IntType>::result_type
                      discrete_distribution<_IntType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	if (__param._M_cp.empty())
                	  return result_type(0);
                
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	const double __p = __aurng();
                	auto __pos = std::lower_bound(__param._M_cp.begin(),
                				      __param._M_cp.end(), __p);
                
                	return __pos - __param._M_cp.begin();
                      }
                
                  template<typename _IntType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      discrete_distribution<_IntType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                
                	if (__param._M_cp.empty())
                	  {
                	    while (__f != __t)
                	      *__f++ = result_type(0);
                	    return;
                	  }
                
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	while (__f != __t)
                	  {
                	    const double __p = __aurng();
                	    auto __pos = std::lower_bound(__param._M_cp.begin(),
                					  __param._M_cp.end(), __p);
                
                	    *__f++ = __pos - __param._M_cp.begin();
                	  }
                      }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const discrete_distribution<_IntType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<double>::max_digits10);
                
                      std::vector<double> __prob = __x.probabilities();
                      __os << __prob.size();
                      for (auto __dit = __prob.begin(); __dit != __prob.end(); ++__dit)
                	__os << __space << *__dit;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _IntType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       discrete_distribution<_IntType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      size_t __n;
                      __is >> __n;
                
                      std::vector<double> __prob_vec;
                      __prob_vec.reserve(__n);
                      for (; __n != 0; --__n)
                	{
                	  double __prob;
                	  __is >> __prob;
                	  __prob_vec.push_back(__prob);
                	}
                
                      __x.param(typename discrete_distribution<_IntType>::
                		param_type(__prob_vec.begin(), __prob_vec.end()));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    void
                    piecewise_constant_distribution<_RealType>::param_type::
                    _M_initialize()
                    {
                      if (_M_int.size() < 2
                	  || (_M_int.size() == 2
                	      && _M_int[0] == _RealType(0)
                	      && _M_int[1] == _RealType(1)))
                	{
                	  _M_int.clear();
                	  _M_den.clear();
                	  return;
                	}
                
                      const double __sum = std::accumulate(_M_den.begin(),
                					   _M_den.end(), 0.0);
                
                      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
                			    __sum);
                
                      _M_cp.reserve(_M_den.size());
                      std::partial_sum(_M_den.begin(), _M_den.end(),
                		       std::back_inserter(_M_cp));
                
                      // Make sure the last cumulative probability is one.
                      _M_cp[_M_cp.size() - 1] = 1.0;
                
                      for (size_t __k = 0; __k < _M_den.size(); ++__k)
                	_M_den[__k] /= _M_int[__k + 1] - _M_int[__k];
                    }
                
                  template<typename _RealType>
                    template<typename _InputIteratorB, typename _InputIteratorW>
                      piecewise_constant_distribution<_RealType>::param_type::
                      param_type(_InputIteratorB __bbegin,
                		 _InputIteratorB __bend,
                		 _InputIteratorW __wbegin)
                      : _M_int(), _M_den(), _M_cp()
                      {
                	if (__bbegin != __bend)
                	  {
                	    for (;;)
                	      {
                		_M_int.push_back(*__bbegin);
                		++__bbegin;
                		if (__bbegin == __bend)
                		  break;
                
                		_M_den.push_back(*__wbegin);
                		++__wbegin;
                	      }
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_constant_distribution<_RealType>::param_type::
                      param_type(initializer_list<_RealType> __bl, _Func __fw)
                      : _M_int(), _M_den(), _M_cp()
                      {
                	_M_int.reserve(__bl.size());
                	for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
                	  _M_int.push_back(*__biter);
                
                	_M_den.reserve(_M_int.size() - 1);
                	for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
                	  _M_den.push_back(__fw(0.5 * (_M_int[__k + 1] + _M_int[__k])));
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_constant_distribution<_RealType>::param_type::
                      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
                      : _M_int(), _M_den(), _M_cp()
                      {
                	const size_t __n = __nw == 0 ? 1 : __nw;
                	const _RealType __delta = (__xmax - __xmin) / __n;
                
                	_M_int.reserve(__n + 1);
                	for (size_t __k = 0; __k <= __nw; ++__k)
                	  _M_int.push_back(__xmin + __k * __delta);
                
                	_M_den.reserve(__n);
                	for (size_t __k = 0; __k < __nw; ++__k)
                	  _M_den.push_back(__fw(_M_int[__k] + 0.5 * __delta));
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename piecewise_constant_distribution<_RealType>::result_type
                      piecewise_constant_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	const double __p = __aurng();
                	if (__param._M_cp.empty())
                	  return __p;
                
                	auto __pos = std::lower_bound(__param._M_cp.begin(),
                				      __param._M_cp.end(), __p);
                	const size_t __i = __pos - __param._M_cp.begin();
                
                	const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
                
                	return __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      piecewise_constant_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	if (__param._M_cp.empty())
                	  {
                	    while (__f != __t)
                	      *__f++ = __aurng();
                	    return;
                	  }
                
                	while (__f != __t)
                	  {
                	    const double __p = __aurng();
                
                	    auto __pos = std::lower_bound(__param._M_cp.begin(),
                					  __param._M_cp.end(), __p);
                	    const size_t __i = __pos - __param._M_cp.begin();
                
                	    const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
                
                	    *__f++ = (__param._M_int[__i]
                		      + (__p - __pref) / __param._M_den[__i]);
                	  }
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const piecewise_constant_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      std::vector<_RealType> __int = __x.intervals();
                      __os << __int.size() - 1;
                
                      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
                	__os << __space << *__xit;
                
                      std::vector<double> __den = __x.densities();
                      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
                	__os << __space << *__dit;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       piecewise_constant_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      size_t __n;
                      __is >> __n;
                
                      std::vector<_RealType> __int_vec;
                      __int_vec.reserve(__n + 1);
                      for (size_t __i = 0; __i <= __n; ++__i)
                	{
                	  _RealType __int;
                	  __is >> __int;
                	  __int_vec.push_back(__int);
                	}
                
                      std::vector<double> __den_vec;
                      __den_vec.reserve(__n);
                      for (size_t __i = 0; __i < __n; ++__i)
                	{
                	  double __den;
                	  __is >> __den;
                	  __den_vec.push_back(__den);
                	}
                
                      __x.param(typename piecewise_constant_distribution<_RealType>::
                	  param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _RealType>
                    void
                    piecewise_linear_distribution<_RealType>::param_type::
                    _M_initialize()
                    {
                      if (_M_int.size() < 2
                	  || (_M_int.size() == 2
                	      && _M_int[0] == _RealType(0)
                	      && _M_int[1] == _RealType(1)
                	      && _M_den[0] == _M_den[1]))
                	{
                	  _M_int.clear();
                	  _M_den.clear();
                	  return;
                	}
                
                      double __sum = 0.0;
                      _M_cp.reserve(_M_int.size() - 1);
                      _M_m.reserve(_M_int.size() - 1);
                      for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
                	{
                	  const _RealType __delta = _M_int[__k + 1] - _M_int[__k];
                	  __sum += 0.5 * (_M_den[__k + 1] + _M_den[__k]) * __delta;
                	  _M_cp.push_back(__sum);
                	  _M_m.push_back((_M_den[__k + 1] - _M_den[__k]) / __delta);
                	}
                
                      //  Now normalize the densities...
                      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
                			    __sum);
                      //  ... and partial sums... 
                      __detail::__normalize(_M_cp.begin(), _M_cp.end(), _M_cp.begin(), __sum);
                      //  ... and slopes.
                      __detail::__normalize(_M_m.begin(), _M_m.end(), _M_m.begin(), __sum);
                
                      //  Make sure the last cumulative probablility is one.
                      _M_cp[_M_cp.size() - 1] = 1.0;
                     }
                
                  template<typename _RealType>
                    template<typename _InputIteratorB, typename _InputIteratorW>
                      piecewise_linear_distribution<_RealType>::param_type::
                      param_type(_InputIteratorB __bbegin,
                		 _InputIteratorB __bend,
                		 _InputIteratorW __wbegin)
                      : _M_int(), _M_den(), _M_cp(), _M_m()
                      {
                	for (; __bbegin != __bend; ++__bbegin, ++__wbegin)
                	  {
                	    _M_int.push_back(*__bbegin);
                	    _M_den.push_back(*__wbegin);
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_linear_distribution<_RealType>::param_type::
                      param_type(initializer_list<_RealType> __bl, _Func __fw)
                      : _M_int(), _M_den(), _M_cp(), _M_m()
                      {
                	_M_int.reserve(__bl.size());
                	_M_den.reserve(__bl.size());
                	for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
                	  {
                	    _M_int.push_back(*__biter);
                	    _M_den.push_back(__fw(*__biter));
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _Func>
                      piecewise_linear_distribution<_RealType>::param_type::
                      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
                      : _M_int(), _M_den(), _M_cp(), _M_m()
                      {
                	const size_t __n = __nw == 0 ? 1 : __nw;
                	const _RealType __delta = (__xmax - __xmin) / __n;
                
                	_M_int.reserve(__n + 1);
                	_M_den.reserve(__n + 1);
                	for (size_t __k = 0; __k <= __nw; ++__k)
                	  {
                	    _M_int.push_back(__xmin + __k * __delta);
                	    _M_den.push_back(__fw(_M_int[__k] + __delta));
                	  }
                
                	_M_initialize();
                      }
                
                  template<typename _RealType>
                    template<typename _UniformRandomNumberGenerator>
                      typename piecewise_linear_distribution<_RealType>::result_type
                      piecewise_linear_distribution<_RealType>::
                      operator()(_UniformRandomNumberGenerator& __urng,
                		 const param_type& __param)
                      {
                	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
                	  __aurng(__urng);
                
                	const double __p = __aurng();
                	if (__param._M_cp.empty())
                	  return __p;
                
                	auto __pos = std::lower_bound(__param._M_cp.begin(),
                				      __param._M_cp.end(), __p);
                	const size_t __i = __pos - __param._M_cp.begin();
                
                	const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
                
                	const double __a = 0.5 * __param._M_m[__i];
                	const double __b = __param._M_den[__i];
                	const double __cm = __p - __pref;
                
                	_RealType __x = __param._M_int[__i];
                	if (__a == 0)
                	  __x += __cm / __b;
                	else
                	  {
                	    const double __d = __b * __b + 4.0 * __a * __cm;
                	    __x += 0.5 * (std::sqrt(__d) - __b) / __a;
                          }
                
                        return __x;
                      }
                
                  template<typename _RealType>
                    template<typename _ForwardIterator,
                	     typename _UniformRandomNumberGenerator>
                      void
                      piecewise_linear_distribution<_RealType>::
                      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                		      _UniformRandomNumberGenerator& __urng,
                		      const param_type& __param)
                      {
                	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                	// We could duplicate everything from operator()...
                	while (__f != __t)
                	  *__f++ = this->operator()(__urng, __param);
                      }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_ostream<_CharT, _Traits>&
                    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                	       const piecewise_linear_distribution<_RealType>& __x)
                    {
                      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
                      typedef typename __ostream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __os.flags();
                      const _CharT __fill = __os.fill();
                      const std::streamsize __precision = __os.precision();
                      const _CharT __space = __os.widen(' ');
                      __os.flags(__ios_base::scientific | __ios_base::left);
                      __os.fill(__space);
                      __os.precision(std::numeric_limits<_RealType>::max_digits10);
                
                      std::vector<_RealType> __int = __x.intervals();
                      __os << __int.size() - 1;
                
                      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
                	__os << __space << *__xit;
                
                      std::vector<double> __den = __x.densities();
                      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
                	__os << __space << *__dit;
                
                      __os.flags(__flags);
                      __os.fill(__fill);
                      __os.precision(__precision);
                      return __os;
                    }
                
                  template<typename _RealType, typename _CharT, typename _Traits>
                    std::basic_istream<_CharT, _Traits>&
                    operator>>(std::basic_istream<_CharT, _Traits>& __is,
                	       piecewise_linear_distribution<_RealType>& __x)
                    {
                      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                      typedef typename __istream_type::ios_base    __ios_base;
                
                      const typename __ios_base::fmtflags __flags = __is.flags();
                      __is.flags(__ios_base::dec | __ios_base::skipws);
                
                      size_t __n;
                      __is >> __n;
                
                      std::vector<_RealType> __int_vec;
                      __int_vec.reserve(__n + 1);
                      for (size_t __i = 0; __i <= __n; ++__i)
                	{
                	  _RealType __int;
                	  __is >> __int;
                	  __int_vec.push_back(__int);
                	}
                
                      std::vector<double> __den_vec;
                      __den_vec.reserve(__n + 1);
                      for (size_t __i = 0; __i <= __n; ++__i)
                	{
                	  double __den;
                	  __is >> __den;
                	  __den_vec.push_back(__den);
                	}
                
                      __x.param(typename piecewise_linear_distribution<_RealType>::
                	  param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));
                
                      __is.flags(__flags);
                      return __is;
                    }
                
                
                  template<typename _IntType>
                    seed_seq::seed_seq(std::initializer_list<_IntType> __il)
                    {
                      for (auto __iter = __il.begin(); __iter != __il.end(); ++__iter)
                	_M_v.push_back(__detail::__mod<result_type,
                		       __detail::_Shift<result_type, 32>::__value>(*__iter));
                    }
                
                  template<typename _InputIterator>
                    seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
                    {
                      for (_InputIterator __iter = __begin; __iter != __end; ++__iter)
                	_M_v.push_back(__detail::__mod<result_type,
                		       __detail::_Shift<result_type, 32>::__value>(*__iter));
                    }
                
                  template<typename _RandomAccessIterator>
                    void
                    seed_seq::generate(_RandomAccessIterator __begin,
                		       _RandomAccessIterator __end)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                        _Type;
                
                      if (__begin == __end)
                	return;
                
                      std::fill(__begin, __end, _Type(0x8b8b8b8bu));
                
                      const size_t __n = __end - __begin;
                      const size_t __s = _M_v.size();
                      const size_t __t = (__n >= 623) ? 11
                		       : (__n >=  68) ? 7
                		       : (__n >=  39) ? 5
                		       : (__n >=   7) ? 3
                		       : (__n - 1) / 2;
                      const size_t __p = (__n - __t) / 2;
                      const size_t __q = __p + __t;
                      const size_t __m = std::max(size_t(__s + 1), __n);
                
                      for (size_t __k = 0; __k < __m; ++__k)
                	{
                	  _Type __arg = (__begin[__k % __n]
                			 ^ __begin[(__k + __p) % __n]
                			 ^ __begin[(__k - 1) % __n]);
                	  _Type __r1 = __arg ^ (__arg >> 27);
                	  __r1 = __detail::__mod<_Type,
                		    __detail::_Shift<_Type, 32>::__value>(1664525u * __r1);
                	  _Type __r2 = __r1;
                	  if (__k == 0)
                	    __r2 += __s;
                	  else if (__k <= __s)
                	    __r2 += __k % __n + _M_v[__k - 1];
                	  else
                	    __r2 += __k % __n;
                	  __r2 = __detail::__mod<_Type,
                	           __detail::_Shift<_Type, 32>::__value>(__r2);
                	  __begin[(__k + __p) % __n] += __r1;
                	  __begin[(__k + __q) % __n] += __r2;
                	  __begin[__k % __n] = __r2;
                	}
                
                      for (size_t __k = __m; __k < __m + __n; ++__k)
                	{
                	  _Type __arg = (__begin[__k % __n]
                			 + __begin[(__k + __p) % __n]
                			 + __begin[(__k - 1) % __n]);
                	  _Type __r3 = __arg ^ (__arg >> 27);
                	  __r3 = __detail::__mod<_Type,
                		   __detail::_Shift<_Type, 32>::__value>(1566083941u * __r3);
                	  _Type __r4 = __r3 - __k % __n;
                	  __r4 = __detail::__mod<_Type,
                	           __detail::_Shift<_Type, 32>::__value>(__r4);
                	  __begin[(__k + __p) % __n] ^= __r3;
                	  __begin[(__k + __q) % __n] ^= __r4;
                	  __begin[__k % __n] = __r4;
                	}
                    }
                
                  template<typename _RealType, size_t __bits,
                	   typename _UniformRandomNumberGenerator>
                    _RealType
                    generate_canonical(_UniformRandomNumberGenerator& __urng)
                    {
                      static_assert(std::is_floating_point<_RealType>::value,
                		    "template argument not a floating point type");
                
                      const size_t __b
                	= std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                                   __bits);
                      const long double __r = static_cast<long double>(__urng.max())
                			    - static_cast<long double>(__urng.min()) + 1.0L;
                      const size_t __log2r = std::log(__r) / std::log(2.0L);
                      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
                      _RealType __sum = _RealType(0);
                      _RealType __tmp = _RealType(1);
                      for (; __k != 0; --__k)
                	{
                	  __sum += _RealType(__urng() - __urng.min()) * __tmp;
                	  __tmp *= __r;
                	}
                      return __sum / __tmp;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      119          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/c++/5/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994-2015 Free Software Foundation, Inc.
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file new
                 *  This is a Standard C++ Library header.
                 *
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <exception>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *  @ingroup exceptions
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception 
                  {
                  public:
                    bad_alloc() throw() { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                
                #if __cplusplus >= 201103L
                  class bad_array_new_length : public bad_alloc
                  {
                  public:
                    bad_array_new_length() throw() { };
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_array_new_length() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                #endif
                
                  struct nothrow_t { };
                
                  extern const nothrow_t nothrow;
                
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                
                  /// Takes a replacement handler as the argument, returns the
                  /// previous handler.
                  new_handler set_new_handler(new_handler) throw();
                
                #if __cplusplus >= 201103L
                  /// Return the current new handler.
                  new_handler get_new_handler() noexcept;
                #endif
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                
                // Default placement versions of operator new.
                inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
       18876 -> { return __p; }
                inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
                { return __p; }
                
                // Default placement versions of operator delete.
       ##### -> inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                //@}
                } // extern "C++"
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      130      18876

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    18876   Total number of line executions
  9438.00   Average executions per line


*** File /usr/include/c++/5/bits/stl_iterator_base_funcs.h:
                // Functions used by iterators -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_funcs.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility
                 *  functions, such as distance() and advance().
                 */
                
                #ifndef _STL_ITERATOR_BASE_FUNCS_H
                #define _STL_ITERATOR_BASE_FUNCS_H 1
                
                #pragma GCC system_header
                
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _InputIterator>
                    inline typename iterator_traits<_InputIterator>::difference_type
                    __distance(_InputIterator __first, _InputIterator __last,
                               input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                
                      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                      while (__first != __last)
                	{
                	  ++__first;
                	  ++__n;
                	}
                      return __n;
                    }
                
                  template<typename _RandomAccessIterator>
                    inline typename iterator_traits<_RandomAccessIterator>::difference_type
          18 ->     __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      return __last - __first;
                    }
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __first  An input iterator.
                   *  @param  __last  An input iterator.
                   *  @return  The distance between them.
                   *
                   *  Returns @c n such that __first + n == __last.  This requires
                   *  that @p __last must be reachable from @p __first.  Note that @c
                   *  n may be negative.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator>
                    inline typename iterator_traits<_InputIterator>::difference_type
          18 ->     distance(_InputIterator __first, _InputIterator __last)
                    {
                      // concept requirements -- taken care of in __distance
                      return std::__distance(__first, __last,
                			     std::__iterator_category(__first));
                    }
                
                  template<typename _InputIterator, typename _Distance>
                    inline void
                    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      _GLIBCXX_DEBUG_ASSERT(__n >= 0);
                      while (__n--)
                	++__i;
                    }
                
                  template<typename _BidirectionalIterator, typename _Distance>
                    inline void
                    __advance(_BidirectionalIterator& __i, _Distance __n,
                	      bidirectional_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      if (__n > 0)
                        while (__n--)
                	  ++__i;
                      else
                        while (__n++)
                	  --__i;
                    }
                
                  template<typename _RandomAccessIterator, typename _Distance>
                    inline void
                    __advance(_RandomAccessIterator& __i, _Distance __n,
                              random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __i += __n;
                    }
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __i  An input iterator.
                   *  @param  __n  The @a delta by which to change @p __i.
                   *  @return  Nothing.
                   *
                   *  This increments @p i by @p n.  For bidirectional and random access
                   *  iterators, @p __n may be negative, in which case @p __i is decremented.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator, typename _Distance>
                    inline void
                    advance(_InputIterator& __i, _Distance __n)
                    {
                      // concept requirements -- taken care of in __advance
                      typename iterator_traits<_InputIterator>::difference_type __d = __n;
                      std::__advance(__i, __d, std::__iterator_category(__i));
                    }
                
                #if __cplusplus >= 201103L
                
                  template<typename _ForwardIterator>
                    inline _ForwardIterator
                    next(_ForwardIterator __x, typename
                	 iterator_traits<_ForwardIterator>::difference_type __n = 1)
                    {
                      std::advance(__x, __n);
                      return __x;
                    }
                
                  template<typename _BidirectionalIterator>
                    inline _BidirectionalIterator
                    prev(_BidirectionalIterator __x, typename
                	 iterator_traits<_BidirectionalIterator>::difference_type __n = 1) 
                    {
                      std::advance(__x, -__n);
                      return __x;
                    }
                
                #endif // C++11
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_FUNCS_H */


Top 10 Lines:

     Line      Count

       90         18
      114         18

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       36   Total number of line executions
    18.00   Average executions per line


*** File /usr/include/c++/5/typeinfo:
                // RTTI support for -*- C++ -*-
                // Copyright (C) 1994-2015 Free Software Foundation, Inc.
                //
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                //
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file typeinfo
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _TYPEINFO
                #define _TYPEINFO
                
                #pragma GCC system_header
                
                #include <exception>
                #if __cplusplus >= 201103L
                #include <bits/hash_bytes.h>
                #endif
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace __cxxabiv1
                {
                  class __class_type_info;
                } // namespace __cxxabiv1
                
                // Determine whether typeinfo names for the same type are merged (in which
                // case comparison can just compare pointers) or not (in which case strings
                // must be compared), and whether comparison is to be implemented inline or
                // not.  We used to do inline pointer comparison by default if weak symbols
                // are available, but even with weak symbols sometimes names are not merged
                // when objects are loaded with RTLD_LOCAL, so now we always use strcmp by
                // default.  For ABI compatibility, we do the strcmp inline if weak symbols
                // are available, and out-of-line if not.  Out-of-line pointer comparison
                // is used where the object files are to be portable to multiple systems,
                // some of which may not be able to use pointer comparison, but the
                // particular system for which libstdc++ is being built can use pointer
                // comparison; in particular for most ARM EABI systems, where the ABI
                // specifies out-of-line comparison.  The compiler's target configuration
                // can override the defaults by defining __GXX_TYPEINFO_EQUALITY_INLINE to
                // 1 or 0 to indicate whether or not comparison is inline, and
                // __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to indicate whether or not pointer
                // comparison can be used.
                
                #ifndef __GXX_MERGED_TYPEINFO_NAMES
                // By default, typeinfo names are not merged.
                #define __GXX_MERGED_TYPEINFO_NAMES 0
                #endif
                
                // By default follow the old inline rules to avoid ABI changes.
                #ifndef __GXX_TYPEINFO_EQUALITY_INLINE
                  #if !__GXX_WEAK__
                    #define __GXX_TYPEINFO_EQUALITY_INLINE 0
                  #else
                    #define __GXX_TYPEINFO_EQUALITY_INLINE 1
                  #endif
                #endif
                
                namespace std
                {
                  /**
                   *  @brief  Part of RTTI.
                   *
                   *  The @c type_info class describes type information generated by
                   *  an implementation.
                  */
                  class type_info
                  {
                  public:
                    /** Destructor first. Being the first non-inline virtual function, this
                     *  controls in which translation unit the vtable is emitted. The
                     *  compiler makes use of that information to know where to emit
                     *  the runtime-mandated type_info structures in the new-abi.  */
                    virtual ~type_info();
                
                    /** Returns an @e implementation-defined byte string; this is not
                     *  portable between compilers!  */
                    const char* name() const _GLIBCXX_NOEXCEPT
                    { return __name[0] == '*' ? __name + 1 : __name; }
                
                #if !__GXX_TYPEINFO_EQUALITY_INLINE
                    // In old abi, or when weak symbols are not supported, there can
                    // be multiple instances of a type_info object for one
                    // type. Uniqueness must use the _name value, not object address.
                    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
                    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
                #else
                  #if !__GXX_MERGED_TYPEINFO_NAMES
                    /** Returns true if @c *this precedes @c __arg in the implementation's
                     *  collation order.  */
                    // Even with the new abi, on systems that support dlopen
                    // we can run into cases where type_info names aren't merged,
                    // so we still need to do string comparison.
                    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT
                    { return (__name[0] == '*' && __arg.__name[0] == '*')
                	? __name < __arg.__name
                	: __builtin_strcmp (__name, __arg.__name) < 0; }
                
         394 ->     bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
                    {
                      return ((__name == __arg.__name)
                	      || (__name[0] != '*' &&
                		  __builtin_strcmp (__name, __arg.__name) == 0));
                    }
                  #else
                    // On some targets we can rely on type_info's NTBS being unique,
                    // and therefore address comparisons are sufficient.
                    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT
                    { return __name < __arg.__name; }
                
                    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
                    { return __name == __arg.__name; }
                  #endif
                #endif
                    bool operator!=(const type_info& __arg) const _GLIBCXX_NOEXCEPT
                    { return !operator==(__arg); }
                
                #if __cplusplus >= 201103L
                    size_t hash_code() const noexcept
                    {
                #  if !__GXX_MERGED_TYPEINFO_NAMES
                      return _Hash_bytes(name(), __builtin_strlen(name()),
                			 static_cast<size_t>(0xc70f6907UL));
                #  else
                      return reinterpret_cast<size_t>(__name);
                #  endif
                    }
                #endif // C++11
                
                    // Return true if this is a pointer type of some kind
                    virtual bool __is_pointer_p() const;
                
                    // Return true if this is a function type
                    virtual bool __is_function_p() const;
                
                    // Try and catch a thrown type. Store an adjusted pointer to the
                    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
                    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
                    // type, then THR_OBJ is the pointer itself. OUTER indicates the
                    // number of outer pointers, and whether they were const
                    // qualified.
                    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
                			    unsigned __outer) const;
                
                    // Internally used during catch matching
                    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
                			     void **__obj_ptr) const;
                
                  protected:
                    const char *__name;
                
                    explicit type_info(const char *__n): __name(__n) { }
                
                  private:
                    /// Assigning type_info is not supported.
                    type_info& operator=(const type_info&);
                    type_info(const type_info&);
                  };
                
                  /**
                   *  @brief  Thrown during incorrect typecasting.
                   *  @ingroup exceptions
                   *
                   *  If you attempt an invalid @c dynamic_cast expression, an instance of
                   *  this class (or something derived from this class) is thrown.  */
                  class bad_cast : public exception
                  {
                  public:
                    bad_cast() _GLIBCXX_USE_NOEXCEPT { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_cast() _GLIBCXX_USE_NOEXCEPT;
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
                  };
                
                  /**
                   *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
                   *  @ingroup exceptions
                   */
                  class bad_typeid : public exception
                  {
                  public:
                    bad_typeid () _GLIBCXX_USE_NOEXCEPT { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_typeid() _GLIBCXX_USE_NOEXCEPT;
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
                  };
                } // namespace std
                
                } // extern "C++"
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      120        394

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      394   Total number of line executions
   394.00   Average executions per line


*** File /usr/include/c++/5/condition_variable:
                // <condition_variable> -*- C++ -*-
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/condition_variable
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_CONDITION_VARIABLE
                #define _GLIBCXX_CONDITION_VARIABLE 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <chrono>
                #include <mutex>
                #include <ext/concurrence.h>
                #include <bits/alloc_traits.h>
                #include <bits/allocator.h>
                #include <bits/unique_ptr.h>
                #include <bits/shared_ptr.h>
                
                #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @defgroup condition_variables Condition Variables
                   * @ingroup concurrency
                   *
                   * Classes for condition_variable support.
                   * @{
                   */
                
                  /// cv_status
                  enum class cv_status { no_timeout, timeout };
                  
                  /// condition_variable
                  class condition_variable
                  {
                    typedef chrono::system_clock	__clock_t;
                    typedef __gthread_cond_t		__native_type;
                
                #ifdef __GTHREAD_COND_INIT
                    __native_type			_M_cond = __GTHREAD_COND_INIT;
                #else
                    __native_type			_M_cond;
                #endif
                
                  public:
                    typedef __native_type* 		native_handle_type;
                
                    condition_variable() noexcept;
                    ~condition_variable() noexcept;
                
                    condition_variable(const condition_variable&) = delete;
                    condition_variable& operator=(const condition_variable&) = delete;
                
                    void
                    notify_one() noexcept;
                
                    void
                    notify_all() noexcept;
                
                    void
                    wait(unique_lock<mutex>& __lock);
                
                    template<typename _Predicate>
                      void
                      wait(unique_lock<mutex>& __lock, _Predicate __p)
                      {
                	while (!__p())
                	  wait(__lock);
                      }
                
                    template<typename _Duration>
                      cv_status
        5720 ->       wait_until(unique_lock<mutex>& __lock,
                		 const chrono::time_point<__clock_t, _Duration>& __atime)
                      { return __wait_until_impl(__lock, __atime); }
                
                    template<typename _Clock, typename _Duration>
                      cv_status
        6605 ->       wait_until(unique_lock<mutex>& __lock,
                		 const chrono::time_point<_Clock, _Duration>& __atime)
                      {
                	// DR 887 - Sync unknown clock to known clock.
                	const typename _Clock::time_point __c_entry = _Clock::now();
                	const __clock_t::time_point __s_entry = __clock_t::now();
                	const auto __delta = __atime - __c_entry;
                	const auto __s_atime = __s_entry + __delta;
                
                	return __wait_until_impl(__lock, __s_atime);
                      }
                
                    template<typename _Clock, typename _Duration, typename _Predicate>
                      bool
                      wait_until(unique_lock<mutex>& __lock,
                		 const chrono::time_point<_Clock, _Duration>& __atime,
                		 _Predicate __p)
                      {
                	while (!__p())
                	  if (wait_until(__lock, __atime) == cv_status::timeout)
                	    return __p();
                	return true;
                      }
                
                    template<typename _Rep, typename _Period>
                      cv_status
        5871 ->       wait_for(unique_lock<mutex>& __lock,
                	       const chrono::duration<_Rep, _Period>& __rtime)
                      { return wait_until(__lock, __clock_t::now() + __rtime); }
                
                    template<typename _Rep, typename _Period, typename _Predicate>
                      bool
                      wait_for(unique_lock<mutex>& __lock,
                	       const chrono::duration<_Rep, _Period>& __rtime,
                	       _Predicate __p)
                      { return wait_until(__lock, __clock_t::now() + __rtime, std::move(__p)); }
                
                    native_handle_type
                    native_handle()
                    { return &_M_cond; }
                
                  private:
                    template<typename _Dur>
                      cv_status
       12087 ->       __wait_until_impl(unique_lock<mutex>& __lock,
                			const chrono::time_point<__clock_t, _Dur>& __atime)
                      {
                	auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
                	auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);
                
                	__gthread_time_t __ts =
                	  {
                	    static_cast<std::time_t>(__s.time_since_epoch().count()),
                	    static_cast<long>(__ns.count())
                	  };
                
                	__gthread_cond_timedwait(&_M_cond, __lock.mutex()->native_handle(),
                				 &__ts);
                
                	return (__clock_t::now() < __atime
                		? cv_status::no_timeout : cv_status::timeout);
                      }
                  };
                
                  void
                  notify_all_at_thread_exit(condition_variable&, unique_lock<mutex>);
                
                  struct __at_thread_exit_elt
                  {
                    __at_thread_exit_elt* _M_next;
                    void (*_M_cb)(void*);
                  };
                
                  inline namespace _V2 {
                
                  /// condition_variable_any
                  // Like above, but mutex is not required to have try_lock.
                  class condition_variable_any
                  {
                    typedef chrono::system_clock	__clock_t;
                    condition_variable			_M_cond;
                    shared_ptr<mutex>			_M_mutex;
                
                    // scoped unlock - unlocks in ctor, re-locks in dtor
                    template<typename _Lock>
                      struct _Unlock
                      {
                	explicit _Unlock(_Lock& __lk) : _M_lock(__lk) { __lk.unlock(); }
                
                	~_Unlock() noexcept(false)
                	{
                	  if (uncaught_exception())
                	    {
                	      __try
                	      { _M_lock.lock(); }
                	      __catch(const __cxxabiv1::__forced_unwind&)
                	      { __throw_exception_again; }
                	      __catch(...)
                	      { }
                	    }
                	  else
                	    _M_lock.lock();
                	}
                
                	_Unlock(const _Unlock&) = delete;
                	_Unlock& operator=(const _Unlock&) = delete;
                
                	_Lock& _M_lock;
                      };
                
                  public:
                    condition_variable_any() : _M_mutex(std::make_shared<mutex>()) { }
                    ~condition_variable_any() = default;
                
                    condition_variable_any(const condition_variable_any&) = delete;
                    condition_variable_any& operator=(const condition_variable_any&) = delete;
                
                    void
                    notify_one() noexcept
                    {
                      lock_guard<mutex> __lock(*_M_mutex);
                      _M_cond.notify_one();
                    }
                
                    void
                    notify_all() noexcept
                    {
                      lock_guard<mutex> __lock(*_M_mutex);
                      _M_cond.notify_all();
                    }
                
                    template<typename _Lock>
                      void
                      wait(_Lock& __lock)
                      {
                	shared_ptr<mutex> __mutex = _M_mutex;
                	unique_lock<mutex> __my_lock(*__mutex);
                	_Unlock<_Lock> __unlock(__lock);
                	// *__mutex must be unlocked before re-locking __lock so move
                	// ownership of *__mutex lock to an object with shorter lifetime.
                	unique_lock<mutex> __my_lock2(std::move(__my_lock));
                	_M_cond.wait(__my_lock2);
                      }
                      
                
                    template<typename _Lock, typename _Predicate>
                      void
                      wait(_Lock& __lock, _Predicate __p)
                      {
                	while (!__p())
                	  wait(__lock);
                      }
                
                    template<typename _Lock, typename _Clock, typename _Duration>
                      cv_status
                      wait_until(_Lock& __lock,
                		 const chrono::time_point<_Clock, _Duration>& __atime)
                      {
                	shared_ptr<mutex> __mutex = _M_mutex;
                	unique_lock<mutex> __my_lock(*__mutex);
                	_Unlock<_Lock> __unlock(__lock);
                	// *__mutex must be unlocked before re-locking __lock so move
                	// ownership of *__mutex lock to an object with shorter lifetime.
                	unique_lock<mutex> __my_lock2(std::move(__my_lock));
                	return _M_cond.wait_until(__my_lock2, __atime);
                      }
                
                    template<typename _Lock, typename _Clock,
                	     typename _Duration, typename _Predicate>
                      bool
                      wait_until(_Lock& __lock,
                		 const chrono::time_point<_Clock, _Duration>& __atime,
                		 _Predicate __p)
                      {
                	while (!__p())
                	  if (wait_until(__lock, __atime) == cv_status::timeout)
                	    return __p();
                	return true;
                      }
                
                    template<typename _Lock, typename _Rep, typename _Period>
                      cv_status
                      wait_for(_Lock& __lock, const chrono::duration<_Rep, _Period>& __rtime)
                      { return wait_until(__lock, __clock_t::now() + __rtime); }
                
                    template<typename _Lock, typename _Rep,
                	     typename _Period, typename _Predicate>
                      bool
                      wait_for(_Lock& __lock,
                	       const chrono::duration<_Rep, _Period>& __rtime, _Predicate __p)
                      { return wait_until(__lock, __clock_t::now() + __rtime, std::move(__p)); }
                  };
                
                  } // end inline namespace
                
                  // @} group condition_variables
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1
                
                #endif // C++11
                
                #endif // _GLIBCXX_CONDITION_VARIABLE


Top 10 Lines:

     Line      Count

      153      12087
      109       6605
      135       5871
      103       5720

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

    30283   Total number of line executions
  7570.75   Average executions per line


*** File /usr/include/c++/5/ext/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/alloc_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_ALLOC_TRAITS_H
                #define _EXT_ALLOC_TRAITS_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                # include <bits/move.h>
                # include <bits/alloc_traits.h>
                #else
                # include <bits/allocator.h>  // for __alloc_swap
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    struct __allocator_always_compares_equal : std::false_type { };
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<std::allocator<_Tp>>
                    : std::true_type { };
                
                  template<typename, typename> struct array_allocator;
                
                  template<typename _Tp, typename _Array>
                    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
                    : std::true_type { };
                
                  template<typename> struct bitmap_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>
                    : std::true_type { };
                
                  template<typename> struct malloc_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<malloc_allocator<_Tp>>
                    : std::true_type { };
                
                  template<typename> struct mt_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
                    : std::true_type { };
                
                  template<typename> struct new_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<new_allocator<_Tp>>
                    : std::true_type { };
                
                  template<typename> struct pool_allocator;
                
                  template<typename _Tp>
                    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
                    : std::true_type { };
                #endif
                
                /**
                 * @brief  Uniform interface to C++98 and C++0x allocators.
                 * @ingroup allocators
                */
                template<typename _Alloc>
                  struct __alloc_traits
                #if __cplusplus >= 201103L
                  : std::allocator_traits<_Alloc>
                #endif
                  {
                    typedef _Alloc allocator_type;
                #if __cplusplus >= 201103L
                    typedef std::allocator_traits<_Alloc>           _Base_type;
                    typedef typename _Base_type::value_type         value_type;
                    typedef typename _Base_type::pointer            pointer;
                    typedef typename _Base_type::const_pointer      const_pointer;
                    typedef typename _Base_type::size_type          size_type;
                    typedef typename _Base_type::difference_type    difference_type;
                    // C++11 allocators do not define reference or const_reference
                    typedef value_type&                             reference;
                    typedef const value_type&                       const_reference;
                    using _Base_type::allocate;
                    using _Base_type::deallocate;
                    using _Base_type::construct;
                    using _Base_type::destroy;
                    using _Base_type::max_size;
                
                  private:
                    template<typename _Ptr>
                      using __is_custom_pointer
                	= std::__and_<std::is_same<pointer, _Ptr>,
                		      std::__not_<std::is_pointer<_Ptr>>>;
                
                  public:
                    // overload construct for non-standard pointer types
                    template<typename _Ptr, typename... _Args>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
                      {
                	_Base_type::construct(__a, std::addressof(*__p),
                			      std::forward<_Args>(__args)...);
                      }
                
                    // overload destroy for non-standard pointer types
                    template<typename _Ptr>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      destroy(_Alloc& __a, _Ptr __p)
                      { _Base_type::destroy(__a, std::addressof(*__p)); }
                
           4 ->     static _Alloc _S_select_on_copy(const _Alloc& __a)
                    { return _Base_type::select_on_container_copy_construction(__a); }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    { std::__alloc_on_swap(__a, __b); }
                
       ##### ->     static constexpr bool _S_propagate_on_copy_assign()
                    { return _Base_type::propagate_on_container_copy_assignment::value; }
                
                    static constexpr bool _S_propagate_on_move_assign()
                    { return _Base_type::propagate_on_container_move_assignment::value; }
                
                    static constexpr bool _S_propagate_on_swap()
                    { return _Base_type::propagate_on_container_swap::value; }
                
       ##### ->     static constexpr bool _S_always_equal()
                    { return __allocator_always_compares_equal<_Alloc>::value; }
                
                    static constexpr bool _S_nothrow_move()
                    { return _S_propagate_on_move_assign() || _S_always_equal(); }
                
                    static constexpr bool _S_nothrow_swap()
                    {
                      using std::swap;
                      return !_S_propagate_on_swap()
                       	|| noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
                #else
                
                    typedef typename _Alloc::pointer                pointer;
                    typedef typename _Alloc::const_pointer          const_pointer;
                    typedef typename _Alloc::value_type             value_type;
                    typedef typename _Alloc::reference              reference;
                    typedef typename _Alloc::const_reference        const_reference;
                    typedef typename _Alloc::size_type              size_type;
                    typedef typename _Alloc::difference_type        difference_type;
                
                    static pointer
                    allocate(_Alloc& __a, size_type __n)
                    { return __a.allocate(__n); }
                
                    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
                    { __a.deallocate(__p, __n); }
                
                    template<typename _Tp>
                      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
                      { __a.construct(__p, __arg); }
                
                    static void destroy(_Alloc& __a, pointer __p)
                    { __a.destroy(__p); }
                
                    static size_type max_size(const _Alloc& __a)
                    { return __a.max_size(); }
                
                    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Alloc::template rebind<_Tp>::other other; };
                #endif
                  };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

      139          4

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        4   Total number of line executions
     1.33   Average executions per line


*** File /home/sbillah/dmclock/sim/test_dmclock.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #include "dmclock_recs.h"
                #include "dmclock_server.h"
                #include "dmclock_client.h"
                
                #include "sim_recs.h"
                #include "sim_server.h"
                #include "sim_client.h"
                
                #include "simulate.h"
                
                
                namespace crimson {
                  namespace test_dmc {
                    
                    namespace dmc = crimson::dmclock;
                    namespace sim = crimson::qos_simulation;
                
         104 ->     struct DmcAccum {
                      uint64_t reservation_count = 0;
                      uint64_t proportion_count = 0;
                    };
                
                    using DmcQueue = dmc::PushPriorityQueue<ClientId,sim::TestRequest>;
                
                    using DmcServer = sim::SimulatedServer<DmcQueue,
                					   dmc::ReqParams,
                					   dmc::PhaseType,
                					   DmcAccum>;
                
                    using DmcClient = sim::SimulatedClient<dmc::ServiceTracker<ServerId>,
                					   dmc::ReqParams,
                					   dmc::PhaseType,
                					   DmcAccum>;
                
                    using CreateQueueF = std::function<DmcQueue*(DmcQueue::CanHandleRequestFunc,
                						 DmcQueue::HandleRequestFunc)>;
                
                    using MySim = sim::Simulation<ServerId,ClientId,DmcServer,DmcClient>;
                
                    using SubmitFunc = DmcClient::SubmitFunc;
                
                    extern void dmc_server_accumulate_f(DmcAccum& a,
                					const dmc::PhaseType& phase);
                
                    extern void dmc_client_accumulate_f(DmcAccum& a,
                					const dmc::PhaseType& phase);
                  } // namespace test_dmc
                } // namespace crimson


Top 10 Lines:

     Line      Count

       26        104

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      104   Total number of line executions
   104.00   Average executions per line


*** File /usr/include/c++/5/ext/type_traits.h:
                // -*- C++ -*-
                
                // Copyright (C) 2005-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the terms
                // of the GNU General Public License as published by the Free Software
                // Foundation; either version 3, or (at your option) any later
                // version.
                
                // This library is distributed in the hope that it will be useful, but
                // WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                // General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/type_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_TYPE_TRAITS
                #define _EXT_TYPE_TRAITS 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/cpp_type_traits.h>
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Define a nested type if some predicate holds.
                  template<bool, typename>
                    struct __enable_if 
                    { };
                
                  template<typename _Tp>
                    struct __enable_if<true, _Tp>
                    { typedef _Tp __type; };
                
                
                  // Conditional expression for types. If true, first, if false, second.
                  template<bool _Cond, typename _Iftrue, typename _Iffalse>
                    struct __conditional_type
                    { typedef _Iftrue __type; };
                
                  template<typename _Iftrue, typename _Iffalse>
                    struct __conditional_type<false, _Iftrue, _Iffalse>
                    { typedef _Iffalse __type; };
                
                
                  // Given an integral builtin type, return the corresponding unsigned type.
                  template<typename _Tp>
                    struct __add_unsigned
                    { 
                    private:
                      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
                      
                    public:
                      typedef typename __if_type::__type __type; 
                    };
                
                  template<>
                    struct __add_unsigned<char>
                    { typedef unsigned char __type; };
                
                  template<>
                    struct __add_unsigned<signed char>
                    { typedef unsigned char __type; };
                
                  template<>
                    struct __add_unsigned<short>
                    { typedef unsigned short __type; };
                
                  template<>
                    struct __add_unsigned<int>
                    { typedef unsigned int __type; };
                
                  template<>
                    struct __add_unsigned<long>
                    { typedef unsigned long __type; };
                
                  template<>
                    struct __add_unsigned<long long>
                    { typedef unsigned long long __type; };
                
                  // Declare but don't define.
                  template<>
                    struct __add_unsigned<bool>;
                
                  template<>
                    struct __add_unsigned<wchar_t>;
                
                
                  // Given an integral builtin type, return the corresponding signed type.
                  template<typename _Tp>
                    struct __remove_unsigned
                    { 
                    private:
                      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
                      
                    public:
                      typedef typename __if_type::__type __type; 
                    };
                
                  template<>
                    struct __remove_unsigned<char>
                    { typedef signed char __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned char>
                    { typedef signed char __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned short>
                    { typedef short __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned int>
                    { typedef int __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned long>
                    { typedef long __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned long long>
                    { typedef long long __type; };
                
                  // Declare but don't define.
                  template<>
                    struct __remove_unsigned<bool>;
                
                  template<>
                    struct __remove_unsigned<wchar_t>;
                
                
                  // For use in string and vstring.
                  template<typename _Type>
                    inline bool
          16 ->     __is_null_pointer(_Type* __ptr)
                    { return __ptr == 0; }
                
                  template<typename _Type>
                    inline bool
                    __is_null_pointer(_Type)
                    { return false; }
                
                #if __cplusplus >= 201103L
                  inline bool
                  __is_null_pointer(std::nullptr_t)
                  { return true; }
                #endif
                
                  // For complex and cmath
                  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
                    struct __promote
                    { typedef double __type; };
                
                  // No nested __type member for non-integer non-floating point types,
                  // allows this type to be used for SFINAE to constrain overloads in
                  // <cmath> and <complex> to only the intended types.
                  template<typename _Tp>
                    struct __promote<_Tp, false>
                    { };
                
                  template<>
                    struct __promote<long double>
                    { typedef long double __type; };
                
                  template<>
                    struct __promote<double>
                    { typedef double __type; };
                
                  template<>
                    struct __promote<float>
                    { typedef float __type; };
                
                  template<typename _Tp, typename _Up,
                           typename _Tp2 = typename __promote<_Tp>::__type,
                           typename _Up2 = typename __promote<_Up>::__type>
                    struct __promote_2
                    {
                      typedef __typeof__(_Tp2() + _Up2()) __type;
                    };
                
                  template<typename _Tp, typename _Up, typename _Vp,
                           typename _Tp2 = typename __promote<_Tp>::__type,
                           typename _Up2 = typename __promote<_Up>::__type,
                           typename _Vp2 = typename __promote<_Vp>::__type>
                    struct __promote_3
                    {
                      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
                    };
                
                  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
                           typename _Tp2 = typename __promote<_Tp>::__type,
                           typename _Up2 = typename __promote<_Up>::__type,
                           typename _Vp2 = typename __promote<_Vp>::__type,
                           typename _Wp2 = typename __promote<_Wp>::__type>
                    struct __promote_4
                    {
                      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif 


Top 10 Lines:

     Line      Count

      150         16

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       16   Total number of line executions
    16.00   Average executions per line


*** File /usr/include/c++/5/bits/basic_string.tcc:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21  Strings library
                //
                
                // Written by Jason Merrill based upon the specification by Takanori Adachi
                // in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.
                // Non-reference-counted implementation written by Paolo Carlini and
                // updated by Jonathan Wakely for ISO-14882-2011.
                
                #ifndef _BASIC_STRING_TCC
                #define _BASIC_STRING_TCC 1
                
                #pragma GCC system_header
                
                #include <bits/cxxabi_forced.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if _GLIBCXX_USE_CXX11_ABI
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::npos;
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    swap(basic_string& __s) _GLIBCXX_NOEXCEPT
                    {
                      if (this == &__s)
                	return;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      // TODO propagation traits
                      std::__alloc_swap<allocator_type>::_S_do_it(_M_get_allocator(),
                						  __s._M_get_allocator());
                
                      if (_M_is_local())
                	if (__s._M_is_local())
                	  {
                	    if (length() && __s.length())
                	      {
                		_CharT __tmp_data[_S_local_capacity + 1];
                		traits_type::copy(__tmp_data, __s._M_local_buf,
                				  _S_local_capacity + 1);
                		traits_type::copy(__s._M_local_buf, _M_local_buf,
                				  _S_local_capacity + 1);
                		traits_type::copy(_M_local_buf, __tmp_data,
                				  _S_local_capacity + 1);
                	      }
                	    else if (__s.length())
                	      {
                		traits_type::copy(_M_local_buf, __s._M_local_buf,
                				  _S_local_capacity + 1);
                		_M_length(__s.length());
                		__s._M_set_length(0);
                		return;
                	      }
                	    else if (length())
                	      {
                		traits_type::copy(__s._M_local_buf, _M_local_buf,
                				  _S_local_capacity + 1);
                		__s._M_length(length());
                		_M_set_length(0);
                		return;
                	      }
                	  }
                	else
                	  {
                	    const size_type __tmp_capacity = __s._M_allocated_capacity;
                	    traits_type::copy(__s._M_local_buf, _M_local_buf,
                			      _S_local_capacity + 1);
                	    _M_data(__s._M_data());
                	    __s._M_data(__s._M_local_buf);
                	    _M_capacity(__tmp_capacity);
                	  }
                      else
                	{
                	  const size_type __tmp_capacity = _M_allocated_capacity;
                	  if (__s._M_is_local())
                	    {
                	      traits_type::copy(_M_local_buf, __s._M_local_buf,
                				_S_local_capacity + 1);
                	      __s._M_data(_M_data());
                	      _M_data(_M_local_buf);
                	    }
                	  else
                	    {
                	      pointer __tmp_ptr = _M_data();
                	      _M_data(__s._M_data());
                	      __s._M_data(__tmp_ptr);
                	      _M_capacity(__s._M_allocated_capacity);
                	    }
                	  __s._M_capacity(__tmp_capacity);
                	}
                
                      const size_type __tmp_length = length();
                      _M_length(__s.length());
                      __s._M_length(__tmp_length);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::pointer
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_create(size_type& __capacity, size_type __old_capacity)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 83.  String::npos vs. string::max_size()
                      if (__capacity > max_size())
                	std::__throw_length_error(__N("basic_string::_M_create"));
                
                      // The below implements an exponential growth policy, necessary to
                      // meet amortized linear time requirements of the library: see
                      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
                      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
                	{
                	  __capacity = 2 * __old_capacity;
                	  // Never allocate a string bigger than max_size.
                	  if (__capacity > max_size())
                	    __capacity = max_size();
                	}
                
                      // NB: Need an array of char_type[__capacity], plus a terminating
                      // null char_type() element.
                      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
                    }
                
                  // NB: This is the special case for Input Iterators, used in
                  // istreambuf_iterators, etc.
                  // Input Iterators have a cost structure very different from
                  // pointers, calling for a different coding style.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      void
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_construct(_InIterator __beg, _InIterator __end,
                		   std::input_iterator_tag)
                      {
                	size_type __len = 0;
                	size_type __capacity = size_type(_S_local_capacity);
                
                	while (__beg != __end && __len < __capacity)
                	  {
                	    _M_data()[__len++] = *__beg;
                	    ++__beg;
                	  }
                
                	__try
                	  {
                	    while (__beg != __end)
                	      {
                		if (__len == __capacity)
                		  {
                		    // Allocate more space.
                		    __capacity = __len + 1;
                		    pointer __another = _M_create(__capacity, __len);
                		    this->_S_copy(__another, _M_data(), __len);
                		    _M_dispose();
                		    _M_data(__another);
                		    _M_capacity(__capacity);
                		  }
                		_M_data()[__len++] = *__beg;
                		++__beg;
                	      }
                	  }
                	__catch(...)
                	  {
                	    _M_dispose();
                	    __throw_exception_again;
                	  }
                
                	_M_set_length(__len);
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      void
          16 ->       basic_string<_CharT, _Traits, _Alloc>::
                      _M_construct(_InIterator __beg, _InIterator __end,
                		   std::forward_iterator_tag)
                      {
                	// NB: Not required, but considered best practice.
                	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                	  std::__throw_logic_error(__N("basic_string::"
                				       "_M_construct null not valid"));
                
                	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                
                	if (__dnew > size_type(_S_local_capacity))
                	  {
                	    _M_data(_M_create(__dnew, size_type(0)));
                	    _M_capacity(__dnew);
                	  }
                
                	// Check for out_of_range and length_error exceptions.
                	__try
                	  { this->_S_copy_chars(_M_data(), __beg, __end); }
                	__catch(...)
                	  {
                	    _M_dispose();
                	    __throw_exception_again;
                	  }
                
                	_M_set_length(__dnew);
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_construct(size_type __n, _CharT __c)
                    {
                      if (__n > size_type(_S_local_capacity))
                	{
                	  _M_data(_M_create(__n, size_type(0)));
                	  _M_capacity(__n);
                	}
                
                      if (__n)
                	this->_S_assign(_M_data(), __n, __c);
                
                      _M_set_length(__n);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_assign(const basic_string& __str)
                    {
                      if (this != &__str)
                	{
                	  const size_type __rsize = __str.length();
                	  const size_type __capacity = capacity();
                
                	  if (__rsize > __capacity)
                	    {
                	      size_type __new_capacity = __rsize;
                	      pointer __tmp = _M_create(__new_capacity, __capacity);
                	      _M_dispose();
                	      _M_data(__tmp);
                	      _M_capacity(__new_capacity);
                	    }
                
                	  if (__rsize)
                	    this->_S_copy(_M_data(), __str._M_data(), __rsize);
                
                	  _M_set_length(__rsize);
                	}
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve(size_type __res)
                    {
                      // Make sure we don't shrink below the current size.
                      if (__res < length())
                	__res = length();
                
                      const size_type __capacity = capacity();
                      if (__res != __capacity)
                	{
                	  if (__res > __capacity
                	      || __res > size_type(_S_local_capacity))
                	    {
                	      pointer __tmp = _M_create(__res, __capacity);
                	      this->_S_copy(__tmp, _M_data(), length() + 1);
                	      _M_dispose();
                	      _M_data(__tmp);
                	      _M_capacity(__res);
                	    }
                	  else if (!_M_is_local())
                	    {
                	      this->_S_copy(_M_local_data(), _M_data(), length() + 1);
                	      _M_destroy(__capacity);
                	      _M_data(_M_local_data());
                	    }
                	}
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
                	      size_type __len2)
                    {
                      const size_type __how_much = length() - __pos - __len1;
                
                      size_type __new_capacity = length() + __len2 - __len1;
                      pointer __r = _M_create(__new_capacity, capacity());
                
                      if (__pos)
                	this->_S_copy(__r, _M_data(), __pos);
                      if (__s && __len2)
                	this->_S_copy(__r + __pos, __s, __len2);
                      if (__how_much)
                	this->_S_copy(__r + __pos + __len2,
                		      _M_data() + __pos + __len1, __how_much);
                
                      _M_dispose();
                      _M_data(__r);
                      _M_capacity(__new_capacity);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_erase(size_type __pos, size_type __n)
                    {
                      const size_type __how_much = length() - __pos - __n;
                
                      if (__how_much && __n)
                	this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
                
                      _M_set_length(length() - __n);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    resize(size_type __n, _CharT __c)
                    {
                      const size_type __size = this->size();
                      if (__size < __n)
                	this->append(__n - __size, __c);
                      else if (__n < __size)
                	this->_M_erase(__n, __size - __n);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_append(const _CharT* __s, size_type __n)
                    {
                      const size_type __len = __n + this->size();
                
                      if (__len <= this->capacity())
                	{
                	  if (__n)
                	    this->_S_copy(this->_M_data() + this->size(), __s, __n);
                	}
                      else
                	this->_M_mutate(this->size(), size_type(0), __s, __n);
                
                      this->_M_set_length(__len);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                      basic_string<_CharT, _Traits, _Alloc>&
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			  _InputIterator __k1, _InputIterator __k2,
                			  std::__false_type)
                      {
                	const basic_string __s(__k1, __k2);
                	const size_type __n1 = __i2 - __i1;
                	return _M_replace(__i1 - begin(), __n1, __s._M_data(),
                			  __s.size());
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		   _CharT __c)
                    {
                      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
                
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __n2 - __n1;
                
                      if (__new_size <= this->capacity())
                	{
                	  _CharT* __p = this->_M_data() + __pos1;
                
                	  const size_type __how_much = __old_size - __pos1 - __n1;
                	  if (__how_much && __n1 != __n2)
                	    this->_S_move(__p + __n2, __p + __n1, __how_much);
                	}
                      else
                	this->_M_mutate(__pos1, __n1, 0, __n2);
                
                      if (__n2)
                	this->_S_assign(this->_M_data() + __pos1, __n2, __c);
                
                      this->_M_set_length(__new_size);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
                	       const size_type __len2)
                    {
                      _M_check_length(__len1, __len2, "basic_string::_M_replace");
                
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __len2 - __len1;
                
                      if (__new_size <= this->capacity())
                	{
                	  _CharT* __p = this->_M_data() + __pos;
                
                	  const size_type __how_much = __old_size - __pos - __len1;
                	  if (_M_disjunct(__s))
                	    {
                	      if (__how_much && __len1 != __len2)
                		this->_S_move(__p + __len2, __p + __len1, __how_much);
                	      if (__len2)
                		this->_S_copy(__p, __s, __len2);
                	    }
                	  else
                	    {
                	      // Work in-place.
                	      if (__len2 && __len2 <= __len1)
                		this->_S_move(__p, __s, __len2);
                	      if (__how_much && __len1 != __len2)
                		this->_S_move(__p + __len2, __p + __len1, __how_much);
                	      if (__len2 > __len1)
                		{
                		  if (__s + __len2 <= __p + __len1)
                		    this->_S_move(__p, __s, __len2);
                		  else if (__s >= __p + __len1)
                		    this->_S_copy(__p, __s + __len2 - __len1, __len2);
                		  else
                		    {
                		      const size_type __nleft = (__p + __len1) - __s;
                		      this->_S_move(__p, __s, __nleft);
                		      this->_S_copy(__p + __nleft, __p + __len2,
                				    __len2 - __nleft);
                		    }
                		}
                	    }
                	}
                      else
                	this->_M_mutate(__pos, __len1, __s, __len2);
                
                      this->_M_set_length(__new_size);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    copy(_CharT* __s, size_type __n, size_type __pos) const
                    {
                      _M_check(__pos, "basic_string::copy");
                      __n = _M_limit(__pos, __n);
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	_S_copy(__s, _M_data() + __pos, __n);
                      // 21.3.5.7 par 3: do not append null.  (good.)
                      return __n;
                    }
                
                #else  // !_GLIBCXX_USE_CXX11_ABI
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const _CharT
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_terminal = _CharT();
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::npos;
                
                  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)
                  // at static init time (before static ctors are run).
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
                    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
                      sizeof(size_type)];
                
                  // NB: This is the special case for Input Iterators, used in
                  // istreambuf_iterators, etc.
                  // Input Iterators have a cost structure very different from
                  // pointers, calling for a different coding style.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   input_iterator_tag)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// Avoid reallocation for common case.
                	_CharT __buf[128];
                	size_type __len = 0;
                	while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
                	  {
                	    __buf[__len++] = *__beg;
                	    ++__beg;
                	  }
                	_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
                	_M_copy(__r->_M_refdata(), __buf, __len);
                	__try
                	  {
                	    while (__beg != __end)
                	      {
                		if (__len == __r->_M_capacity)
                		  {
                		    // Allocate more space.
                		    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
                		    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
                		    __r->_M_destroy(__a);
                		    __r = __another;
                		  }
                		__r->_M_refdata()[__len++] = *__beg;
                		++__beg;
                	      }
                	  }
                	__catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__len);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template <typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   forward_iterator_tag)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// NB: Not required, but considered best practice.
                	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                	  __throw_logic_error(__N("basic_string::_S_construct null not valid"));
                
                	const size_type __dnew = static_cast<size_type>(std::distance(__beg,
                								      __end));
                	// Check for out_of_range and length_error exceptions.
                	_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
                	__try
                	  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
                	__catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__dnew);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::
                    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
                    {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      if (__n == 0 && __a == _Alloc())
                	return _S_empty_rep()._M_refdata();
                #endif
                      // Check for out_of_range and length_error exceptions.
                      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
                      if (__n)
                	_M_assign(__r->_M_refdata(), __n, __c);
                
                      __r->_M_set_length_and_sharable(__n);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str)
                    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
                					  __str.get_allocator()),
                		  __str.get_allocator())
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _Alloc& __a)
                    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos, size_type __n)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, _Alloc()), _Alloc())
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos,
                		 size_type __n, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _CharT* __s, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
                			       __s + npos, __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__n, __c, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
                    { }
                
                #if __cplusplus >= 201103L
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
                    { }
                #endif
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const basic_string& __str)
                    {
                      if (_M_rep() != __str._M_rep())
                	{
                	  // XXX MT
                	  const allocator_type __a = this->get_allocator();
                	  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__tmp);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      _M_check_length(this->size(), __n, "basic_string::assign");
                      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                	return _M_replace_safe(size_type(0), this->size(), __s, __n);
                      else
                	{
                	  // Work in-place.
                	  const size_type __pos = __s - _M_data();
                	  if (__pos >= __n)
                	    _M_copy(_M_data(), __s, __n);
                	  else if (__pos)
                	    _M_move(_M_data(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__n);
                	  return *this;
                	}
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(size_type __n, _CharT __c)
                    {
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");	  
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_assign(_M_data() + this->size(), __n, __c);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    {
                	      if (_M_disjunct(__s))
                		this->reserve(__len);
                	      else
                		{
                		  const size_type __off = __s - _M_data();
                		  this->reserve(__len);
                		  __s = _M_data() + __off;
                		}
                	    }
                	  _M_copy(_M_data() + this->size(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str)
                    {
                      const size_type __size = __str.size();
                      if (__size)
                	{
                	  const size_type __len = __size + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data(), __size);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }    
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str, size_type __pos, size_type __n)
                    {
                      __str._M_check(__pos, "basic_string::append");
                      __n = __str._M_limit(__pos, __n);
                      if (__n)
                	{
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);	  
                	}
                      return *this;
                    }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     insert(size_type __pos, const _CharT* __s, size_type __n)
                     {
                       __glibcxx_requires_string_len(__s, __n);
                       _M_check(__pos, "basic_string::insert");
                       _M_check_length(size_type(0), __n, "basic_string::insert");
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, size_type(0), __s, __n);
                       else
                         {
                           // Work in-place.
                           const size_type __off = __s - _M_data();
                           _M_mutate(__pos, 0, __n);
                           __s = _M_data() + __off;
                           _CharT* __p = _M_data() + __pos;
                           if (__s  + __n <= __p)
                             _M_copy(__p, __s, __n);
                           else if (__s >= __p)
                             _M_copy(__p, __s + __n, __n);
                           else
                             {
                	       const size_type __nleft = __p - __s;
                               _M_copy(__p, __s, __nleft);
                               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
                             }
                           return *this;
                         }
                     }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     typename basic_string<_CharT, _Traits, _Alloc>::iterator
                     basic_string<_CharT, _Traits, _Alloc>::
                     erase(iterator __first, iterator __last)
                     {
                       _GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last
                				&& __last <= _M_iend());
                
                       // NB: This isn't just an optimization (bail out early when
                       // there is nothing to do, really), it's also a correctness
                       // issue vs MT, see libstdc++/40518.
                       const size_type __size = __last - __first;
                       if (__size)
                	 {
                	   const size_type __pos = __first - _M_ibegin();
                	   _M_mutate(__pos, __size, size_type(0));
                	   _M_rep()->_M_set_leaked();
                	   return iterator(_M_data() + __pos);
                	 }
                       else
                	 return __first;
                     }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     replace(size_type __pos, size_type __n1, const _CharT* __s,
                	     size_type __n2)
                     {
                       __glibcxx_requires_string_len(__s, __n2);
                       _M_check(__pos, "basic_string::replace");
                       __n1 = _M_limit(__pos, __n1);
                       _M_check_length(__n1, __n2, "basic_string::replace");
                       bool __left;
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, __n1, __s, __n2);
                       else if ((__left = __s + __n2 <= _M_data() + __pos)
                		|| _M_data() + __pos + __n1 <= __s)
                	 {
                	   // Work in-place: non-overlapping case.
                	   size_type __off = __s - _M_data();
                	   __left ? __off : (__off += __n2 - __n1);
                	   _M_mutate(__pos, __n1, __n2);
                	   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
                	   return *this;
                	 }
                       else
                	 {
                	   // Todo: overlapping case.
                	   const basic_string __tmp(__s, __n2);
                	   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
                	 }
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_destroy(const _Alloc& __a) throw ()
                    {
                      const size_type __size = sizeof(_Rep_base) +
                	                       (this->_M_capacity + 1) * sizeof(_CharT);
                      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_leak_hard()
                    {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      if (_M_rep() == &_S_empty_rep())
                	return;
                #endif
                      if (_M_rep()->_M_is_shared())
                	_M_mutate(0, 0, 0);
                      _M_rep()->_M_set_leaked();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
                    {
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __len2 - __len1;
                      const size_type __how_much = __old_size - __pos - __len1;
                
                      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
                	{
                	  // Must reallocate.
                	  const allocator_type __a = get_allocator();
                	  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
                
                	  if (__pos)
                	    _M_copy(__r->_M_refdata(), _M_data(), __pos);
                	  if (__how_much)
                	    _M_copy(__r->_M_refdata() + __pos + __len2,
                		    _M_data() + __pos + __len1, __how_much);
                
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__r->_M_refdata());
                	}
                      else if (__how_much && __len1 != __len2)
                	{
                	  // Work in-place.
                	  _M_move(_M_data() + __pos + __len2,
                		  _M_data() + __pos + __len1, __how_much);
                	}
                      _M_rep()->_M_set_length_and_sharable(__new_size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve(size_type __res)
                    {
                      if (__res != this->capacity() || _M_rep()->_M_is_shared())
                        {
                	  // Make sure we don't shrink below the current size
                	  if (__res < this->size())
                	    __res = this->size();
                	  const allocator_type __a = get_allocator();
                	  _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__tmp);
                        }
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    swap(basic_string& __s)
                    {
                      if (_M_rep()->_M_is_leaked())
                	_M_rep()->_M_set_sharable();
                      if (__s._M_rep()->_M_is_leaked())
                	__s._M_rep()->_M_set_sharable();
                      if (this->get_allocator() == __s.get_allocator())
                	{
                	  _CharT* __tmp = _M_data();
                	  _M_data(__s._M_data());
                	  __s._M_data(__tmp);
                	}
                      // The code below can usually be optimized away.
                      else
                	{
                	  const basic_string __tmp1(_M_ibegin(), _M_iend(),
                				    __s.get_allocator());
                	  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
                				    this->get_allocator());
                	  *this = __tmp2;
                	  __s = __tmp1;
                	}
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _S_create(size_type __capacity, size_type __old_capacity,
                	      const _Alloc& __alloc)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 83.  String::npos vs. string::max_size()
                      if (__capacity > _S_max_size)
                	__throw_length_error(__N("basic_string::_S_create"));
                
                      // The standard places no restriction on allocating more memory
                      // than is strictly needed within this layer at the moment or as
                      // requested by an explicit application call to reserve().
                
                      // Many malloc implementations perform quite poorly when an
                      // application attempts to allocate memory in a stepwise fashion
                      // growing each allocation size by only 1 char.  Additionally,
                      // it makes little sense to allocate less linear memory than the
                      // natural blocking size of the malloc implementation.
                      // Unfortunately, we would need a somewhat low-level calculation
                      // with tuned parameters to get this perfect for any particular
                      // malloc implementation.  Fortunately, generalizations about
                      // common features seen among implementations seems to suffice.
                
                      // __pagesize need not match the actual VM page size for good
                      // results in practice, thus we pick a common value on the low
                      // side.  __malloc_header_size is an estimate of the amount of
                      // overhead per memory allocation (in practice seen N * sizeof
                      // (void*) where N is 0, 2 or 4).  According to folklore,
                      // picking this value on the high side is better than
                      // low-balling it (especially when this algorithm is used with
                      // malloc implementations that allocate memory blocks rounded up
                      // to a size which is a power of 2).
                      const size_type __pagesize = 4096;
                      const size_type __malloc_header_size = 4 * sizeof(void*);
                
                      // The below implements an exponential growth policy, necessary to
                      // meet amortized linear time requirements of the library: see
                      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
                      // It's active for allocations requiring an amount of memory above
                      // system pagesize. This is consistent with the requirements of the
                      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html
                      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
                	__capacity = 2 * __old_capacity;
                
                      // NB: Need an array of char_type[__capacity], plus a terminating
                      // null char_type() element, plus enough for the _Rep data structure.
                      // Whew. Seemingly so needy, yet so elemental.
                      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                
                      const size_type __adj_size = __size + __malloc_header_size;
                      if (__adj_size > __pagesize && __capacity > __old_capacity)
                	{
                	  const size_type __extra = __pagesize - __adj_size % __pagesize;
                	  __capacity += __extra / sizeof(_CharT);
                	  // Never allocate a string bigger than _S_max_size.
                	  if (__capacity > _S_max_size)
                	    __capacity = _S_max_size;
                	  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                	}
                
                      // NB: Might throw, but no worries about a leak, mate: _Rep()
                      // does not throw.
                      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
                      _Rep *__p = new (__place) _Rep;
                      __p->_M_capacity = __capacity;
                      // ABI compatibility - 3.4.x set in _S_create both
                      // _M_refcount and _M_length.  All callers of _S_create
                      // in basic_string.tcc then set just _M_length.
                      // In 4.0.x and later both _M_refcount and _M_length
                      // are initialized in the callers, unfortunately we can
                      // have 3.4.x compiled code with _S_create callers inlined
                      // calling 4.0.x+ _S_create.
                      __p->_M_set_sharable();
                      return __p;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_clone(const _Alloc& __alloc, size_type __res)
                    {
                      // Requested capacity of the clone.
                      const size_type __requested_cap = this->_M_length + __res;
                      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
                				  __alloc);
                      if (this->_M_length)
                	_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
                
                      __r->_M_set_length_and_sharable(this->_M_length);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    resize(size_type __n, _CharT __c)
                    {
                      const size_type __size = this->size();
                      _M_check_length(__size, __n, "basic_string::resize");
                      if (__size < __n)
                	this->append(__n - __size, __c);
                      else if (__n < __size)
                	this->erase(__n);
                      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                      basic_string<_CharT, _Traits, _Alloc>&
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			  _InputIterator __k2, __false_type)
                      {
                	const basic_string __s(__k1, __k2);
                	const size_type __n1 = __i2 - __i1;
                	_M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
                	return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
                			       __s.size());
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		   _CharT __c)
                    {
                      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_assign(_M_data() + __pos1, __n2, __c);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		    size_type __n2)
                    {
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_copy(_M_data() + __pos1, __s, __n2);
                      return *this;
                    }
                
                    template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    copy(_CharT* __s, size_type __n, size_type __pos) const
                    {
                      _M_check(__pos, "basic_string::copy");
                      __n = _M_limit(__pos, __n);
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	_M_copy(__s, _M_data() + __pos, __n);
                      // 21.3.5.7 par 3: do not append null.  (good.)
                      return __n;
                    }
                #endif  // !_GLIBCXX_USE_CXX11_ABI
                   
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      __glibcxx_requires_string(__lhs);
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      const __size_type __len = _Traits::length(__lhs);
                      __string_type __str;
                      __str.reserve(__len + __rhs.size());
                      __str.append(__lhs, __len);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      __string_type __str;
                      const __size_type __len = __rhs.size();
                      __str.reserve(__len + 1);
                      __str.append(__size_type(1), __lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      const size_type __size = this->size();
                      const _CharT* __data = _M_data();
                
                      if (__n == 0)
                	return __pos <= __size ? __pos : npos;
                
                      if (__n <= __size)
                	{
                	  for (; __pos <= __size - __n; ++__pos)
                	    if (traits_type::eq(__data[__pos], __s[0])
                		&& traits_type::compare(__data + __pos + 1,
                					__s + 1, __n - 1) == 0)
                	      return __pos;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __ret = npos;
                      const size_type __size = this->size();
                      if (__pos < __size)
                	{
                	  const _CharT* __data = _M_data();
                	  const size_type __n = __size - __pos;
                	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
                	  if (__p)
                	    __ret = __p - __data;
                	}
                      return __ret;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      const size_type __size = this->size();
                      if (__n <= __size)
                	{
                	  __pos = std::min(size_type(__size - __n), __pos);
                	  const _CharT* __data = _M_data();
                	  do
                	    {
                	      if (traits_type::compare(__data + __pos, __s, __n) == 0)
                		return __pos;
                	    }
                	  while (__pos-- > 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  for (++__size; __size-- > 0; )
                	    if (traits_type::eq(_M_data()[__size], __c))
                	      return __size;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __n && __pos < this->size(); ++__pos)
                	{
                	  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
                	  if (__p)
                	    return __pos;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size && __n)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size-- != 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::find(__s, __n, _M_data()[__pos]))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::eq(_M_data()[__pos], __c))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::eq(_M_data()[__size], __c))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n, const basic_string& __str) const
                    {
                      _M_check(__pos, "basic_string::compare");
                      __n = _M_limit(__pos, __n);
                      const size_type __osize = __str.size();
                      const size_type __len = std::min(__n, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
                      if (!__r)
                	__r = _S_compare(__n, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	    size_type __pos2, size_type __n2) const
                    {
                      _M_check(__pos1, "basic_string::compare");
                      __str._M_check(__pos2, "basic_string::compare");
                      __n1 = _M_limit(__pos1, __n1);
                      __n2 = __str._M_limit(__pos2, __n2);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos1,
                				     __str.data() + __pos2, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __n2);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(const _CharT* __s) const
                    {
                      __glibcxx_requires_string(__s);
                      const size_type __size = this->size();
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__size, __osize);
                      int __r = traits_type::compare(_M_data(), __s, __len);
                      if (!__r)
                	__r = _S_compare(__size, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s) const
                    {
                      __glibcxx_requires_string(__s);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__n1, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s,
                	    size_type __n2) const
                    {
                      __glibcxx_requires_string_len(__s, __n2);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __n2);
                      return __r;
                    }
                
                  // 21.3.7.9 basic_string::getline and operators
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __in,
                	       basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      typedef basic_istream<_CharT, _Traits>		__istream_type;
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __istream_type::ios_base         __ios_base;
                      typedef typename __istream_type::int_type		__int_type;
                      typedef typename __string_type::size_type		__size_type;
                      typedef ctype<_CharT>				__ctype_type;
                      typedef typename __ctype_type::ctype_base         __ctype_base;
                
                      __size_type __extracted = 0;
                      typename __ios_base::iostate __err = __ios_base::goodbit;
                      typename __istream_type::sentry __cerb(__in, false);
                      if (__cerb)
                	{
                	  __try
                	    {
                	      // Avoid reallocation for common case.
                	      __str.erase();
                	      _CharT __buf[128];
                	      __size_type __len = 0;	      
                	      const streamsize __w = __in.width();
                	      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                		                              : __str.max_size();
                	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
                	      const __int_type __eof = _Traits::eof();
                	      __int_type __c = __in.rdbuf()->sgetc();
                
                	      while (__extracted < __n
                		     && !_Traits::eq_int_type(__c, __eof)
                		     && !__ct.is(__ctype_base::space,
                				 _Traits::to_char_type(__c)))
                		{
                		  if (__len == sizeof(__buf) / sizeof(_CharT))
                		    {
                		      __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
                		      __len = 0;
                		    }
                		  __buf[__len++] = _Traits::to_char_type(__c);
                		  ++__extracted;
                		  __c = __in.rdbuf()->snextc();
                		}
                	      __str.append(__buf, __len);
                
                	      if (_Traits::eq_int_type(__c, __eof))
                		__err |= __ios_base::eofbit;
                	      __in.width(0);
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __in._M_setstate(__ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    {
                	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	      // 91. Description of operator>> and getline() for string<>
                	      // might cause endless loop
                	      __in._M_setstate(__ios_base::badbit);
                	    }
                	}
                      // 211.  operator>>(istream&, string&) doesn't set failbit
                      if (!__extracted)
                	__err |= __ios_base::failbit;
                      if (__err)
                	__in.setstate(__err);
                      return __in;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __in,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    {
                      typedef basic_istream<_CharT, _Traits>		__istream_type;
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __istream_type::ios_base         __ios_base;
                      typedef typename __istream_type::int_type		__int_type;
                      typedef typename __string_type::size_type		__size_type;
                
                      __size_type __extracted = 0;
                      const __size_type __n = __str.max_size();
                      typename __ios_base::iostate __err = __ios_base::goodbit;
                      typename __istream_type::sentry __cerb(__in, true);
                      if (__cerb)
                	{
                	  __try
                	    {
                	      __str.erase();
                	      const __int_type __idelim = _Traits::to_int_type(__delim);
                	      const __int_type __eof = _Traits::eof();
                	      __int_type __c = __in.rdbuf()->sgetc();
                
                	      while (__extracted < __n
                		     && !_Traits::eq_int_type(__c, __eof)
                		     && !_Traits::eq_int_type(__c, __idelim))
                		{
                		  __str += _Traits::to_char_type(__c);
                		  ++__extracted;
                		  __c = __in.rdbuf()->snextc();
                		}
                
                	      if (_Traits::eq_int_type(__c, __eof))
                		__err |= __ios_base::eofbit;
                	      else if (_Traits::eq_int_type(__c, __idelim))
                		{
                		  ++__extracted;		  
                		  __in.rdbuf()->sbumpc();
                		}
                	      else
                		__err |= __ios_base::failbit;
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __in._M_setstate(__ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    {
                	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	      // 91. Description of operator>> and getline() for string<>
                	      // might cause endless loop
                	      __in._M_setstate(__ios_base::badbit);
                	    }
                	}
                      if (!__extracted)
                	__err |= __ios_base::failbit;
                      if (__err)
                	__in.setstate(__err);
                      return __in;
                    }
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE > 0
                  extern template class basic_string<char>;
                  extern template
                    basic_istream<char>&
                    operator>>(basic_istream<char>&, string&);
                  extern template
                    basic_ostream<char>&
                    operator<<(basic_ostream<char>&, const string&);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&, char);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  extern template class basic_string<wchar_t>;
                  extern template
                    basic_istream<wchar_t>&
                    operator>>(basic_istream<wchar_t>&, wstring&);
                  extern template
                    basic_ostream<wchar_t>&
                    operator<<(basic_ostream<wchar_t>&, const wstring&);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&);
                #endif
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      210         16

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       16   Total number of line executions
    16.00   Average executions per line


*** File /usr/include/c++/5/atomic:
                // -*- C++ -*- header.
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/atomic
                 *  This is a Standard C++ Library header.
                 */
                
                // Based on "C++ Atomic Types and Operations" by Hans Boehm and Lawrence Crowl.
                // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html
                
                #ifndef _GLIBCXX_ATOMIC
                #define _GLIBCXX_ATOMIC 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <bits/atomic_base.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup atomics
                   * @{
                   */
                
                  template<typename _Tp>
                    struct atomic;
                
                  /// atomic<bool>
                  // NB: No operators or fetch-operations for this type.
                  template<>
                  struct atomic<bool>
                  {
                  private:
                    __atomic_base<bool>	_M_base;
                
                  public:
                    atomic() noexcept = default;
                    ~atomic() noexcept = default;
                    atomic(const atomic&) = delete;
                    atomic& operator=(const atomic&) = delete;
                    atomic& operator=(const atomic&) volatile = delete;
                
         107 ->     constexpr atomic(bool __i) noexcept : _M_base(__i) { }
                
                    bool
           6 ->     operator=(bool __i) noexcept
                    { return _M_base.operator=(__i); }
                
                    bool
                    operator=(bool __i) volatile noexcept
                    { return _M_base.operator=(__i); }
                
          40 ->     operator bool() const noexcept
                    { return _M_base.load(); }
                
                    operator bool() const volatile noexcept
                    { return _M_base.load(); }
                
                    bool
                    is_lock_free() const noexcept { return _M_base.is_lock_free(); }
                
                    bool
                    is_lock_free() const volatile noexcept { return _M_base.is_lock_free(); }
                
                    void
                    store(bool __i, memory_order __m = memory_order_seq_cst) noexcept
                    { _M_base.store(__i, __m); }
                
                    void
                    store(bool __i, memory_order __m = memory_order_seq_cst) volatile noexcept
                    { _M_base.store(__i, __m); }
                
                    bool
        6678 ->     load(memory_order __m = memory_order_seq_cst) const noexcept
                    { return _M_base.load(__m); }
                
                    bool
                    load(memory_order __m = memory_order_seq_cst) const volatile noexcept
                    { return _M_base.load(__m); }
                
                    bool
                    exchange(bool __i, memory_order __m = memory_order_seq_cst) noexcept
                    { return _M_base.exchange(__i, __m); }
                
                    bool
                    exchange(bool __i,
                	     memory_order __m = memory_order_seq_cst) volatile noexcept
                    { return _M_base.exchange(__i, __m); }
                
                    bool
                    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
                			  memory_order __m2) noexcept
                    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }
                
                    bool
                    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
                			  memory_order __m2) volatile noexcept
                    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }
                
                    bool
                    compare_exchange_weak(bool& __i1, bool __i2,
                			  memory_order __m = memory_order_seq_cst) noexcept
                    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }
                
                    bool
                    compare_exchange_weak(bool& __i1, bool __i2,
                		     memory_order __m = memory_order_seq_cst) volatile noexcept
                    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }
                
                    bool
                    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
                			    memory_order __m2) noexcept
                    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }
                
                    bool
                    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
                			    memory_order __m2) volatile noexcept
                    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }
                
                    bool
                    compare_exchange_strong(bool& __i1, bool __i2,
                			    memory_order __m = memory_order_seq_cst) noexcept
                    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
                
                    bool
                    compare_exchange_strong(bool& __i1, bool __i2,
                		    memory_order __m = memory_order_seq_cst) volatile noexcept
                    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
                  };
                
                
                  /**
                   *  @brief Generic atomic type, primary class template.
                   *
                   *  @tparam _Tp  Type to be made atomic, must be trivally copyable.
                   */
                  template<typename _Tp>
                    struct atomic
                    {
                    private:
                      // Align 1/2/4/8/16-byte types to at least their size.
                      static constexpr int _S_min_alignment
                	= (sizeof(_Tp) & (sizeof(_Tp) - 1)) || sizeof(_Tp) > 16
                	? 0 : sizeof(_Tp);
                
                      static constexpr int _S_alignment
                        = _S_min_alignment > alignof(_Tp) ? _S_min_alignment : alignof(_Tp);
                
                      alignas(_S_alignment) _Tp _M_i;
                
                      static_assert(__is_trivially_copyable(_Tp),
                		    "std::atomic requires a trivially copyable type");
                
                      static_assert(sizeof(_Tp) > 0,
                		    "Incomplete or zero-sized types are not supported");
                
                    public:
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
                
                      operator _Tp() const noexcept
                      { return load(); }
                
                      operator _Tp() const volatile noexcept
                      { return load(); }
                
                      _Tp
                      operator=(_Tp __i) noexcept 
                      { store(__i); return __i; }
                
                      _Tp
                      operator=(_Tp __i) volatile noexcept 
                      { store(__i); return __i; }
                
                      bool
                      is_lock_free() const noexcept
                      {
                	// Produce a fake, minimally aligned pointer.
                	return __atomic_is_lock_free(sizeof(_M_i),
                	    reinterpret_cast<void *>(-__alignof(_M_i)));
                      }
                
                      bool
                      is_lock_free() const volatile noexcept
                      {
                	// Produce a fake, minimally aligned pointer.
                	return __atomic_is_lock_free(sizeof(_M_i),
                	    reinterpret_cast<void *>(-__alignof(_M_i)));
                      }
                
                      void
                      store(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept
                      { __atomic_store(&_M_i, &__i, __m); }
                
                      void
                      store(_Tp __i, memory_order __m = memory_order_seq_cst) volatile noexcept
                      { __atomic_store(&_M_i, &__i, __m); }
                
                      _Tp
                      load(memory_order __m = memory_order_seq_cst) const noexcept
                      { 
                        _Tp tmp;
                	__atomic_load(&_M_i, &tmp, __m);
                	return tmp;
                      }
                
                      _Tp
                      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
                      { 
                        _Tp tmp;
                	__atomic_load(&_M_i, &tmp, __m);
                	return tmp;
                      }
                
                      _Tp
                      exchange(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept
                      { 
                        _Tp tmp;
                	__atomic_exchange(&_M_i, &__i, &tmp, __m);
                	return tmp;
                      }
                
                      _Tp
                      exchange(_Tp __i, 
                	       memory_order __m = memory_order_seq_cst) volatile noexcept
                      { 
                        _Tp tmp;
                	__atomic_exchange(&_M_i, &__i, &tmp, __m);
                	return tmp;
                      }
                
                      bool
                      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s, 
                			    memory_order __f) noexcept
                      {
                	return __atomic_compare_exchange(&_M_i, &__e, &__i, true, __s, __f);
                      }
                
                      bool
                      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s, 
                			    memory_order __f) volatile noexcept
                      {
                	return __atomic_compare_exchange(&_M_i, &__e, &__i, true, __s, __f);
                      }
                
                      bool
                      compare_exchange_weak(_Tp& __e, _Tp __i,
                			    memory_order __m = memory_order_seq_cst) noexcept
                      { return compare_exchange_weak(__e, __i, __m,
                                                     __cmpexch_failure_order(__m)); }
                
                      bool
                      compare_exchange_weak(_Tp& __e, _Tp __i,
                		     memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return compare_exchange_weak(__e, __i, __m,
                                                     __cmpexch_failure_order(__m)); }
                
                      bool
                      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
                			      memory_order __f) noexcept
                      {
                	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
                      }
                
                      bool
                      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
                			      memory_order __f) volatile noexcept
                      {
                	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
                      }
                
                      bool
                      compare_exchange_strong(_Tp& __e, _Tp __i,
                			       memory_order __m = memory_order_seq_cst) noexcept
                      { return compare_exchange_strong(__e, __i, __m,
                                                       __cmpexch_failure_order(__m)); }
                
                      bool
                      compare_exchange_strong(_Tp& __e, _Tp __i,
                		     memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return compare_exchange_strong(__e, __i, __m,
                                                       __cmpexch_failure_order(__m)); }
                    };
                
                
                  /// Partial specialization for pointer types.
                  template<typename _Tp>
                    struct atomic<_Tp*>
                    {
                      typedef _Tp* 			__pointer_type;
                      typedef __atomic_base<_Tp*>	__base_type;
                      __base_type			_M_b;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__pointer_type __p) noexcept : _M_b(__p) { }
                
                      operator __pointer_type() const noexcept
                      { return __pointer_type(_M_b); }
                
                      operator __pointer_type() const volatile noexcept
                      { return __pointer_type(_M_b); }
                
                      __pointer_type
                      operator=(__pointer_type __p) noexcept
                      { return _M_b.operator=(__p); }
                
                      __pointer_type
                      operator=(__pointer_type __p) volatile noexcept
                      { return _M_b.operator=(__p); }
                
                      __pointer_type
                      operator++(int) noexcept
                      { return _M_b++; }
                
                      __pointer_type
                      operator++(int) volatile noexcept
                      { return _M_b++; }
                
                      __pointer_type
                      operator--(int) noexcept
                      { return _M_b--; }
                
                      __pointer_type
                      operator--(int) volatile noexcept
                      { return _M_b--; }
                
                      __pointer_type
                      operator++() noexcept
                      { return ++_M_b; }
                
                      __pointer_type
                      operator++() volatile noexcept
                      { return ++_M_b; }
                
                      __pointer_type
                      operator--() noexcept
                      { return --_M_b; }
                
                      __pointer_type
                      operator--() volatile noexcept
                      { return --_M_b; }
                
                      __pointer_type
                      operator+=(ptrdiff_t __d) noexcept
                      { return _M_b.operator+=(__d); }
                
                      __pointer_type
                      operator+=(ptrdiff_t __d) volatile noexcept
                      { return _M_b.operator+=(__d); }
                
                      __pointer_type
                      operator-=(ptrdiff_t __d) noexcept
                      { return _M_b.operator-=(__d); }
                
                      __pointer_type
                      operator-=(ptrdiff_t __d) volatile noexcept
                      { return _M_b.operator-=(__d); }
                
                      bool
                      is_lock_free() const noexcept
                      { return _M_b.is_lock_free(); }
                
                      bool
                      is_lock_free() const volatile noexcept
                      { return _M_b.is_lock_free(); }
                
                      void
                      store(__pointer_type __p,
                	    memory_order __m = memory_order_seq_cst) noexcept
                      { return _M_b.store(__p, __m); }
                
                      void
                      store(__pointer_type __p,
                	    memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return _M_b.store(__p, __m); }
                
                      __pointer_type
                      load(memory_order __m = memory_order_seq_cst) const noexcept
                      { return _M_b.load(__m); }
                
                      __pointer_type
                      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
                      { return _M_b.load(__m); }
                
                      __pointer_type
                      exchange(__pointer_type __p,
                	       memory_order __m = memory_order_seq_cst) noexcept
                      { return _M_b.exchange(__p, __m); }
                
                      __pointer_type
                      exchange(__pointer_type __p,
                	       memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return _M_b.exchange(__p, __m); }
                
                      bool
                      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
                			    memory_order __m1, memory_order __m2) noexcept
                      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
                
                      bool
                      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
                			    memory_order __m1,
                			    memory_order __m2) volatile noexcept
                      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
                
                      bool
                      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
                			    memory_order __m = memory_order_seq_cst) noexcept
                      {
                	return compare_exchange_weak(__p1, __p2, __m,
                				     __cmpexch_failure_order(__m));
                      }
                
                      bool
                      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
                		    memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                	return compare_exchange_weak(__p1, __p2, __m,
                				     __cmpexch_failure_order(__m));
                      }
                
                      bool
                      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
                			      memory_order __m1, memory_order __m2) noexcept
                      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
                
                      bool
                      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
                			      memory_order __m1,
                			      memory_order __m2) volatile noexcept
                      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }
                
                      bool
                      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
                			      memory_order __m = memory_order_seq_cst) noexcept
                      {
                	return _M_b.compare_exchange_strong(__p1, __p2, __m,
                					    __cmpexch_failure_order(__m));
                      }
                
                      bool
                      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
                		    memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                	return _M_b.compare_exchange_strong(__p1, __p2, __m,
                					    __cmpexch_failure_order(__m));
                      }
                
                      __pointer_type
                      fetch_add(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return _M_b.fetch_add(__d, __m); }
                
                      __pointer_type
                      fetch_add(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return _M_b.fetch_add(__d, __m); }
                
                      __pointer_type
                      fetch_sub(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return _M_b.fetch_sub(__d, __m); }
                
                      __pointer_type
                      fetch_sub(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return _M_b.fetch_sub(__d, __m); }
                    };
                
                
                  /// Explicit specialization for char.
                  template<>
                    struct atomic<char> : __atomic_base<char>
                    {
                      typedef char 			__integral_type;
                      typedef __atomic_base<char> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for signed char.
                  template<>
                    struct atomic<signed char> : __atomic_base<signed char>
                    {
                      typedef signed char 		__integral_type;
                      typedef __atomic_base<signed char> 	__base_type;
                
                      atomic() noexcept= default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for unsigned char.
                  template<>
                    struct atomic<unsigned char> : __atomic_base<unsigned char>
                    {
                      typedef unsigned char 		__integral_type;
                      typedef __atomic_base<unsigned char> 	__base_type;
                
                      atomic() noexcept= default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for short.
                  template<>
                    struct atomic<short> : __atomic_base<short>
                    {
                      typedef short 			__integral_type;
                      typedef __atomic_base<short> 		__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for unsigned short.
                  template<>
                    struct atomic<unsigned short> : __atomic_base<unsigned short>
                    {
                      typedef unsigned short 	      	__integral_type;
                      typedef __atomic_base<unsigned short> 		__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for int.
                  template<>
                    struct atomic<int> : __atomic_base<int>
                    {
                      typedef int 			__integral_type;
                      typedef __atomic_base<int> 		__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for unsigned int.
                  template<>
                    struct atomic<unsigned int> : __atomic_base<unsigned int>
                    {
                      typedef unsigned int		__integral_type;
                      typedef __atomic_base<unsigned int> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for long.
                  template<>
                    struct atomic<long> : __atomic_base<long>
                    {
                      typedef long 			__integral_type;
                      typedef __atomic_base<long> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for unsigned long.
                  template<>
                    struct atomic<unsigned long> : __atomic_base<unsigned long>
                    {
                      typedef unsigned long 		__integral_type;
                      typedef __atomic_base<unsigned long> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
           7 ->       constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for long long.
                  template<>
                    struct atomic<long long> : __atomic_base<long long>
                    {
                      typedef long long 		__integral_type;
                      typedef __atomic_base<long long> 		__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for unsigned long long.
                  template<>
                    struct atomic<unsigned long long> : __atomic_base<unsigned long long>
                    {
                      typedef unsigned long long       	__integral_type;
                      typedef __atomic_base<unsigned long long> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for wchar_t.
                  template<>
                    struct atomic<wchar_t> : __atomic_base<wchar_t>
                    {
                      typedef wchar_t 			__integral_type;
                      typedef __atomic_base<wchar_t> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for char16_t.
                  template<>
                    struct atomic<char16_t> : __atomic_base<char16_t>
                    {
                      typedef char16_t 			__integral_type;
                      typedef __atomic_base<char16_t> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                  /// Explicit specialization for char32_t.
                  template<>
                    struct atomic<char32_t> : __atomic_base<char32_t>
                    {
                      typedef char32_t 			__integral_type;
                      typedef __atomic_base<char32_t> 	__base_type;
                
                      atomic() noexcept = default;
                      ~atomic() noexcept = default;
                      atomic(const atomic&) = delete;
                      atomic& operator=(const atomic&) = delete;
                      atomic& operator=(const atomic&) volatile = delete;
                
                      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }
                
                      using __base_type::operator __integral_type;
                      using __base_type::operator=;
                    };
                
                
                  /// atomic_bool
                  typedef atomic<bool>			atomic_bool;
                
                  /// atomic_char
                  typedef atomic<char>			atomic_char;
                
                  /// atomic_schar
                  typedef atomic<signed char>		atomic_schar;
                
                  /// atomic_uchar
                  typedef atomic<unsigned char>		atomic_uchar;
                
                  /// atomic_short
                  typedef atomic<short>			atomic_short;
                
                  /// atomic_ushort
                  typedef atomic<unsigned short>	atomic_ushort;
                
                  /// atomic_int
                  typedef atomic<int>			atomic_int;
                
                  /// atomic_uint
                  typedef atomic<unsigned int>		atomic_uint;
                
                  /// atomic_long
                  typedef atomic<long>			atomic_long;
                
                  /// atomic_ulong
                  typedef atomic<unsigned long>		atomic_ulong;
                
                  /// atomic_llong
                  typedef atomic<long long>		atomic_llong;
                
                  /// atomic_ullong
                  typedef atomic<unsigned long long>	atomic_ullong;
                
                  /// atomic_wchar_t
                  typedef atomic<wchar_t>		atomic_wchar_t;
                
                  /// atomic_char16_t
                  typedef atomic<char16_t>		atomic_char16_t;
                
                  /// atomic_char32_t
                  typedef atomic<char32_t>		atomic_char32_t;
                
                
                  /// atomic_int_least8_t
                  typedef atomic<int_least8_t>		atomic_int_least8_t;
                
                  /// atomic_uint_least8_t
                  typedef atomic<uint_least8_t>		atomic_uint_least8_t;
                
                  /// atomic_int_least16_t
                  typedef atomic<int_least16_t>		atomic_int_least16_t;
                
                  /// atomic_uint_least16_t
                  typedef atomic<uint_least16_t>	atomic_uint_least16_t;
                
                  /// atomic_int_least32_t
                  typedef atomic<int_least32_t>		atomic_int_least32_t;
                
                  /// atomic_uint_least32_t
                  typedef atomic<uint_least32_t>	atomic_uint_least32_t;
                
                  /// atomic_int_least64_t
                  typedef atomic<int_least64_t>		atomic_int_least64_t;
                
                  /// atomic_uint_least64_t
                  typedef atomic<uint_least64_t>	atomic_uint_least64_t;
                
                
                  /// atomic_int_fast8_t
                  typedef atomic<int_fast8_t>		atomic_int_fast8_t;
                
                  /// atomic_uint_fast8_t
                  typedef atomic<uint_fast8_t>		atomic_uint_fast8_t;
                
                  /// atomic_int_fast16_t
                  typedef atomic<int_fast16_t>		atomic_int_fast16_t;
                
                  /// atomic_uint_fast16_t
                  typedef atomic<uint_fast16_t>		atomic_uint_fast16_t;
                
                  /// atomic_int_fast32_t
                  typedef atomic<int_fast32_t>		atomic_int_fast32_t;
                
                  /// atomic_uint_fast32_t
                  typedef atomic<uint_fast32_t>		atomic_uint_fast32_t;
                
                  /// atomic_int_fast64_t
                  typedef atomic<int_fast64_t>		atomic_int_fast64_t;
                
                  /// atomic_uint_fast64_t
                  typedef atomic<uint_fast64_t>		atomic_uint_fast64_t;
                
                
                  /// atomic_intptr_t
                  typedef atomic<intptr_t>		atomic_intptr_t;
                
                  /// atomic_uintptr_t
                  typedef atomic<uintptr_t>		atomic_uintptr_t;
                
                  /// atomic_size_t
                  typedef atomic<size_t>		atomic_size_t;
                
                  /// atomic_intmax_t
                  typedef atomic<intmax_t>		atomic_intmax_t;
                
                  /// atomic_uintmax_t
                  typedef atomic<uintmax_t>		atomic_uintmax_t;
                
                  /// atomic_ptrdiff_t
                  typedef atomic<ptrdiff_t>		atomic_ptrdiff_t;
                
                
                  // Function definitions, atomic_flag operations.
                  inline bool
                  atomic_flag_test_and_set_explicit(atomic_flag* __a,
                				    memory_order __m) noexcept
                  { return __a->test_and_set(__m); }
                
                  inline bool
                  atomic_flag_test_and_set_explicit(volatile atomic_flag* __a,
                				    memory_order __m) noexcept
                  { return __a->test_and_set(__m); }
                
                  inline void
                  atomic_flag_clear_explicit(atomic_flag* __a, memory_order __m) noexcept
                  { __a->clear(__m); }
                
                  inline void
                  atomic_flag_clear_explicit(volatile atomic_flag* __a,
                			     memory_order __m) noexcept
                  { __a->clear(__m); }
                
                  inline bool
                  atomic_flag_test_and_set(atomic_flag* __a) noexcept
                  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }
                
                  inline bool
                  atomic_flag_test_and_set(volatile atomic_flag* __a) noexcept
                  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }
                
                  inline void
                  atomic_flag_clear(atomic_flag* __a) noexcept
                  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }
                
                  inline void
                  atomic_flag_clear(volatile atomic_flag* __a) noexcept
                  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }
                
                
                  // Function templates generally applicable to atomic types.
                  template<typename _ITp>
                    inline bool
                    atomic_is_lock_free(const atomic<_ITp>* __a) noexcept
                    { return __a->is_lock_free(); }
                
                  template<typename _ITp>
                    inline bool
                    atomic_is_lock_free(const volatile atomic<_ITp>* __a) noexcept
                    { return __a->is_lock_free(); }
                
                  template<typename _ITp>
                    inline void
                    atomic_init(atomic<_ITp>* __a, _ITp __i) noexcept
                    { __a->store(__i, memory_order_relaxed); }
                
                  template<typename _ITp>
                    inline void
                    atomic_init(volatile atomic<_ITp>* __a, _ITp __i) noexcept
                    { __a->store(__i, memory_order_relaxed); }
                
                  template<typename _ITp>
                    inline void
                    atomic_store_explicit(atomic<_ITp>* __a, _ITp __i,
                			  memory_order __m) noexcept
                    { __a->store(__i, __m); }
                
                  template<typename _ITp>
                    inline void
                    atomic_store_explicit(volatile atomic<_ITp>* __a, _ITp __i,
                			  memory_order __m) noexcept
                    { __a->store(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_load_explicit(const atomic<_ITp>* __a, memory_order __m) noexcept
                    { return __a->load(__m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_load_explicit(const volatile atomic<_ITp>* __a,
                			 memory_order __m) noexcept
                    { return __a->load(__m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_exchange_explicit(atomic<_ITp>* __a, _ITp __i,
                			     memory_order __m) noexcept
                    { return __a->exchange(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_exchange_explicit(volatile atomic<_ITp>* __a, _ITp __i,
                			     memory_order __m) noexcept
                    { return __a->exchange(__i, __m); }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_weak_explicit(atomic<_ITp>* __a,
                					  _ITp* __i1, _ITp __i2,
                					  memory_order __m1,
                					  memory_order __m2) noexcept
                    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_weak_explicit(volatile atomic<_ITp>* __a,
                					  _ITp* __i1, _ITp __i2,
                					  memory_order __m1,
                					  memory_order __m2) noexcept
                    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_strong_explicit(atomic<_ITp>* __a,
                					    _ITp* __i1, _ITp __i2,
                					    memory_order __m1,
                					    memory_order __m2) noexcept
                    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_strong_explicit(volatile atomic<_ITp>* __a,
                					    _ITp* __i1, _ITp __i2,
                					    memory_order __m1,
                					    memory_order __m2) noexcept
                    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }
                
                
                  template<typename _ITp>
                    inline void
                    atomic_store(atomic<_ITp>* __a, _ITp __i) noexcept
                    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline void
                    atomic_store(volatile atomic<_ITp>* __a, _ITp __i) noexcept
                    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_load(const atomic<_ITp>* __a) noexcept
                    { return atomic_load_explicit(__a, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_load(const volatile atomic<_ITp>* __a) noexcept
                    { return atomic_load_explicit(__a, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_exchange(atomic<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_exchange(volatile atomic<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_weak(atomic<_ITp>* __a,
                				 _ITp* __i1, _ITp __i2) noexcept
                    {
                      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,
                						   memory_order_seq_cst,
                						   memory_order_seq_cst);
                    }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_weak(volatile atomic<_ITp>* __a,
                				 _ITp* __i1, _ITp __i2) noexcept
                    {
                      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,
                						   memory_order_seq_cst,
                						   memory_order_seq_cst);
                    }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_strong(atomic<_ITp>* __a,
                				   _ITp* __i1, _ITp __i2) noexcept
                    {
                      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,
                						     memory_order_seq_cst,
                						     memory_order_seq_cst);
                    }
                
                  template<typename _ITp>
                    inline bool
                    atomic_compare_exchange_strong(volatile atomic<_ITp>* __a,
                				   _ITp* __i1, _ITp __i2) noexcept
                    {
                      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,
                						     memory_order_seq_cst,
                						     memory_order_seq_cst);
                    }
                
                  // Function templates for atomic_integral operations only, using
                  // __atomic_base. Template argument should be constricted to
                  // intergral types as specified in the standard, excluding address
                  // types.
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_add_explicit(__atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_add(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_add_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_add(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_sub_explicit(__atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_sub(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_sub_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_sub(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_and_explicit(__atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_and(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_and(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_or_explicit(__atomic_base<_ITp>* __a, _ITp __i,
                			     memory_order __m) noexcept
                    { return __a->fetch_or(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
                			     memory_order __m) noexcept
                    { return __a->fetch_or(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_xor_explicit(__atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_xor(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
                			      memory_order __m) noexcept
                    { return __a->fetch_xor(__i, __m); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_add(__atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_add(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_sub(__atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_sub(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_and(__atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_and(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_or(__atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_or(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_xor(__atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }
                
                  template<typename _ITp>
                    inline _ITp
                    atomic_fetch_xor(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
                    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }
                
                
                  // Partial specializations for pointers.
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_add_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
                			      memory_order __m) noexcept
                    { return __a->fetch_add(__d, __m); }
                
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_add_explicit(volatile atomic<_ITp*>* __a, ptrdiff_t __d,
                			      memory_order __m) noexcept
                    { return __a->fetch_add(__d, __m); }
                
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_add(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
                    { return __a->fetch_add(__d); }
                
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_add(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
                    { return __a->fetch_add(__d); }
                
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_sub_explicit(volatile atomic<_ITp*>* __a,
                			      ptrdiff_t __d, memory_order __m) noexcept
                    { return __a->fetch_sub(__d, __m); }
                
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_sub_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
                			      memory_order __m) noexcept
                    { return __a->fetch_sub(__d, __m); }
                
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_sub(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
                    { return __a->fetch_sub(__d); }
                
                  template<typename _ITp>
                    inline _ITp*
                    atomic_fetch_sub(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
                    { return __a->fetch_sub(__d); }
                  // @} group atomics
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif // C++11
                
                #endif // _GLIBCXX_ATOMIC


Top 10 Lines:

     Line      Count

      101       6678
       70        107
       80         40
      673          7
       73          6

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

     6838   Total number of line executions
  1367.60   Average executions per line


*** File /usr/include/c++/5/bits/ios_base.h:
                // Iostreams base classes -*- C++ -*-
                
                // Copyright (C) 1997-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/ios_base.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{ios}
                 */
                
                //
                // ISO C++ 14882: 27.4  Iostreams base classes
                //
                
                #ifndef _IOS_BASE_H
                #define _IOS_BASE_H 1
                
                #pragma GCC system_header
                
                #include <ext/atomicity.h>
                #include <bits/localefwd.h>
                #include <bits/locale_classes.h>
                
                #if __cplusplus < 201103L
                # include <stdexcept>
                #else
                # include <system_error>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // The following definitions of bitmask types are enums, not ints,
                  // as permitted (but not required) in the standard, in order to provide
                  // better type safety in iostream calls.  A side effect is that
                  // expressions involving them are no longer compile-time constants.
                  enum _Ios_Fmtflags 
                    { 
                      _S_boolalpha 	= 1L << 0,
                      _S_dec 		= 1L << 1,
                      _S_fixed 		= 1L << 2,
                      _S_hex 		= 1L << 3,
                      _S_internal 	= 1L << 4,
                      _S_left 		= 1L << 5,
                      _S_oct 		= 1L << 6,
                      _S_right 		= 1L << 7,
                      _S_scientific 	= 1L << 8,
                      _S_showbase 	= 1L << 9,
                      _S_showpoint 	= 1L << 10,
                      _S_showpos 	= 1L << 11,
                      _S_skipws 	= 1L << 12,
                      _S_unitbuf 	= 1L << 13,
                      _S_uppercase 	= 1L << 14,
                      _S_adjustfield 	= _S_left | _S_right | _S_internal,
                      _S_basefield 	= _S_dec | _S_oct | _S_hex,
                      _S_floatfield 	= _S_scientific | _S_fixed,
                      _S_ios_fmtflags_end = 1L << 16,
                      _S_ios_fmtflags_max = __INT_MAX__,
                      _S_ios_fmtflags_min = ~__INT_MAX__
                    };
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
                  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
         240 ->   { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
                  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
         120 ->   { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
                  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
                  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
                  operator~(_Ios_Fmtflags __a)
         120 ->   { return _Ios_Fmtflags(~static_cast<int>(__a)); }
                
                  inline const _Ios_Fmtflags&
                  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
         120 ->   { return __a = __a | __b; }
                
                  inline const _Ios_Fmtflags&
                  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
         120 ->   { return __a = __a & __b; }
                
                  inline const _Ios_Fmtflags&
                  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
                  { return __a = __a ^ __b; }
                
                
                  enum _Ios_Openmode 
                    { 
                      _S_app 		= 1L << 0,
                      _S_ate 		= 1L << 1,
                      _S_bin 		= 1L << 2,
                      _S_in 		= 1L << 3,
                      _S_out 		= 1L << 4,
                      _S_trunc 		= 1L << 5,
                      _S_ios_openmode_end = 1L << 16,
                      _S_ios_openmode_max = __INT_MAX__,
                      _S_ios_openmode_min = ~__INT_MAX__
                    };
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
                  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
                  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
                  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
                  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
                  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
                  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
                  operator~(_Ios_Openmode __a)
                  { return _Ios_Openmode(~static_cast<int>(__a)); }
                
                  inline const _Ios_Openmode&
                  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
                  { return __a = __a | __b; }
                
                  inline const _Ios_Openmode&
                  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
                  { return __a = __a & __b; }
                
                  inline const _Ios_Openmode&
                  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
                  { return __a = __a ^ __b; }
                
                
                  enum _Ios_Iostate
                    { 
                      _S_goodbit 		= 0,
                      _S_badbit 		= 1L << 0,
                      _S_eofbit 		= 1L << 1,
                      _S_failbit		= 1L << 2,
                      _S_ios_iostate_end = 1L << 16,
                      _S_ios_iostate_max = __INT_MAX__,
                      _S_ios_iostate_min = ~__INT_MAX__
                    };
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
                  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
                  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
                  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
                  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
                  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
                  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }
                
                  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
                  operator~(_Ios_Iostate __a)
                  { return _Ios_Iostate(~static_cast<int>(__a)); }
                
                  inline const _Ios_Iostate&
                  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
                  { return __a = __a | __b; }
                
                  inline const _Ios_Iostate&
                  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
                  { return __a = __a & __b; }
                
                  inline const  _Ios_Iostate&
                  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
                  { return __a = __a ^ __b; }
                
                
                  enum _Ios_Seekdir 
                    { 
                      _S_beg = 0,
                      _S_cur = _GLIBCXX_STDIO_SEEK_CUR,
                      _S_end = _GLIBCXX_STDIO_SEEK_END,
                      _S_ios_seekdir_end = 1L << 16 
                    };
                
                #if __cplusplus >= 201103L
                  /// I/O error code
                  enum class io_errc { stream = 1 };
                
                  template <> struct is_error_code_enum<io_errc> : public true_type { };
                
                  const error_category& iostream_category() noexcept;
                
                  inline error_code
                  make_error_code(io_errc e) noexcept
                  { return error_code(static_cast<int>(e), iostream_category()); }
                
                  inline error_condition
                  make_error_condition(io_errc e) noexcept
                  { return error_condition(static_cast<int>(e), iostream_category()); }
                #endif
                
                  // 27.4.2  Class ios_base
                  /**
                   *  @brief  The base of the I/O class hierarchy.
                   *  @ingroup io
                   *
                   *  This class defines everything that can be defined about I/O that does
                   *  not depend on the type of characters being input or output.  Most
                   *  people will only see @c ios_base when they need to specify the full
                   *  name of the various I/O flags (e.g., the openmodes).
                  */
                  class ios_base
                  {
                #if _GLIBCXX_USE_CXX11_ABI
                #if __cplusplus < 201103L
                    // Type that is layout-compatible with std::system_error
                    struct system_error : std::runtime_error
                    {
                      // Type that is layout-compatible with std::error_code
                      struct error_code
                      {
                	error_code() { }
                      private:
                	int		_M_value;
                	const void*	_M_cat;
                      } _M_code;
                    };
                #endif
                #endif
                  public:
                
                    /** 
                     *  @brief These are thrown to indicate problems with io.
                     *  @ingroup exceptions
                     *
                     *  27.4.2.1.1  Class ios_base::failure
                     */
                #if _GLIBCXX_USE_CXX11_ABI
                    class _GLIBCXX_ABI_TAG_CXX11 failure : public system_error
                    {
                    public:
                      explicit
                      failure(const string& __str);
                
                #if __cplusplus >= 201103L
                      explicit
                      failure(const string&, const error_code&);
                
                      explicit
                      failure(const char*, const error_code& = io_errc::stream);
                #endif
                
                      virtual
                      ~failure() throw();
                
                      virtual const char*
                      what() const throw();
                    };
                #else
                    class failure : public exception
                    {
                    public:
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 48.  Use of non-existent exception constructor
                      explicit
                      failure(const string& __str) throw();
                
                      // This declaration is not useless:
                      // http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Vague-Linkage.html
                      virtual
                      ~failure() throw();
                
                      virtual const char*
                      what() const throw();
                
                    private:
                      string _M_msg;
                    };
                #endif
                
                    // 27.4.2.1.2  Type ios_base::fmtflags
                    /**
                     *  @brief This is a bitmask type.
                     *
                     *  @c @a _Ios_Fmtflags is implementation-defined, but it is valid to
                     *  perform bitwise operations on these values and expect the Right
                     *  Thing to happen.  Defined objects of type fmtflags are:
                     *  - boolalpha
                     *  - dec
                     *  - fixed
                     *  - hex
                     *  - internal
                     *  - left
                     *  - oct
                     *  - right
                     *  - scientific
                     *  - showbase
                     *  - showpoint
                     *  - showpos
                     *  - skipws
                     *  - unitbuf
                     *  - uppercase
                     *  - adjustfield
                     *  - basefield
                     *  - floatfield
                    */
                    typedef _Ios_Fmtflags fmtflags;
                
                    /// Insert/extract @c bool in alphabetic rather than numeric format.
                    static const fmtflags boolalpha =   _S_boolalpha;
                
                    /// Converts integer input or generates integer output in decimal base.
                    static const fmtflags dec =         _S_dec;
                
                    /// Generate floating-point output in fixed-point notation.
                    static const fmtflags fixed =       _S_fixed;
                
                    /// Converts integer input or generates integer output in hexadecimal base.
                    static const fmtflags hex =         _S_hex;
                
                    /// Adds fill characters at a designated internal point in certain
                    /// generated output, or identical to @c right if no such point is
                    /// designated.
                    static const fmtflags internal =    _S_internal;
                
                    /// Adds fill characters on the right (final positions) of certain
                    /// generated output.  (I.e., the thing you print is flush left.)
                    static const fmtflags left =        _S_left;
                
                    /// Converts integer input or generates integer output in octal base.
                    static const fmtflags oct =         _S_oct;
                
                    /// Adds fill characters on the left (initial positions) of certain
                    /// generated output.  (I.e., the thing you print is flush right.)
                    static const fmtflags right =       _S_right;
                
                    /// Generates floating-point output in scientific notation.
                    static const fmtflags scientific =  _S_scientific;
                
                    /// Generates a prefix indicating the numeric base of generated integer
                    /// output.
                    static const fmtflags showbase =    _S_showbase;
                
                    /// Generates a decimal-point character unconditionally in generated
                    /// floating-point output.
                    static const fmtflags showpoint =   _S_showpoint;
                
                    /// Generates a + sign in non-negative generated numeric output.
                    static const fmtflags showpos =     _S_showpos;
                
                    /// Skips leading white space before certain input operations.
                    static const fmtflags skipws =      _S_skipws;
                
                    /// Flushes output after each output operation.
                    static const fmtflags unitbuf =     _S_unitbuf;
                
                    /// Replaces certain lowercase letters with their uppercase equivalents
                    /// in generated output.
                    static const fmtflags uppercase =   _S_uppercase;
                
                    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.
                    static const fmtflags adjustfield = _S_adjustfield;
                
                    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.
                    static const fmtflags basefield =   _S_basefield;
                
                    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.
                    static const fmtflags floatfield =  _S_floatfield;
                
                    // 27.4.2.1.3  Type ios_base::iostate
                    /**
                     *  @brief This is a bitmask type.
                     *
                     *  @c @a _Ios_Iostate is implementation-defined, but it is valid to
                     *  perform bitwise operations on these values and expect the Right
                     *  Thing to happen.  Defined objects of type iostate are:
                     *  - badbit
                     *  - eofbit
                     *  - failbit
                     *  - goodbit
                    */
                    typedef _Ios_Iostate iostate;
                
                    /// Indicates a loss of integrity in an input or output sequence (such
                    /// as an irrecoverable read error from a file).
                    static const iostate badbit =	_S_badbit;
                
                    /// Indicates that an input operation reached the end of an input sequence.
                    static const iostate eofbit =	_S_eofbit;
                
                    /// Indicates that an input operation failed to read the expected
                    /// characters, or that an output operation failed to generate the
                    /// desired characters.
                    static const iostate failbit =	_S_failbit;
                
                    /// Indicates all is well.
                    static const iostate goodbit =	_S_goodbit;
                
                    // 27.4.2.1.4  Type ios_base::openmode
                    /**
                     *  @brief This is a bitmask type.
                     *
                     *  @c @a _Ios_Openmode is implementation-defined, but it is valid to
                     *  perform bitwise operations on these values and expect the Right
                     *  Thing to happen.  Defined objects of type openmode are:
                     *  - app
                     *  - ate
                     *  - binary
                     *  - in
                     *  - out
                     *  - trunc
                    */
                    typedef _Ios_Openmode openmode;
                
                    /// Seek to end before each write.
                    static const openmode app =		_S_app;
                
                    /// Open and seek to end immediately after opening.
                    static const openmode ate =		_S_ate;
                
                    /// Perform input and output in binary mode (as opposed to text mode).
                    /// This is probably not what you think it is; see
                    /// https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary
                    static const openmode binary =	_S_bin;
                
                    /// Open for input.  Default for @c ifstream and fstream.
                    static const openmode in =		_S_in;
                
                    /// Open for output.  Default for @c ofstream and fstream.
                    static const openmode out =		_S_out;
                
                    /// Open for input.  Default for @c ofstream.
                    static const openmode trunc =	_S_trunc;
                
                    // 27.4.2.1.5  Type ios_base::seekdir
                    /**
                     *  @brief This is an enumerated type.
                     *
                     *  @c @a _Ios_Seekdir is implementation-defined.  Defined values
                     *  of type seekdir are:
                     *  - beg
                     *  - cur, equivalent to @c SEEK_CUR in the C standard library.
                     *  - end, equivalent to @c SEEK_END in the C standard library.
                    */
                    typedef _Ios_Seekdir seekdir;
                
                    /// Request a seek relative to the beginning of the stream.
                    static const seekdir beg =		_S_beg;
                
                    /// Request a seek relative to the current position within the sequence.
                    static const seekdir cur =		_S_cur;
                
                    /// Request a seek relative to the current end of the sequence.
                    static const seekdir end =		_S_end;
                
                    // Annex D.6
                    typedef int io_state;
                    typedef int open_mode;
                    typedef int seek_dir;
                
                    typedef std::streampos streampos;
                    typedef std::streamoff streamoff;
                
                    // Callbacks;
                    /**
                     *  @brief  The set of events that may be passed to an event callback.
                     *
                     *  erase_event is used during ~ios() and copyfmt().  imbue_event is used
                     *  during imbue().  copyfmt_event is used during copyfmt().
                    */
                    enum event
                    {
                      erase_event,
                      imbue_event,
                      copyfmt_event
                    };
                
                    /**
                     *  @brief  The type of an event callback function.
                     *  @param  __e  One of the members of the event enum.
                     *  @param  __b  Reference to the ios_base object.
                     *  @param  __i  The integer provided when the callback was registered.
                     *
                     *  Event callbacks are user defined functions that get called during
                     *  several ios_base and basic_ios functions, specifically imbue(),
                     *  copyfmt(), and ~ios().
                    */
                    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
                
                    /**
                     *  @brief  Add the callback __fn with parameter __index.
                     *  @param  __fn  The function to add.
                     *  @param  __index  The integer to pass to the function when invoked.
                     *
                     *  Registers a function as an event callback with an integer parameter to
                     *  be passed to the function when invoked.  Multiple copies of the
                     *  function are allowed.  If there are multiple callbacks, they are
                     *  invoked in the order they were registered.
                    */
                    void
                    register_callback(event_callback __fn, int __index);
                
                  protected:
                    streamsize		_M_precision;
                    streamsize		_M_width;
                    fmtflags		_M_flags;
                    iostate		_M_exception;
                    iostate		_M_streambuf_state;
                
                    // 27.4.2.6  Members for callbacks
                    // 27.4.2.6  ios_base callbacks
                    struct _Callback_list
                    {
                      // Data Members
                      _Callback_list*		_M_next;
                      ios_base::event_callback	_M_fn;
                      int			_M_index;
                      _Atomic_word		_M_refcount;  // 0 means one reference.
                
                      _Callback_list(ios_base::event_callback __fn, int __index,
                		     _Callback_list* __cb)
                      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }
                
                      void
                      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
                
                      // 0 => OK to delete.
                      int
                      _M_remove_reference() 
                      {
                        // Be race-detector-friendly.  For more info see bits/c++config.
                        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);
                        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
                        if (__res == 0)
                          {
                            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);
                          }
                        return __res;
                      }
                    };
                
                     _Callback_list*	_M_callbacks;
                
                    void
                    _M_call_callbacks(event __ev) throw();
                
                    void
                    _M_dispose_callbacks(void) throw();
                
                    // 27.4.2.5  Members for iword/pword storage
                    struct _Words
                    {
                      void*	_M_pword;
                      long	_M_iword;
                      _Words() : _M_pword(0), _M_iword(0) { }
                    };
                
                    // Only for failed iword/pword calls.
                    _Words		_M_word_zero;
                
                    // Guaranteed storage.
                    // The first 5 iword and pword slots are reserved for internal use.
                    enum { _S_local_word_size = 8 };
                    _Words		_M_local_word[_S_local_word_size];
                
                    // Allocated storage.
                    int			_M_word_size;
                    _Words*		_M_word;
                
                    _Words&
                    _M_grow_words(int __index, bool __iword);
                
                    // Members for locale and locale caching.
                    locale		_M_ios_locale;
                
                    void
                    _M_init() throw();
                
                  public:
                
                    // 27.4.2.1.6  Class ios_base::Init
                    // Used to initialize standard streams. In theory, g++ could use
                    // -finit-priority to order this stuff correctly without going
                    // through these machinations.
                    class Init
                    {
                      friend class ios_base;
                    public:
                      Init();
                      ~Init();
                
                    private:
                      static _Atomic_word	_S_refcount;
                      static bool		_S_synced_with_stdio;
                    };
                
                    // [27.4.2.2] fmtflags state functions
                    /**
                     *  @brief  Access to format flags.
                     *  @return  The format control flags for both input and output.
                    */
                    fmtflags
                    flags() const
                    { return _M_flags; }
                
                    /**
                     *  @brief  Setting new format flags all at once.
                     *  @param  __fmtfl  The new flags to set.
                     *  @return  The previous format control flags.
                     *
                     *  This function overwrites all the format flags with @a __fmtfl.
                    */
                    fmtflags
                    flags(fmtflags __fmtfl)
                    {
                      fmtflags __old = _M_flags;
                      _M_flags = __fmtfl;
                      return __old;
                    }
                
                    /**
                     *  @brief  Setting new format flags.
                     *  @param  __fmtfl  Additional flags to set.
                     *  @return  The previous format control flags.
                     *
                     *  This function sets additional flags in format control.  Flags that
                     *  were previously set remain set.
                    */
                    fmtflags
                    setf(fmtflags __fmtfl)
                    {
                      fmtflags __old = _M_flags;
                      _M_flags |= __fmtfl;
                      return __old;
                    }
                
                    /**
                     *  @brief  Setting new format flags.
                     *  @param  __fmtfl  Additional flags to set.
                     *  @param  __mask  The flags mask for @a fmtfl.
                     *  @return  The previous format control flags.
                     *
                     *  This function clears @a mask in the format flags, then sets
                     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.
                    */
                    fmtflags
         120 ->     setf(fmtflags __fmtfl, fmtflags __mask)
                    {
                      fmtflags __old = _M_flags;
                      _M_flags &= ~__mask;
                      _M_flags |= (__fmtfl & __mask);
                      return __old;
                    }
                
                    /**
                     *  @brief  Clearing format flags.
                     *  @param  __mask  The flags to unset.
                     *
                     *  This function clears @a __mask in the format flags.
                    */
                    void
                    unsetf(fmtflags __mask)
                    { _M_flags &= ~__mask; }
                
                    /**
                     *  @brief  Flags access.
                     *  @return  The precision to generate on certain output operations.
                     *
                     *  Be careful if you try to give a definition of @a precision here; see
                     *  DR 189.
                    */
                    streamsize
                    precision() const
                    { return _M_precision; }
                
                    /**
                     *  @brief  Changing flags.
                     *  @param  __prec  The new precision value.
                     *  @return  The previous value of precision().
                    */
                    streamsize
                    precision(streamsize __prec)
                    {
                      streamsize __old = _M_precision;
                      _M_precision = __prec;
                      return __old;
                    }
                
                    /**
                     *  @brief  Flags access.
                     *  @return  The minimum field width to generate on output operations.
                     *
                     *  <em>Minimum field width</em> refers to the number of characters.
                    */
                    streamsize
                    width() const
                    { return _M_width; }
                
                    /**
                     *  @brief  Changing flags.
                     *  @param  __wide  The new width value.
                     *  @return  The previous value of width().
                    */
                    streamsize
                    width(streamsize __wide)
                    {
                      streamsize __old = _M_width;
                      _M_width = __wide;
                      return __old;
                    }
                
                    // [27.4.2.4] ios_base static members
                    /**
                     *  @brief  Interaction with the standard C I/O objects.
                     *  @param  __sync  Whether to synchronize or not.
                     *  @return  True if the standard streams were previously synchronized.
                     *
                     *  The synchronization referred to is @e only that between the standard
                     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,
                     *  cout).  User-declared streams are unaffected.  See
                     *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary
                    */
                    static bool
                    sync_with_stdio(bool __sync = true);
                
                    // [27.4.2.3] ios_base locale functions
                    /**
                     *  @brief  Setting a new locale.
                     *  @param  __loc  The new locale.
                     *  @return  The previous locale.
                     *
                     *  Sets the new locale for this stream, and then invokes each callback
                     *  with imbue_event.
                    */
                    locale
                    imbue(const locale& __loc) throw();
                
                    /**
                     *  @brief  Locale access
                     *  @return  A copy of the current locale.
                     *
                     *  If @c imbue(loc) has previously been called, then this function
                     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),
                     *  the global C++ locale.
                    */
                    locale
                    getloc() const
                    { return _M_ios_locale; }
                
                    /**
                     *  @brief  Locale access
                     *  @return  A reference to the current locale.
                     *
                     *  Like getloc above, but returns a reference instead of
                     *  generating a copy.
                    */
                    const locale&
                    _M_getloc() const
                    { return _M_ios_locale; }
                
                    // [27.4.2.5] ios_base storage functions
                    /**
                     *  @brief  Access to unique indices.
                     *  @return  An integer different from all previous calls.
                     *
                     *  This function returns a unique integer every time it is called.  It
                     *  can be used for any purpose, but is primarily intended to be a unique
                     *  index for the iword and pword functions.  The expectation is that an
                     *  application calls xalloc in order to obtain an index in the iword and
                     *  pword arrays that can be used without fear of conflict.
                     *
                     *  The implementation maintains a static variable that is incremented and
                     *  returned on each invocation.  xalloc is guaranteed to return an index
                     *  that is safe to use in the iword and pword arrays.
                    */
                    static int
                    xalloc() throw();
                
                    /**
                     *  @brief  Access to integer array.
                     *  @param  __ix  Index into the array.
                     *  @return  A reference to an integer associated with the index.
                     *
                     *  The iword function provides access to an array of integers that can be
                     *  used for any purpose.  The array grows as required to hold the
                     *  supplied index.  All integers in the array are initialized to 0.
                     *
                     *  The implementation reserves several indices.  You should use xalloc to
                     *  obtain an index that is safe to use.  Also note that since the array
                     *  can grow dynamically, it is not safe to hold onto the reference.
                    */
                    long&
                    iword(int __ix)
                    {
                      _Words& __word = (__ix < _M_word_size)
                			? _M_word[__ix] : _M_grow_words(__ix, true);
                      return __word._M_iword;
                    }
                
                    /**
                     *  @brief  Access to void pointer array.
                     *  @param  __ix  Index into the array.
                     *  @return  A reference to a void* associated with the index.
                     *
                     *  The pword function provides access to an array of pointers that can be
                     *  used for any purpose.  The array grows as required to hold the
                     *  supplied index.  All pointers in the array are initialized to 0.
                     *
                     *  The implementation reserves several indices.  You should use xalloc to
                     *  obtain an index that is safe to use.  Also note that since the array
                     *  can grow dynamically, it is not safe to hold onto the reference.
                    */
                    void*&
                    pword(int __ix)
                    {
                      _Words& __word = (__ix < _M_word_size)
                			? _M_word[__ix] : _M_grow_words(__ix, false);
                      return __word._M_pword;
                    }
                
                    // Destructor
                    /**
                     *  Invokes each callback with erase_event.  Destroys local storage.
                     *
                     *  Note that the ios_base object for the standard streams never gets
                     *  destroyed.  As a result, any callbacks registered with the standard
                     *  streams will not get invoked with erase_event (unless copyfmt is
                     *  used).
                    */
                    virtual ~ios_base();
                
                  protected:
                    ios_base() throw ();
                
                #if __cplusplus < 201103L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 50.  Copy constructor and assignment operator of ios_base
                  private:
                    ios_base(const ios_base&);
                
                    ios_base&
                    operator=(const ios_base&);
                #else
                  public:
                    ios_base(const ios_base&) = delete;
                
                    ios_base&
                    operator=(const ios_base&) = delete;
                
                  protected:
                    void
                    _M_move(ios_base&) noexcept;
                
                    void
                    _M_swap(ios_base& __rhs) noexcept;
                #endif
                  };
                
                  // [27.4.5.1] fmtflags manipulators
                  /// Calls base.setf(ios_base::boolalpha).
                  inline ios_base&
                  boolalpha(ios_base& __base)
                  {
                    __base.setf(ios_base::boolalpha);
                    return __base;
                  }
                
                  /// Calls base.unsetf(ios_base::boolalpha).
                  inline ios_base&
                  noboolalpha(ios_base& __base)
                  {
                    __base.unsetf(ios_base::boolalpha);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::showbase).
                  inline ios_base&
                  showbase(ios_base& __base)
                  {
                    __base.setf(ios_base::showbase);
                    return __base;
                  }
                
                  /// Calls base.unsetf(ios_base::showbase).
                  inline ios_base&
                  noshowbase(ios_base& __base)
                  {
                    __base.unsetf(ios_base::showbase);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::showpoint).
                  inline ios_base&
                  showpoint(ios_base& __base)
                  {
                    __base.setf(ios_base::showpoint);
                    return __base;
                  }
                
                  /// Calls base.unsetf(ios_base::showpoint).
                  inline ios_base&
                  noshowpoint(ios_base& __base)
                  {
                    __base.unsetf(ios_base::showpoint);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::showpos).
                  inline ios_base&
                  showpos(ios_base& __base)
                  {
                    __base.setf(ios_base::showpos);
                    return __base;
                  }
                
                  /// Calls base.unsetf(ios_base::showpos).
                  inline ios_base&
                  noshowpos(ios_base& __base)
                  {
                    __base.unsetf(ios_base::showpos);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::skipws).
                  inline ios_base&
                  skipws(ios_base& __base)
                  {
                    __base.setf(ios_base::skipws);
                    return __base;
                  }
                
                  /// Calls base.unsetf(ios_base::skipws).
                  inline ios_base&
                  noskipws(ios_base& __base)
                  {
                    __base.unsetf(ios_base::skipws);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::uppercase).
                  inline ios_base&
                  uppercase(ios_base& __base)
                  {
                    __base.setf(ios_base::uppercase);
                    return __base;
                  }
                
                  /// Calls base.unsetf(ios_base::uppercase).
                  inline ios_base&
                  nouppercase(ios_base& __base)
                  {
                    __base.unsetf(ios_base::uppercase);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::unitbuf).
                  inline ios_base&
                  unitbuf(ios_base& __base)
                  {
                     __base.setf(ios_base::unitbuf);
                     return __base;
                  }
                
                  /// Calls base.unsetf(ios_base::unitbuf).
                  inline ios_base&
                  nounitbuf(ios_base& __base)
                  {
                     __base.unsetf(ios_base::unitbuf);
                     return __base;
                  }
                
                  // [27.4.5.2] adjustfield manipulators
                  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).
                  inline ios_base&
                  internal(ios_base& __base)
                  {
                     __base.setf(ios_base::internal, ios_base::adjustfield);
                     return __base;
                  }
                
                  /// Calls base.setf(ios_base::left, ios_base::adjustfield).
                  inline ios_base&
                  left(ios_base& __base)
                  {
                    __base.setf(ios_base::left, ios_base::adjustfield);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::right, ios_base::adjustfield).
                  inline ios_base&
                  right(ios_base& __base)
                  {
                    __base.setf(ios_base::right, ios_base::adjustfield);
                    return __base;
                  }
                
                  // [27.4.5.3] basefield manipulators
                  /// Calls base.setf(ios_base::dec, ios_base::basefield).
                  inline ios_base&
                  dec(ios_base& __base)
                  {
                    __base.setf(ios_base::dec, ios_base::basefield);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::hex, ios_base::basefield).
                  inline ios_base&
                  hex(ios_base& __base)
                  {
                    __base.setf(ios_base::hex, ios_base::basefield);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::oct, ios_base::basefield).
                  inline ios_base&
                  oct(ios_base& __base)
                  {
                    __base.setf(ios_base::oct, ios_base::basefield);
                    return __base;
                  }
                
                  // [27.4.5.4] floatfield manipulators
                  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).
                  inline ios_base&
                  fixed(ios_base& __base)
       ##### ->   {
                    __base.setf(ios_base::fixed, ios_base::floatfield);
                    return __base;
                  }
                
                  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).
                  inline ios_base&
                  scientific(ios_base& __base)
                  {
                    __base.setf(ios_base::scientific, ios_base::floatfield);
                    return __base;
                  }
                
                #if __cplusplus >= 201103L
                  // New C++11 floatfield manipulators
                
                  /// Calls
                  /// base.setf(ios_base::fixed|ios_base::scientific, ios_base::floatfield)
                  inline ios_base&
                  hexfloat(ios_base& __base)
                  {
                    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
                    return __base;
                  }
                
                  /// Calls @c base.unsetf(ios_base::floatfield)
                  inline ios_base&
                  defaultfloat(ios_base& __base)
                  {
                    __base.unsetf(ios_base::floatfield);
                    return __base;
                  }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _IOS_BASE_H */


Top 10 Lines:

     Line      Count

       84        240
       88        120
       96        120
      100        120
      104        120
      663        120

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

      840   Total number of line executions
   120.00   Average executions per line


*** File /home/sbillah/dmclock/sim/sim_recs.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                
                #include <stdint.h>
                #include <stdlib.h>
                #include <assert.h>
                #include <signal.h>
                
                #include <sys/time.h>
                
                #include <cmath>
                #include <limits>
                #include <string>
                #include <mutex>
                #include <iostream>
                
                
                using ClientId = uint;
                using ServerId = uint;
                
                
                namespace crimson {
                  namespace qos_simulation {
                
                    inline void debugger() {
                      raise(SIGCONT);
                    }
                
                    template<typename T>
        7130 ->     void time_stats(std::mutex& mtx,
                		    T& time_accumulate,
                		    std::function<void()> code) {
                      auto t1 = std::chrono::steady_clock::now();
                      code();
                      auto t2 = std::chrono::steady_clock::now();
                      auto duration = t2 - t1;
                      auto cast_duration = std::chrono::duration_cast<T>(duration);
                      std::lock_guard<std::mutex> lock(mtx);
                      time_accumulate += cast_duration;
                    }
                
                    // unfortunately it's hard for the compiler to infer the types,
                    // and therefore when called the template params might have to be
                    // explicit
                    template<typename T, typename R>
        1821 ->     R time_stats_w_return(std::mutex& mtx,
                			  T& time_accumulate,
                			  std::function<R()> code) {
                      auto t1 = std::chrono::steady_clock::now();
                      R result = code();
                      auto t2 = std::chrono::steady_clock::now();
                      auto duration = t2 - t1;
                      auto cast_duration = std::chrono::duration_cast<T>(duration);
                      std::lock_guard<std::mutex> lock(mtx);
                      time_accumulate += cast_duration;
                      return result;
                    }
                
                    template<typename T>
        9773 ->     void count_stats(std::mutex& mtx,
                		     T& counter) {
                      std::lock_guard<std::mutex> lock(mtx);
                      ++counter;
                    }
                
                    struct TestRequest {
                      ServerId server; // allows debugging
                      uint32_t epoch;
                      uint32_t op;
                
        3985 ->       TestRequest(ServerId _server,
                		  uint32_t _epoch,
                		  uint32_t _op) :
                	server(_server),
                	epoch(_epoch),
                	op(_op)
                      {
                	// empty
                      }
                
        2095 ->       TestRequest(const TestRequest& r) :
                	TestRequest(r.server, r.epoch, r.op)
                      {
                	// empty
                      }
                    }; // struct TestRequest
                
                
                    struct TestResponse {
                      uint32_t epoch;
                
        3418 ->       TestResponse(uint32_t _epoch) :
                	epoch(_epoch)
                      {
                	// empty
                      }
                
        8451 ->       TestResponse(const TestResponse& r) :
                	epoch(r.epoch)
                      {
                	// empty
                      }
                
                      friend std::ostream& operator<<(std::ostream& out, const TestResponse& resp) {
                	out << "{ ";
                	out << "epoch:" << resp.epoch;
                	out << " }";
                	return out;
                      }
                    }; // class TestResponse
                
                  }; // namespace qos_simulation
                }; // namespace crimson


Top 10 Lines:

     Line      Count

       68       9773
      106       8451
       38       7130
       79       3985
      100       3418
       89       2095
       54       1821

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

    36673   Total number of line executions
  5239.00   Average executions per line


*** File /home/sbillah/dmclock/sim/../support/src/run_every.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                #include <chrono>
                #include <mutex>
                #include <condition_variable>
                #include <thread>
                
                
                namespace crimson {
                  using std::chrono::duration_cast;
                  using std::chrono::milliseconds;
                
                  // runs a given simple function object waiting wait_period
                  // milliseconds between; the destructor stops the other thread
                  // immediately
                  class RunEvery {
                    using Lock      = std::unique_lock<std::mutex>;
                    using Guard     = std::lock_guard<std::mutex>;
                    using TimePoint = std::chrono::steady_clock::time_point;
                
                    bool                      finishing = false;
                    std::chrono::milliseconds wait_period;
                    std::function<void()>     body;
                    std::mutex                mtx;
                    std::condition_variable   cv;
                
                    // put threads last so all other variables are initialized first
                
                    std::thread               thd;
                
                  public:
                
                #ifdef ADD_MOVE_SEMANTICS
                    RunEvery();
                #endif
                
                    template<typename D>
         105 ->     RunEvery(D                     _wait_period,
                	     std::function<void()> _body) :
                      wait_period(duration_cast<milliseconds>(_wait_period)),
                      body(_body)
                    {
                      thd = std::thread(&RunEvery::run, this);
                    }
                
                    RunEvery(const RunEvery& other) = delete;
                    RunEvery& operator=(const RunEvery& other) = delete;
                    RunEvery(RunEvery&& other) = delete;
                #ifdef ADD_MOVE_SEMANTICS
                    RunEvery& operator=(RunEvery&& other);
                #else
                    RunEvery& operator=(RunEvery&& other) = delete;
                #endif
                
                    ~RunEvery();
                
                  protected:
                
                    void run();
                  };
                }


Top 10 Lines:

     Line      Count

       45        105

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      105   Total number of line executions
   105.00   Average executions per line


*** File /usr/include/c++/5/bits/unique_ptr.h:
                // unique_ptr implementation -*- C++ -*-
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/unique_ptr.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _UNIQUE_PTR_H
                #define _UNIQUE_PTR_H 1
                
                #include <bits/c++config.h>
                #include <debug/debug.h>
                #include <type_traits>
                #include <utility>
                #include <tuple>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup pointer_abstractions
                   * @{
                   */
                
                #if _GLIBCXX_USE_DEPRECATED
                  template<typename> class auto_ptr;
                #endif
                
                  /// Primary template of default_delete, used by unique_ptr
                  template<typename _Tp>
                    struct default_delete
                    {
                      /// Default constructor
         106 ->       constexpr default_delete() noexcept = default;
                
                      /** @brief Converting constructor.
                       *
                       * Allows conversion from a deleter for arrays of another type, @p _Up,
                       * only if @p _Up* is convertible to @p _Tp*.
                       */
                      template<typename _Up, typename = typename
                	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
                        default_delete(const default_delete<_Up>&) noexcept { }
                
                      /// Calls @c delete @p __ptr
                      void
        2157 ->       operator()(_Tp* __ptr) const
                      {
                	static_assert(!is_void<_Tp>::value,
                		      "can't delete pointer to incomplete type");
                	static_assert(sizeof(_Tp)>0,
                		      "can't delete pointer to incomplete type");
                	delete __ptr;
                      }
                    };
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 740 - omit specialization for array objects with a compile time length
                  /// Specialization for arrays, default_delete.
                  template<typename _Tp>
                    struct default_delete<_Tp[]>
                    {
                    private:
                      template<typename _Up>
                	using __remove_cv = typename remove_cv<_Up>::type;
                
                      // Like is_base_of<_Tp, _Up> but false if unqualified types are the same
                      template<typename _Up>
                	using __is_derived_Tp
                	  = __and_< is_base_of<_Tp, _Up>,
                		    __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;
                
                    public:
                      /// Default constructor
                      constexpr default_delete() noexcept = default;
                
                      /** @brief Converting constructor.
                       *
                       * Allows conversion from a deleter for arrays of another type, such as
                       * a const-qualified version of @p _Tp.
                       *
                       * Conversions from types derived from @c _Tp are not allowed because
                       * it is unsafe to @c delete[] an array of derived types through a
                       * pointer to the base type.
                       */
                      template<typename _Up, typename = typename
                	       enable_if<!__is_derived_Tp<_Up>::value>::type>
                        default_delete(const default_delete<_Up[]>&) noexcept { }
                
                      /// Calls @c delete[] @p __ptr
                      void
                      operator()(_Tp* __ptr) const
                      {
                	static_assert(sizeof(_Tp)>0,
                		      "can't delete pointer to incomplete type");
                	delete [] __ptr;
                      }
                
                      template<typename _Up>
                	typename enable_if<__is_derived_Tp<_Up>::value>::type
                	operator()(_Up*) const = delete;
                    };
                
                  /// 20.7.1.2 unique_ptr for single objects.
                  template <typename _Tp, typename _Dp = default_delete<_Tp> >
                    class unique_ptr
                    {
                      // use SFINAE to determine whether _Del::pointer exists
                      class _Pointer
                      {
                	template<typename _Up>
                	  static typename _Up::pointer __test(typename _Up::pointer*);
                
                	template<typename _Up>
                	  static _Tp* __test(...);
                
                	typedef typename remove_reference<_Dp>::type _Del;
                
                      public:
                	typedef decltype(__test<_Del>(0)) type;
                      };
                
                      typedef std::tuple<typename _Pointer::type, _Dp>  __tuple_type;
                      __tuple_type                                      _M_t;
                
                    public:
                      typedef typename _Pointer::type   pointer;
                      typedef _Tp                       element_type;
                      typedef _Dp                       deleter_type;
                
                      // Constructors.
                
                      /// Default constructor, creates a unique_ptr that owns nothing.
         104 ->       constexpr unique_ptr() noexcept
                      : _M_t()
                      { static_assert(!is_pointer<deleter_type>::value,
                		     "constructed with null function pointer deleter"); }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an object of @c element_type
                       *
                       * The deleter will be value-initialized.
                       */
                      explicit
        2023 ->       unique_ptr(pointer __p) noexcept
                      : _M_t(__p, deleter_type())
                      { static_assert(!is_pointer<deleter_type>::value,
                		     "constructed with null function pointer deleter"); }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an object of @c element_type
                       * @param __d  A reference to a deleter.
                       *
                       * The deleter will be initialized with @p __d
                       */
                      unique_ptr(pointer __p,
                	  typename conditional<is_reference<deleter_type>::value,
                	    deleter_type, const deleter_type&>::type __d) noexcept
                      : _M_t(__p, __d) { }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an object of @c element_type
                       * @param __d  An rvalue reference to a deleter.
                       *
                       * The deleter will be initialized with @p std::move(__d)
                       */
                      unique_ptr(pointer __p,
                	  typename remove_reference<deleter_type>::type&& __d) noexcept
                      : _M_t(std::move(__p), std::move(__d))
                      { static_assert(!std::is_reference<deleter_type>::value,
                		      "rvalue deleter bound to reference"); }
                
                      /// Creates a unique_ptr that owns nothing.
                      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }
                
                      // Move constructors.
                
                      /// Move constructor.
       20618 ->       unique_ptr(unique_ptr&& __u) noexcept
                      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
                
                      /** @brief Converting constructor from another type
                       *
                       * Requires that the pointer owned by @p __u is convertible to the
                       * type of pointer owned by this object, @p __u does not own an array,
                       * and @p __u has a compatible deleter type.
                       */
                      template<typename _Up, typename _Ep, typename = _Require<
                	       is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                	       __not_<is_array<_Up>>,
                	       typename conditional<is_reference<_Dp>::value,
                				    is_same<_Ep, _Dp>,
                				    is_convertible<_Ep, _Dp>>::type>>
                	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
                	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
                	{ }
                
                #if _GLIBCXX_USE_DEPRECATED
                      /// Converting constructor from @c auto_ptr
                      template<typename _Up, typename = _Require<
                	       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
                	unique_ptr(auto_ptr<_Up>&& __u) noexcept;
                #endif
                
                      /// Destructor, invokes the deleter if the stored pointer is not null.
       27620 ->       ~unique_ptr() noexcept
                      {
                	auto& __ptr = std::get<0>(_M_t);
                	if (__ptr != nullptr)
                	  get_deleter()(__ptr);
                	__ptr = pointer();
                      }
                
                      // Assignment.
                
                      /** @brief Move assignment operator.
                       *
                       * @param __u  The object to transfer ownership from.
                       *
                       * Invokes the deleter first if this object owns a pointer.
                       */
                      unique_ptr&
         108 ->       operator=(unique_ptr&& __u) noexcept
                      {
                	reset(__u.release());
                	get_deleter() = std::forward<deleter_type>(__u.get_deleter());
                	return *this;
                      }
                
                      /** @brief Assignment from another type.
                       *
                       * @param __u  The object to transfer ownership from, which owns a
                       *             convertible pointer to a non-array object.
                       *
                       * Invokes the deleter first if this object owns a pointer.
                       */
                      template<typename _Up, typename _Ep>
                	typename enable_if< __and_<
                	  is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                	  __not_<is_array<_Up>>
                	  >::value,
                	  unique_ptr&>::type
                	operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
                	{
                	  reset(__u.release());
                	  get_deleter() = std::forward<_Ep>(__u.get_deleter());
                	  return *this;
                	}
                
                      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
                      unique_ptr&
                      operator=(nullptr_t) noexcept
                      {
                	reset();
                	return *this;
                      }
                
                      // Observers.
                
                      /// Dereference the stored pointer.
                      typename add_lvalue_reference<element_type>::type
                      operator*() const
                      {
                	_GLIBCXX_DEBUG_ASSERT(get() != pointer());
                	return *get();
                      }
                
                      /// Return the stored pointer.
                      pointer
        3816 ->       operator->() const noexcept
                      {
                	_GLIBCXX_DEBUG_ASSERT(get() != pointer());
                	return get();
                      }
                
                      /// Return the stored pointer.
                      pointer
       24558 ->       get() const noexcept
                      { return std::get<0>(_M_t); }
                
                      /// Return a reference to the stored deleter.
                      deleter_type&
       23383 ->       get_deleter() noexcept
                      { return std::get<1>(_M_t); }
                
                      /// Return a reference to the stored deleter.
                      const deleter_type&
                      get_deleter() const noexcept
                      { return std::get<1>(_M_t); }
                
                      /// Return @c true if the stored pointer is not null.
                      explicit operator bool() const noexcept
                      { return get() == pointer() ? false : true; }
                
                      // Modifiers.
                
                      /// Release ownership of any stored pointer.
                      pointer
       20434 ->       release() noexcept
                      {
                	pointer __p = get();
                	std::get<0>(_M_t) = pointer();
                	return __p;
                      }
                
                      /** @brief Replace the stored pointer.
                       *
                       * @param __p  The new pointer to store.
                       *
                       * The deleter will be invoked if a pointer is already owned.
                       */
                      void
         108 ->       reset(pointer __p = pointer()) noexcept
                      {
                	using std::swap;
                	swap(std::get<0>(_M_t), __p);
                	if (__p != pointer())
                	  get_deleter()(__p);
                      }
                
                      /// Exchange the pointer and deleter with another object.
                      void
                      swap(unique_ptr& __u) noexcept
                      {
                	using std::swap;
                	swap(_M_t, __u._M_t);
                      }
                
                      // Disable copy from lvalue.
                      unique_ptr(const unique_ptr&) = delete;
                      unique_ptr& operator=(const unique_ptr&) = delete;
                  };
                
                  /// 20.7.1.3 unique_ptr for array objects with a runtime length
                  // [unique.ptr.runtime]
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 740 - omit specialization for array objects with a compile time length
                  template<typename _Tp, typename _Dp>
                    class unique_ptr<_Tp[], _Dp>
                    {
                      // use SFINAE to determine whether _Del::pointer exists
                      class _Pointer
                      {
                	template<typename _Up>
                	  static typename _Up::pointer __test(typename _Up::pointer*);
                
                	template<typename _Up>
                	  static _Tp* __test(...);
                
                	typedef typename remove_reference<_Dp>::type _Del;
                
                      public:
                	typedef decltype(__test<_Del>(0)) type;
                      };
                
                      typedef std::tuple<typename _Pointer::type, _Dp>  __tuple_type;
                      __tuple_type                                      _M_t;
                
                      template<typename _Up>
                	using __remove_cv = typename remove_cv<_Up>::type;
                
                      // like is_base_of<_Tp, _Up> but false if unqualified types are the same
                      template<typename _Up>
                	using __is_derived_Tp
                	  = __and_< is_base_of<_Tp, _Up>,
                		    __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;
                
                      template<typename _Up, typename _Ep,
                	       typename _Tp_pointer = typename _Pointer::type,
                	       typename _Up_pointer = typename unique_ptr<_Up, _Ep>::pointer>
                	using __safe_conversion = __and_<
                	    is_convertible<_Up_pointer, _Tp_pointer>,
                	    is_array<_Up>,
                	    __or_<__not_<is_pointer<_Up_pointer>>,
                		  __not_<is_pointer<_Tp_pointer>>,
                		  __not_<__is_derived_Tp<typename remove_extent<_Up>::type>>
                	    >
                	  >;
                
                    public:
                      typedef typename _Pointer::type	pointer;
                      typedef _Tp		 	element_type;
                      typedef _Dp                       deleter_type;
                
                      // Constructors.
                
                      /// Default constructor, creates a unique_ptr that owns nothing.
                      constexpr unique_ptr() noexcept
                      : _M_t()
                      { static_assert(!std::is_pointer<deleter_type>::value,
                		      "constructed with null function pointer deleter"); }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an array of @c element_type
                       *
                       * The deleter will be value-initialized.
                       */
                      explicit
                      unique_ptr(pointer __p) noexcept
                      : _M_t(__p, deleter_type())
                      { static_assert(!is_pointer<deleter_type>::value,
                		      "constructed with null function pointer deleter"); }
                
                      // Disable construction from convertible pointer types.
                      template<typename _Up, typename = _Require<is_pointer<pointer>,
                	       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
                	explicit
                	unique_ptr(_Up* __p) = delete;
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an array of @c element_type
                       * @param __d  A reference to a deleter.
                       *
                       * The deleter will be initialized with @p __d
                       */
                      unique_ptr(pointer __p,
                	  typename conditional<is_reference<deleter_type>::value,
                	      deleter_type, const deleter_type&>::type __d) noexcept
                      : _M_t(__p, __d) { }
                
                      /** Takes ownership of a pointer.
                       *
                       * @param __p  A pointer to an array of @c element_type
                       * @param __d  A reference to a deleter.
                       *
                       * The deleter will be initialized with @p std::move(__d)
                       */
                      unique_ptr(pointer __p, typename
                		 remove_reference<deleter_type>::type&& __d) noexcept
                      : _M_t(std::move(__p), std::move(__d))
                      { static_assert(!is_reference<deleter_type>::value,
                		      "rvalue deleter bound to reference"); }
                
                      /// Move constructor.
                      unique_ptr(unique_ptr&& __u) noexcept
                      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
                
                      /// Creates a unique_ptr that owns nothing.
                      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }
                
                      template<typename _Up, typename _Ep,
                	       typename = _Require<__safe_conversion<_Up, _Ep>,
                		 typename conditional<is_reference<_Dp>::value,
                				      is_same<_Ep, _Dp>,
                				      is_convertible<_Ep, _Dp>>::type
                	       >>
                	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
                	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
                	{ }
                
                      /// Destructor, invokes the deleter if the stored pointer is not null.
                      ~unique_ptr()
                      {
                	auto& __ptr = std::get<0>(_M_t);
                	if (__ptr != nullptr)
                	  get_deleter()(__ptr);
                	__ptr = pointer();
                      }
                
                      // Assignment.
                
                      /** @brief Move assignment operator.
                       *
                       * @param __u  The object to transfer ownership from.
                       *
                       * Invokes the deleter first if this object owns a pointer.
                       */
                      unique_ptr&
                      operator=(unique_ptr&& __u) noexcept
                      {
                	reset(__u.release());
                	get_deleter() = std::forward<deleter_type>(__u.get_deleter());
                	return *this;
                      }
                
                      /** @brief Assignment from another type.
                       *
                       * @param __u  The object to transfer ownership from, which owns a
                       *             convertible pointer to an array object.
                       *
                       * Invokes the deleter first if this object owns a pointer.
                       */
                      template<typename _Up, typename _Ep>
                	typename
                	enable_if<__safe_conversion<_Up, _Ep>::value, unique_ptr&>::type
                	operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
                	{
                	  reset(__u.release());
                	  get_deleter() = std::forward<_Ep>(__u.get_deleter());
                	  return *this;
                	}
                
                      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
                      unique_ptr&
                      operator=(nullptr_t) noexcept
                      {
                	reset();
                	return *this;
                      }
                
                      // Observers.
                
                      /// Access an element of owned array.
                      typename std::add_lvalue_reference<element_type>::type
                      operator[](size_t __i) const
                      {
                	_GLIBCXX_DEBUG_ASSERT(get() != pointer());
                	return get()[__i];
                      }
                
                      /// Return the stored pointer.
                      pointer
                      get() const noexcept
                      { return std::get<0>(_M_t); }
                
                      /// Return a reference to the stored deleter.
                      deleter_type&
                      get_deleter() noexcept
                      { return std::get<1>(_M_t); }
                
                      /// Return a reference to the stored deleter.
                      const deleter_type&
                      get_deleter() const noexcept
                      { return std::get<1>(_M_t); }
                
                      /// Return @c true if the stored pointer is not null.
                      explicit operator bool() const noexcept
                      { return get() == pointer() ? false : true; }
                
                      // Modifiers.
                
                      /// Release ownership of any stored pointer.
                      pointer
                      release() noexcept
                      {
                	pointer __p = get();
                	std::get<0>(_M_t) = pointer();
                	return __p;
                      }
                
                      /** @brief Replace the stored pointer.
                       *
                       * @param __p  The new pointer to store.
                       *
                       * The deleter will be invoked if a pointer is already owned.
                       */
                      void
                      reset(pointer __p = pointer()) noexcept
                      {
                	using std::swap;
                	swap(std::get<0>(_M_t), __p);
                	if (__p != nullptr)
                	  get_deleter()(__p);
                      }
                
                      // Disable resetting from convertible pointer types.
                      template<typename _Up, typename = _Require<is_pointer<pointer>,
                	       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
                	void reset(_Up*) = delete;
                
                      /// Exchange the pointer and deleter with another object.
                      void
                      swap(unique_ptr& __u) noexcept
                      {
                	using std::swap;
                	swap(_M_t, __u._M_t);
                      }
                
                      // Disable copy from lvalue.
                      unique_ptr(const unique_ptr&) = delete;
                      unique_ptr& operator=(const unique_ptr&) = delete;
                
                      // Disable construction from convertible pointer types.
                      template<typename _Up, typename = _Require<is_pointer<pointer>,
                	       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
                	unique_ptr(_Up*, typename
                		   conditional<is_reference<deleter_type>::value,
                		   deleter_type, const deleter_type&>::type) = delete;
                
                      // Disable construction from convertible pointer types.
                      template<typename _Up, typename = _Require<is_pointer<pointer>,
                	       is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
                	unique_ptr(_Up*, typename
                		   remove_reference<deleter_type>::type&&) = delete;
                    };
                
                  template<typename _Tp, typename _Dp>
                    inline void
                    swap(unique_ptr<_Tp, _Dp>& __x,
                	 unique_ptr<_Tp, _Dp>& __y) noexcept
                    { __x.swap(__y); }
                
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    inline bool
                    operator==(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return __x.get() == __y.get(); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
                    { return !__x; }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
                    { return !__x; }
                
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    inline bool
                    operator!=(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return __x.get() != __y.get(); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
                    { return (bool)__x; }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
                    { return (bool)__x; }
                
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    inline bool
                    operator<(const unique_ptr<_Tp, _Dp>& __x,
                	      const unique_ptr<_Up, _Ep>& __y)
                    {
                      typedef typename
                	std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                	                 typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
                      return std::less<_CT>()(__x.get(), __y.get());
                    }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
                								 nullptr); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
                								 __x.get()); }
                
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    inline bool
                    operator<=(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    { return !(nullptr < __x); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    { return !(__x < nullptr); }
                
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    inline bool
                    operator>(const unique_ptr<_Tp, _Dp>& __x,
                	      const unique_ptr<_Up, _Ep>& __y)
                    { return (__y < __x); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
                								 __x.get()); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
                								 nullptr); }
                
                  template<typename _Tp, typename _Dp,
                	   typename _Up, typename _Ep>
                    inline bool
                    operator>=(const unique_ptr<_Tp, _Dp>& __x,
                	       const unique_ptr<_Up, _Ep>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
                    { return !(__x < nullptr); }
                
                  template<typename _Tp, typename _Dp>
                    inline bool
                    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
                    { return !(nullptr < __x); }
                
                  /// std::hash specialization for unique_ptr.
                  template<typename _Tp, typename _Dp>
                    struct hash<unique_ptr<_Tp, _Dp>>
                    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
                    {
                      size_t
                      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
                      {
                	typedef unique_ptr<_Tp, _Dp> _UP;
                	return std::hash<typename _UP::pointer>()(__u.get());
                      }
                    };
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_make_unique 201304
                
                  template<typename _Tp>
                    struct _MakeUniq
                    { typedef unique_ptr<_Tp> __single_object; };
                
                  template<typename _Tp>
                    struct _MakeUniq<_Tp[]>
                    { typedef unique_ptr<_Tp[]> __array; };
                
                  template<typename _Tp, size_t _Bound>
                    struct _MakeUniq<_Tp[_Bound]>
                    { struct __invalid_type { }; };
                
                  /// std::make_unique for single objects
                  template<typename _Tp, typename... _Args>
                    inline typename _MakeUniq<_Tp>::__single_object
                    make_unique(_Args&&... __args)
                    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
                
                  /// std::make_unique for arrays of unknown bound
                  template<typename _Tp>
                    inline typename _MakeUniq<_Tp>::__array
                    make_unique(size_t __num)
                    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }
                
                  /// Disable std::make_unique for arrays of known bound
                  template<typename _Tp, typename... _Args>
                    inline typename _MakeUniq<_Tp>::__invalid_type
                    make_unique(_Args&&...) = delete;
                #endif
                
                  // @} group pointer_abstractions
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _UNIQUE_PTR_H */


Top 10 Lines:

     Line      Count

      232      27620
      304      24558
      309      23383
      205      20618
      325      20434
      296       3816
       70       2157
      169       2023
      249        108
      339        108

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

   125035   Total number of line executions
 10419.58   Average executions per line


*** File /usr/include/c++/5/bits/basic_string.h:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21 Strings library
                //
                
                #ifndef _BASIC_STRING_H
                #define _BASIC_STRING_H 1
                
                #pragma GCC system_header
                
                #include <ext/atomicity.h>
                #include <ext/alloc_traits.h>
                #include <debug/debug.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if _GLIBCXX_USE_CXX11_ABI
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_CharT>::other _Char_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
                
                      // Types:
                    public:
                      typedef _Traits					traits_type;
                      typedef typename _Traits::char_type		value_type;
                      typedef _Char_alloc_type				allocator_type;
                      typedef typename _Alloc_traits::size_type		size_type;
                      typedef typename _Alloc_traits::difference_type	difference_type;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef typename _Alloc_traits::pointer		pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                							const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // type used for positions in insert, erase etc.
                #if __cplusplus < 201103L
                      typedef iterator __const_iterator;
                #else
                      typedef const_iterator __const_iterator;
                #endif
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
       ##### ->       struct _Alloc_hider : allocator_type // TODO check __is_final
                      {
                	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
                	: allocator_type(__a), _M_p(__dat) { }
                
                	pointer _M_p; // The actual data.
                      };
                
                      _Alloc_hider	_M_dataplus;
                      size_type		_M_string_length;
                
                      enum { _S_local_capacity = 15 / sizeof(_CharT) };
                
                      union
                      {
                	_CharT           _M_local_buf[_S_local_capacity + 1];
                	size_type        _M_allocated_capacity;
                      };
                
                      void
                      _M_data(pointer __p)
                      { _M_dataplus._M_p = __p; }
                
                      void
                      _M_length(size_type __length)
                      { _M_string_length = __length; }
                
                      pointer
                      _M_data() const
                      { return _M_dataplus._M_p; }
                
                      pointer
                      _M_local_data()
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
                #else
                	return pointer(_M_local_buf);
                #endif
                      }
                
                      const_pointer
                      _M_local_data() const
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
                #else
                	return const_pointer(_M_local_buf);
                #endif
                      }
                
                      void
                      _M_capacity(size_type __capacity)
                      { _M_allocated_capacity = __capacity; }
                
                      void
                      _M_set_length(size_type __n)
                      {
                	_M_length(__n);
                	traits_type::assign(_M_data()[__n], _CharT());
                      }
                
                      bool
                      _M_is_local() const
                      { return _M_data() == _M_local_data(); }
                
                      // Create & Destroy
                      pointer
                      _M_create(size_type&, size_type);
                
                      void
                      _M_dispose()
                      {
                	if (!_M_is_local())
                	  _M_destroy(_M_allocated_capacity);
                      }
                
                      void
                      _M_destroy(size_type __size) throw()
                      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
                
                      // _M_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIterator is an integral type
                      template<typename _InIterator>
                        void
          16 ->         _M_construct_aux(_InIterator __beg, _InIterator __end,
                			 std::__false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          _M_construct(__beg, __end, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
                	{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }
                
                      void
                      _M_construct_aux_2(size_type __req, _CharT __c)
                      { _M_construct(__req, __c); }
                
                      template<typename _InIterator>
                        void
          16 ->         _M_construct(_InIterator __beg, _InIterator __end)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  _M_construct_aux(__beg, __end, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<typename _InIterator>
                        void
                        _M_construct(_InIterator __beg, _InIterator __end,
                		     std::input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<typename _FwdIterator>
                        void
                        _M_construct(_FwdIterator __beg, _FwdIterator __end,
                		     std::forward_iterator_tag);
                
                      void
                      _M_construct(size_type __req, _CharT __c);
                
                      allocator_type&
                      _M_get_allocator()
                      { return _M_dataplus; }
                
                      const allocator_type&
                      _M_get_allocator() const
                      { return _M_dataplus; }
                
                    private:
                
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                      // The explicit instantiations in misc-inst.cc require this due to
                      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063
                      template<typename _Tp, bool _Requires =
                	       !__are_same<_Tp, _CharT*>::__value
                	       && !__are_same<_Tp, const _CharT*>::__value
                	       && !__are_same<_Tp, iterator>::__value
                	       && !__are_same<_Tp, const_iterator>::__value>
                	struct __enable_if_not_native_iterator
                	{ typedef basic_string& __type; };
                      template<typename _Tp>
                	struct __enable_if_not_native_iterator<_Tp, false> { };
                #endif
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);
                      }
                
                      static void
                      _S_assign(_CharT* __d, size_type __n, _CharT __c)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, ++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_assign(const basic_string& __rcs);
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
                		size_type __len2);
                
                      void
                      _M_erase(size_type __pos, size_type __n);
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                #if __cplusplus >= 201103L
                      noexcept(is_nothrow_default_constructible<_Alloc>::value)
                #endif
                      : _M_dataplus(_M_local_data())
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct string with copy of value of @a __str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str)
                      : _M_dataplus(_M_local_data(), __str._M_get_allocator()) // TODO A traits
                      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy (default remainder).
                       */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2402. [this constructor] shouldn't use Allocator()
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n = npos)
                      : _M_dataplus(_M_local_data())
                      {
                	const _CharT* __start = __str._M_data()
                	  + __str._M_check(__pos, "basic_string::basic_string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy (default remainder).
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	const _CharT* __start
                	  = __str._M_data() + __str._M_check(__pos, "string::string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__s, __s + __n); }
                
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
                
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       **/
                      basic_string(basic_string&& __str) noexcept
                      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
                      {
                	if (__str._M_is_local())
                	  {
                	    traits_type::copy(_M_local_buf, __str._M_local_buf,
                			      _S_local_capacity + 1);
                	  }
                	else
                	  {
                	    _M_data(__str._M_data());
                	    _M_capacity(__str._M_allocated_capacity);
                	  }
                
                	// Must use _M_length() here not _M_set_length() because
                	// basic_stringbuf relies on writing into unallocated capacity so
                	// we mess up the contents if we put a '\0' in the string.
                	_M_length(__str.length());
                	__str._M_data(__str._M_local_data());
                	__str._M_set_length(0);
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__l.begin(), __l.end()); }
                
                      basic_string(const basic_string& __str, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__str.begin(), __str.end()); }
                
                      basic_string(basic_string&& __str, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	if (__str.get_allocator() == __a)
                	  *this = std::move(__str);
                	else
                	  _M_construct(__str.begin(), __str.end());
                      }
                
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<typename _InputIterator>
                #endif
          16 ->         basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc())
                	: _M_dataplus(_M_local_data(), __a)
                	{ _M_construct(__beg, __end); }
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string()
                      { _M_dispose(); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str)
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s)
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c)
                      {
                	this->assign(1, __c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       **/
                      // PR 58265, this should be noexcept.
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2063. Contradictory requirements for string move assignment
                      basic_string&
                      operator=(basic_string&& __str)
                      {
                	this->swap(__str);
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.
                       */
                      iterator
                      begin() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.
                       */
                      iterator
                      end() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() noexcept
                      {
                #if __cpp_exceptions
                	if (capacity() > size())
                	  {
                	    try
                	      { reserve(0); }
                	    catch(...)
                	      { }
                	  }
                #endif
                      }
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      {
                	return _M_is_local() ? size_type(_S_local_capacity)
                	                     : _M_allocated_capacity;
                      }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_set_length(0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front() noexcept
                      { return operator[](0); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const noexcept
                      { return operator[](0); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back() noexcept
                      { return operator[](this->size() - 1); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const noexcept
                      { return operator[](this->size() - 1); }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      {
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str)
                      { return _M_append(__str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n)
                      { return _M_append(__str._M_data()
                			 + __str._M_check(__pos, "basic_string::append"),
                			 __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	const size_type __n = traits_type::length(__s);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c)
                      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(end(), end(), __first, __last); }
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      {
                	const size_type __size = this->size();
                	if (__size + 1 > this->capacity())
                	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
                	traits_type::assign(this->_M_data()[__size], __c);
                	this->_M_set_length(__size + 1);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str)
                      {
                	this->_M_assign(__str);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string&
                      assign(basic_string&& __str)
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 2063. Contradictory requirements for string move assignment
                	return *this = std::move(__str);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n)
                      { return _M_replace(size_type(0), this->size(), __str._M_data()
                			  + __str._M_check(__pos, "basic_string::assign"),
                			  __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	return _M_replace(size_type(0), this->size(), __s, __n);
                      }
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return _M_replace(size_type(0), this->size(), __s,
                			  traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(begin(), end(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(const_iterator __p, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	this->replace(__p, __p, __n, __c);
                	return iterator(this->_M_data() + __pos);
                      }
                #else
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [beg,end).  If adding characters
                       *  causes the length to exceed max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	  const size_type __pos = __p - begin();
                	  this->replace(__p, __p, __beg, __end);
                	  return iterator(this->_M_data() + __pos);
                	}
                #else
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	this->insert(__p - begin(), __l.begin(), __l.size());
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->replace(__pos1, size_type(0),
                			     __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n)
                      { return this->replace(__pos1, size_type(0), __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::insert"),
                			     __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n)
                      { return this->replace(__pos, size_type(0), __s, __n); }
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, size_type(0), __s,
                			     traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(__const_iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      {
                	this->_M_erase(_M_check(__pos, "basic_string::erase"),
                		       _M_limit(__pos, __n));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()
                				 && __position < end());
                	const size_type __pos = __position - begin();
                	this->_M_erase(__pos, size_type(1));
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __first, __const_iterator __last)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last
                				 && __last <= end());
                        const size_type __pos = __first - begin();
                	this->_M_erase(__pos, __last - __first);
                	return iterator(this->_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() noexcept
                      { _M_erase(size()-1, 1); }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2)
                      {
                	__glibcxx_requires_string_len(__s, __n2);
                	return _M_replace(_M_check(__pos, "basic_string::replace"),
                			  _M_limit(__pos, __n1), __s, __n2);
                      }
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
                	      _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        basic_string&
                        replace(const_iterator __i1, const_iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
                					   std::__false_type());
                	}
                #else
                      template<class _InputIterator>
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                        typename __enable_if_not_native_iterator<_InputIterator>::__type
                #else
                        basic_string&
                #endif
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                #endif
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(const_iterator __i1, const_iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
                #endif // C++11
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _Integer __n, _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _InputIterator __k1, _InputIterator __k2,
                			    __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
                		 const size_type __len2);
                
                      basic_string&
                      _M_append(const _CharT* __s, size_type __n);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      void
                      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_get_allocator(); }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                  };
                _GLIBCXX_END_NAMESPACE_CXX11
                #else  // !_GLIBCXX_USE_CXX11_ABI
                  // Reference-counted COW string implentation
                
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   *
                   *  @doctodo
                   *
                   *
                   *  Documentation?  What's that?
                   *  Nathan Myers <ncm@cantrip.org>.
                   *
                   *  A string looks like this:
                   *
                   *  @code
                   *                                        [_Rep]
                   *                                        _M_length
                   *   [basic_string<char_type>]            _M_capacity
                   *   _M_dataplus                          _M_refcount
                   *   _M_p ---------------->               unnamed array of char_type
                   *  @endcode
                   *
                   *  Where the _M_p points to the first character in the string, and
                   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
                   *  pointer to the header.
                   *
                   *  This approach has the enormous advantage that a string object
                   *  requires only one allocation.  All the ugliness is confined
                   *  within a single %pair of inline functions, which each compile to
                   *  a single @a add instruction: _Rep::_M_data(), and
                   *  string::_M_rep(); and the allocation function which gets a
                   *  block of raw bytes and with room enough and constructs a _Rep
                   *  object at the front.
                   *
                   *  The reason you want _M_data pointing to the character %array and
                   *  not the _Rep is so that the debugger can see the string
                   *  contents. (Probably we should add a non-inline member to get
                   *  the _Rep for the debugger to use, so users can check the actual
                   *  string length.)
                   *
                   *  Note that the _Rep object is a POD so that you can have a
                   *  static <em>empty string</em> _Rep object already @a constructed before
                   *  static constructors have run.  The reference-count encoding is
                   *  chosen so that a 0 indicates one reference, so you never try to
                   *  destroy the empty-string _Rep object.
                   *
                   *  All but the last paragraph is considered pretty conventional
                   *  for a C++ string implementation.
                  */
                  // 21.3  Template class basic_string
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
                
                      // Types:
                    public:
                      typedef _Traits					    traits_type;
                      typedef typename _Traits::char_type		    value_type;
                      typedef _Alloc					    allocator_type;
                      typedef typename _CharT_alloc_type::size_type	    size_type;
                      typedef typename _CharT_alloc_type::difference_type   difference_type;
                      typedef typename _CharT_alloc_type::reference	    reference;
                      typedef typename _CharT_alloc_type::const_reference   const_reference;
                      typedef typename _CharT_alloc_type::pointer	    pointer;
                      typedef typename _CharT_alloc_type::const_pointer	    const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                                            const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		    reverse_iterator;
                
                    private:
                      // _Rep: string representation
                      //   Invariants:
                      //   1. String really contains _M_length + 1 characters: due to 21.3.4
                      //      must be kept null-terminated.
                      //   2. _M_capacity >= _M_length
                      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
                      //   3. _M_refcount has three states:
                      //      -1: leaked, one reference, no ref-copies allowed, non-const.
                      //       0: one reference, non-const.
                      //     n>0: n + 1 references, operations require a lock, const.
                      //   4. All fields==0 is an empty string, given the extra storage
                      //      beyond-the-end for a null terminator; thus, the shared
                      //      empty string representation needs no constructor.
                
                      struct _Rep_base
                      {
                	size_type		_M_length;
                	size_type		_M_capacity;
                	_Atomic_word		_M_refcount;
                      };
                
                      struct _Rep : _Rep_base
                      {
                	// Types:
                	typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
                
                	// (Public) Data members:
                
                	// The maximum number of individual char_type elements of an
                	// individual string is determined by _S_max_size. This is the
                	// value that will be returned by max_size().  (Whereas npos
                	// is the maximum number of bytes the allocator can allocate.)
                	// If one was to divvy up the theoretical largest size string,
                	// with a terminating character and m _CharT elements, it'd
                	// look like this:
                	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
                	// Solving for m:
                	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
                	// In addition, this implementation quarters this amount.
                	static const size_type	_S_max_size;
                	static const _CharT	_S_terminal;
                
                	// The following storage is init'd to 0 by the linker, resulting
                        // (carefully) in an empty string with one reference.
                        static size_type _S_empty_rep_storage[];
                
                        static _Rep&
                        _S_empty_rep() _GLIBCXX_NOEXCEPT
                        { 
                	  // NB: Mild hack to avoid strict-aliasing warnings.  Note that
                	  // _S_empty_rep_storage is never modified and the punning should
                	  // be reasonably safe in this case.
                	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
                	  return *reinterpret_cast<_Rep*>(__p);
                	}
                
                        bool
                	_M_is_leaked() const _GLIBCXX_NOEXCEPT
                        { return this->_M_refcount < 0; }
                
                        bool
                	_M_is_shared() const _GLIBCXX_NOEXCEPT
                        { return this->_M_refcount > 0; }
                
                        void
                	_M_set_leaked() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = -1; }
                
                        void
                	_M_set_sharable() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = 0; }
                
                	void
                	_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      this->_M_set_sharable();  // One reference.
                	      this->_M_length = __n;
                	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
                	      // grrr. (per 21.3.4)
                	      // You cannot leave those LWG people alone for a second.
                	    }
                	}
                
                	_CharT*
                	_M_refdata() throw()
                	{ return reinterpret_cast<_CharT*>(this + 1); }
                
                	_CharT*
                	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
                	{
                	  return (!_M_is_leaked() && __alloc1 == __alloc2)
                	          ? _M_refcopy() : _M_clone(__alloc1);
                	}
                
                	// Create & Destroy
                	static _Rep*
                	_S_create(size_type, size_type, const _Alloc&);
                
                	void
                	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      // Be race-detector-friendly.  For more info see bits/c++config.
                	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
                	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
                							 -1) <= 0)
                		{
                		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
                		  _M_destroy(__a);
                		}
                	    }
                	}  // XXX MT
                
                	void
                	_M_destroy(const _Alloc&) throw();
                
                	_CharT*
                	_M_refcopy() throw()
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
                	  return _M_refdata();
                	}  // XXX MT
                
                	_CharT*
                	_M_clone(const _Alloc&, size_type __res = 0);
                      };
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : _Alloc
                      {
                	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	: _Alloc(__a), _M_p(__dat) { }
                
                	_CharT* _M_p; // The actual data.
                      };
                
                    public:
                      // Data Members (public):
                      // NB: This is an unsigned type, and thus represents the maximum
                      // size that the allocator can hold.
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // Data Members (private):
                      mutable _Alloc_hider	_M_dataplus;
                
                      _CharT*
                      _M_data() const _GLIBCXX_NOEXCEPT
                      { return  _M_dataplus._M_p; }
                
                      _CharT*
                      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
                      { return (_M_dataplus._M_p = __p); }
                
                      _Rep*
                      _M_rep() const _GLIBCXX_NOEXCEPT
                      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
                
                      // For the internal use we have functions similar to `begin'/`end'
                      // but they do not call _M_leak.
                      iterator
                      _M_ibegin() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      iterator
                      _M_iend() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      void
                      _M_leak()    // for use in begin() & non-const op[]
                      {
                	if (!_M_rep()->_M_is_leaked())
                	  _M_leak_hard();
                      }
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);	  
                      }
                
                      static void
                      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);	  
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, ++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
                
                      void
                      _M_leak_hard();
                
                      static _Rep&
                      _S_empty_rep() _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_empty_rep(); }
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
                #else
                      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ }
                #endif
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a);
                
                      // NB: per LWG issue 42, semantics different from IS:
                      /**
                       *  @brief  Construct string with copy of value of @a str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy (default remainder).
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n = npos);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a);
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       **/
                      basic_string(basic_string&& __str)
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      noexcept // FIXME C++11: should always be noexcept.
                #endif
                      : _M_dataplus(__str._M_dataplus)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	__str._M_data(_S_empty_rep()._M_refdata());
                #else
                	__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));
                #endif
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<class _InputIterator>
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc());
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string() _GLIBCXX_NOEXCEPT
                      { _M_rep()->_M_dispose(this->get_allocator()); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str) 
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s) 
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c) 
                      { 
                	this->assign(1, __c); 
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       **/
                      // PR 58265, this should be noexcept.
                      basic_string&
                      operator=(basic_string&& __str)
                      {
                	// NB: DR 1204.
                	this->swap(__str);
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.  Unshares the string.
                       */
                      iterator
                      begin() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.  Unshares the string.
                       */
                      iterator
                      end() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data() + this->size());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.  Unshares the string.
                       */
                      reverse_iterator
                      rbegin() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.  Unshares the string.
                       */
                      reverse_iterator
                      rend() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_max_size; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() _GLIBCXX_NOEXCEPT
                      {
                #if __cpp_exceptions
                	if (capacity() > size())
                	  {
                	    try
                	      { reserve(0); }
                	    catch(...)
                	      { }
                	  }
                #endif
                      }
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_capacity; }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      // PR 56166: this should not throw.
                      void
                      clear()
                      { _M_mutate(0, this->size(), 0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)  Unshares the string.
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	_M_leak();
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.  Success results in
                       *  unsharing the string.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	_M_leak();
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front()
                      { return operator[](0); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      { return operator[](0); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back()
                      { return operator[](this->size() - 1); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      { return operator[](this->size() - 1); }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      { 
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str);
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n);
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->append(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                      template<class _InputIterator>
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      { 
                	const size_type __len = 1 + this->size();
                	if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	  this->reserve(__len);
                	traits_type::assign(_M_data()[this->size()], __c);
                	_M_rep()->_M_set_length_and_sharable(__len);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      // PR 58265, this should be noexcept.
                      basic_string&
                      assign(basic_string&& __str)
                      {
                	this->swap(__str);
                	return *this;
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n)
                      { return this->assign(__str._M_data()
                			    + __str._M_check(__pos, "basic_string::assign"),
                			    __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->assign(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                      template<class _InputIterator>
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n)
                      { return this->insert(__pos1, __str._M_data()
                			    + __str._M_check(__pos2, "basic_string::insert"),
                			    __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->insert(__pos, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	const size_type __pos = __p - _M_ibegin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      { 
                	_M_mutate(_M_check(__pos, "basic_string::erase"),
                		  _M_limit(__pos, __n), size_type(0));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
                				 && __position < _M_iend());
                	const size_type __pos = __position - _M_ibegin();
                	_M_mutate(__pos, size_type(1), size_type(0));
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __first, iterator __last);
                 
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() // FIXME C++11: should be noexcept.
                      { erase(size()-1, 1); }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2);
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      template<class _InputIterator>
                        basic_string&
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				   && __i2 <= _M_iend());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                      
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(iterator __i1, iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
                #endif // C++11
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
                			    _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			    _InputIterator __k2, __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		      size_type __n2);
                
                      // _S_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIter is an integral type
                      template<class _InIterator>
                        static _CharT*
                        _S_construct_aux(_InIterator __beg, _InIterator __end,
                			 const _Alloc& __a, __false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          return _S_construct(__beg, __end, __a, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<class _Integer>
                        static _CharT*
                        _S_construct_aux(_Integer __beg, _Integer __end,
                			 const _Alloc& __a, __true_type)
                        { return _S_construct_aux_2(static_cast<size_type>(__beg),
                				    __end, __a); }
                
                      static _CharT*
                      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
                      { return _S_construct(__req, __c, __a); }
                
                      template<class _InIterator>
                        static _CharT*
                        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  return _S_construct_aux(__beg, __end, __a, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<class _InIterator>
                        static _CharT*
                         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		      input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<class _FwdIterator>
                        static _CharT*
                        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
                		     forward_iterator_tag);
                
                      static _CharT*
                      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      // PR 58265, this should be noexcept.
                      void
                      swap(basic_string& __s);
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_dataplus; }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                	_GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                  };
                #endif  // !_GLIBCXX_USE_CXX11_ABI
                
                  // operator+
                  /**
                   *  @brief  Concatenate two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate C string and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate character and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate string and C string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate string and character.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __string_type::size_type		__size_type;
                      __string_type __str(__lhs);
                      __str.append(__size_type(1), __rhs);
                      return __str;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    {
                      const auto __size = __lhs.size() + __rhs.size();
                      const bool __cond = (__size > __lhs.capacity()
                			   && __size <= __rhs.capacity());
                      return __cond ? std::move(__rhs.insert(0, __lhs))
                	            : std::move(__lhs.append(__rhs));
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
          16 ->     operator+(const _CharT* __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, 1, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
          16 ->     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const _CharT* __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      _CharT __rhs)
                    { return std::move(__lhs.append(1, __rhs)); }
                #endif
                
                  // operator ==
                  /**
                   *  @brief  Test equivalence of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  template<typename _CharT>
                    inline
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
                    operator==(const basic_string<_CharT>& __lhs,
                	       const basic_string<_CharT>& __rhs)
                    { return (__lhs.size() == __rhs.size()
                	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
                						    __lhs.size())); }
                
                  /**
                   *  @brief  Test equivalence of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) == 0; }
                
                  /**
                   *  @brief  Test equivalence of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  // operator !=
                  /**
                   *  @brief  Test difference of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return !(__lhs == __rhs); }
                
                  // operator <
                  /**
                   *  @brief  Test if string precedes string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if string precedes C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if C string precedes string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) > 0; }
                
                  // operator >
                  /**
                   *  @brief  Test if string follows string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if string follows C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if C string follows string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) < 0; }
                
                  // operator <=
                  /**
                   *  @brief  Test if string doesn't follow string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if string doesn't follow C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't follow string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) >= 0; }
                
                  // operator >=
                  /**
                   *  @brief  Test if string doesn't precede string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if string doesn't precede C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't precede string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const _CharT* __lhs,
                	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) <= 0; }
                
                  /**
                   *  @brief  Swap contents of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *
                   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline void
                    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	 basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { __lhs.swap(__rhs); }
                
                
                  /**
                   *  @brief  Read stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until whitespace is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  If is.width() is non-zero, that is the limit on the
                   *  number of characters stored into @a __str.  Any previous
                   *  contents of @a __str are erased.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is,
                	       basic_string<_CharT, _Traits, _Alloc>& __str);
                
                  template<>
                    basic_istream<char>&
                    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
                
                  /**
                   *  @brief  Write string to a stream.
                   *  @param __os  Output stream.
                   *  @param __str  String to write out.
                   *  @return  Reference to the output stream.
                   *
                   *  Output characters of @a __str into os following the same rules as for
                   *  writing a C string.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os,
                	       const basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 586. string inserter not a formatted function
                      return __ostream_insert(__os, __str.data(), __str.size());
                    }
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @param __delim  Character marking end of line.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until @a __delim is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  @a __delim is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from is into @a __str until &apos;\n&apos; is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  end of line is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str, __is.widen('\n')); }
                
                #if __cplusplus >= 201103L
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    { return std::getline(__is, __str, __delim); }
                
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str); }
                #endif
                
                  template<>
                    basic_istream<char>&
                    getline(basic_istream<char>& __in, basic_string<char>& __str,
                	    char __delim);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
                	    wchar_t __delim);
                #endif  
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L && defined(_GLIBCXX_USE_C99)
                
                #include <ext/string_conversions.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                
                  // 21.4 Numeric Conversions [string.conversions].
                  inline int
                  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long
                  stol(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: strtof vs strtod.
                  inline float
                  stof(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
                
                  // NB: (v)snprintf vs sprintf.
                
                  // DR 1261.
                  inline string
                  to_string(int __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
                					   "%d", __val); }
                
                  inline string
                  to_string(unsigned __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned),
                					   "%u", __val); }
                
                  inline string
                  to_string(long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
                					   "%ld", __val); }
                
                  inline string
                  to_string(unsigned long __val)
          16 ->   { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long),
                					   "%lu", __val); }
                
                  inline string
                  to_string(long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(long long),
                					   "%lld", __val); }
                
                  inline string
                  to_string(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long long),
                					   "%llu", __val); }
                
                  inline string
                  to_string(float __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(long double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%Lf", __val);
                  }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  inline int 
                  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long 
                  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: wcstof vs wcstod.
                  inline float
                  stof(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }
                
                #ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                  // DR 1261.
                  inline wstring
                  to_wstring(int __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
                					    L"%d", __val); }
                
                  inline wstring
                  to_wstring(unsigned __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned),
                					    L"%u", __val); }
                
                  inline wstring
                  to_wstring(long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
                					    L"%ld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long),
                					    L"%lu", __val); }
                
                  inline wstring
                  to_wstring(long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(long long),
                					    L"%lld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long long),
                					    L"%llu", __val); }
                
                  inline wstring
                  to_wstring(float __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(long double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%Lf", __val);
                  }
                #endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                #endif
                
                _GLIBCXX_END_NAMESPACE_CXX11
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* C++11 && _GLIBCXX_USE_C99 ... */
                
                #if __cplusplus >= 201103L
                
                #include <bits/functional_hash.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // DR 1182.
                
                #ifndef _GLIBCXX_COMPATIBILITY_CXX0X
                  /// std::hash specialization for string.
                  template<>
                    struct hash<string>
                    : public __hash_base<size_t, string>
                    {
                      size_t
                      operator()(const string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<string>> : std::false_type
                    { };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  /// std::hash specialization for wstring.
                  template<>
                    struct hash<wstring>
                    : public __hash_base<size_t, wstring>
                    {
                      size_t
                      operator()(const wstring& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(wchar_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<wstring>> : std::false_type
                    { };
                #endif
                #endif /* _GLIBCXX_COMPATIBILITY_CXX0X */
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                  /// std::hash specialization for u16string.
                  template<>
                    struct hash<u16string>
                    : public __hash_base<size_t, u16string>
                    {
                      size_t
                      operator()(const u16string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char16_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u16string>> : std::false_type
                    { };
                
                  /// std::hash specialization for u32string.
                  template<>
                    struct hash<u32string>
                    : public __hash_base<size_t, u32string>
                    {
                      size_t
                      operator()(const u32string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char32_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u32string>> : std::false_type
                    { };
                #endif
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_string_udls 201304
                
                  inline namespace literals
                  {
                  inline namespace string_literals
                  {
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char>
                    operator""s(const char* __str, size_t __len)
                    { return basic_string<char>{__str, __len}; }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<wchar_t>
                    operator""s(const wchar_t* __str, size_t __len)
                    { return basic_string<wchar_t>{__str, __len}; }
                #endif
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char16_t>
                    operator""s(const char16_t* __str, size_t __len)
                    { return basic_string<char16_t>{__str, __len}; }
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char32_t>
                    operator""s(const char32_t* __str, size_t __len)
                    { return basic_string<char32_t>{__str, __len}; }
                #endif
                
                  } // inline namespace string_literals
                  } // inline namespace literals
                
                #endif // __cplusplus > 201103L
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _BASIC_STRING_H */


Top 10 Lines:

     Line      Count

      191         16
      211         16
      534         16
     4872         16
     4884         16
     5316         16

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

       96   Total number of line executions
    13.71   Average executions per line


*** File /usr/include/c++/5/bits/stl_function.h:
                // Functor implementations -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_function.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{functional}
                 */
                
                #ifndef _STL_FUNCTION_H
                #define _STL_FUNCTION_H 1
                
                #if __cplusplus > 201103L
                #include <bits/move.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // 20.3.1 base classes
                  /** @defgroup functors Function Objects
                   * @ingroup utilities
                   *
                   *  Function objects, or @e functors, are objects with an @c operator()
                   *  defined and accessible.  They can be passed as arguments to algorithm
                   *  templates and used in place of a function pointer.  Not only is the
                   *  resulting expressiveness of the library increased, but the generated
                   *  code can be more efficient than what you might write by hand.  When we
                   *  refer to @a functors, then, generally we include function pointers in
                   *  the description as well.
                   *
                   *  Often, functors are only created as temporaries passed to algorithm
                   *  calls, rather than being created as named variables.
                   *
                   *  Two examples taken from the standard itself follow.  To perform a
                   *  by-element addition of two vectors @c a and @c b containing @c double,
                   *  and put the result in @c a, use
                   *  \code
                   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
                   *  \endcode
                   *  To negate every element in @c a, use
                   *  \code
                   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
                   *  \endcode
                   *  The addition and negation functions will be inlined directly.
                   *
                   *  The standard functors are derived from structs named @c unary_function
                   *  and @c binary_function.  These two classes contain nothing but typedefs,
                   *  to aid in generic (template) programming.  If you write your own
                   *  functors, you might consider doing the same.
                   *
                   *  @{
                   */
                  /**
                   *  This is one of the @link functors functor base classes@endlink.
                   */
                  template<typename _Arg, typename _Result>
         801 ->     struct unary_function
                    {
                      /// @c argument_type is the type of the argument
                      typedef _Arg 	argument_type;   
                
                      /// @c result_type is the return type
                      typedef _Result 	result_type;  
                    };
                
                  /**
                   *  This is one of the @link functors functor base classes@endlink.
                   */
                  template<typename _Arg1, typename _Arg2, typename _Result>
        2853 ->     struct binary_function
                    {
                      /// @c first_argument_type is the type of the first argument
                      typedef _Arg1 	first_argument_type; 
                
                      /// @c second_argument_type is the type of the second argument
                      typedef _Arg2 	second_argument_type;
                
                      /// @c result_type is the return type
                      typedef _Result 	result_type;
                    };
                  /** @}  */
                
                  // 20.3.2 arithmetic
                  /** @defgroup arithmetic_functors Arithmetic Classes
                   * @ingroup functors
                   *
                   *  Because basic math often needs to be done during an algorithm,
                   *  the library provides functors for those operations.  See the
                   *  documentation for @link functors the base classes@endlink
                   *  for examples of their use.
                   *
                   *  @{
                   */
                
                #if __cplusplus > 201103L
                  struct __is_transparent;  // undefined
                
                  template<typename _Tp = void>
                    struct plus;
                
                  template<typename _Tp = void>
                    struct minus;
                
                  template<typename _Tp = void>
                    struct multiplies;
                
                  template<typename _Tp = void>
                    struct divides;
                
                  template<typename _Tp = void>
                    struct modulus;
                
                  template<typename _Tp = void>
                    struct negate;
                #endif
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct plus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x + __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct minus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x - __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x * __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct divides : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x / __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct modulus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x % __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct negate : public unary_function<_Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x) const
                      { return -__x; }
                    };
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_transparent_operators 201210
                //#define __cpp_lib_generic_associative_lookup 201304
                
                  template<>
                    struct plus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct minus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct multiplies<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct divides<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct modulus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct negate<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(-std::forward<_Tp>(__t)))
                	-> decltype(-std::forward<_Tp>(__t))
                	{ return -std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                  /** @}  */
                
                  // 20.3.3 comparisons
                  /** @defgroup comparison_functors Comparison Classes
                   * @ingroup functors
                   *
                   *  The library provides six wrapper functors for all the basic comparisons
                   *  in C++, like @c <.
                   *
                   *  @{
                   */
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct equal_to;
                
                  template<typename _Tp = void>
                    struct not_equal_to;
                
                  template<typename _Tp = void>
                    struct greater;
                
                  template<typename _Tp = void>
                    struct less;
                
                  template<typename _Tp = void>
                    struct greater_equal;
                
                  template<typename _Tp = void>
                    struct less_equal;
                #endif
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x == __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x != __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct greater : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x > __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct less : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
       64185 ->       operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x < __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct greater_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x >= __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct less_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x <= __y; }
                    };
                
                #if __cplusplus > 201103L
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct equal_to<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct not_equal_to<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct greater<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct less<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct greater_equal<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct less_equal<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                  /** @}  */
                
                  // 20.3.4 logical operations
                  /** @defgroup logical_functors Boolean Operations Classes
                   * @ingroup functors
                   *
                   *  Here are wrapper functors for Boolean operations: @c &&, @c ||,
                   *  and @c !.
                   *
                   *  @{
                   */
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct logical_and;
                
                  template<typename _Tp = void>
                    struct logical_or;
                
                  template<typename _Tp = void>
                    struct logical_not;
                #endif
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_and : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x && __y; }
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_or : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x || __y; }
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_not : public unary_function<_Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x) const
                      { return !__x; }
                    };
                
                #if __cplusplus > 201103L
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_and<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_or<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_not<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(!std::forward<_Tp>(__t)))
                	-> decltype(!std::forward<_Tp>(__t))
                	{ return !std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                  /** @}  */
                
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct bit_and;
                
                  template<typename _Tp = void>
                    struct bit_or;
                
                  template<typename _Tp = void>
                    struct bit_xor;
                
                  template<typename _Tp = void>
                    struct bit_not;
                #endif
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 660. Missing Bitwise Operations.
                  template<typename _Tp>
                    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x & __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x | __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x ^ __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_not : public unary_function<_Tp, _Tp>
                    {
                    _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x) const
                      { return ~__x; }
                    };
                
                #if __cplusplus > 201103L
                  template <>
                    struct bit_and<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_or<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_xor<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_not<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(~std::forward<_Tp>(__t)))
                	-> decltype(~std::forward<_Tp>(__t))
                	{ return ~std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                
                  // 20.3.5 negators
                  /** @defgroup negators Negators
                   * @ingroup functors
                   *
                   *  The functions @c not1 and @c not2 each take a predicate functor
                   *  and return an instance of @c unary_negate or
                   *  @c binary_negate, respectively.  These classes are functors whose
                   *  @c operator() performs the stored predicate function and then returns
                   *  the negation of the result.
                   *
                   *  For example, given a vector of integers and a trivial predicate,
                   *  \code
                   *  struct IntGreaterThanThree
                   *    : public std::unary_function<int, bool>
                   *  {
                   *      bool operator() (int x) { return x > 3; }
                   *  };
                   *
                   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
                   *  \endcode
                   *  The call to @c find_if will locate the first index (i) of @c v for which
                   *  <code>!(v[i] > 3)</code> is true.
                   *
                   *  The not1/unary_negate combination works on predicates taking a single
                   *  argument.  The not2/binary_negate combination works on predicates which
                   *  take two arguments.
                   *
                   *  @{
                   */
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    class unary_negate
                    : public unary_function<typename _Predicate::argument_type, bool>
                    {
                    protected:
                      _Predicate _M_pred;
                
                    public:
                      _GLIBCXX14_CONSTEXPR
                      explicit
                      unary_negate(const _Predicate& __x) : _M_pred(__x) { }
                
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const typename _Predicate::argument_type& __x) const
                      { return !_M_pred(__x); }
                    };
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    _GLIBCXX14_CONSTEXPR
                    inline unary_negate<_Predicate>
                    not1(const _Predicate& __pred)
                    { return unary_negate<_Predicate>(__pred); }
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    class binary_negate
                    : public binary_function<typename _Predicate::first_argument_type,
                			     typename _Predicate::second_argument_type, bool>
                    {
                    protected:
                      _Predicate _M_pred;
                
                    public:
                      _GLIBCXX14_CONSTEXPR
                      explicit
                      binary_negate(const _Predicate& __x) : _M_pred(__x) { }
                
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const typename _Predicate::first_argument_type& __x,
                		 const typename _Predicate::second_argument_type& __y) const
                      { return !_M_pred(__x, __y); }
                    };
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    _GLIBCXX14_CONSTEXPR
                    inline binary_negate<_Predicate>
                    not2(const _Predicate& __pred)
                    { return binary_negate<_Predicate>(__pred); }
                  /** @}  */
                
                  // 20.3.7 adaptors pointers functions
                  /** @defgroup pointer_adaptors Adaptors for pointers to functions
                   * @ingroup functors
                   *
                   *  The advantage of function objects over pointers to functions is that
                   *  the objects in the standard library declare nested typedefs describing
                   *  their argument and result types with uniform names (e.g., @c result_type
                   *  from the base classes @c unary_function and @c binary_function).
                   *  Sometimes those typedefs are required, not just optional.
                   *
                   *  Adaptors are provided to turn pointers to unary (single-argument) and
                   *  binary (double-argument) functions into function objects.  The
                   *  long-winded functor @c pointer_to_unary_function is constructed with a
                   *  function pointer @c f, and its @c operator() called with argument @c x
                   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
                   *  thing, but with a double-argument @c f and @c operator().
                   *
                   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
                   *  an instance of the appropriate functor.
                   *
                   *  @{
                   */
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg, typename _Result>
                    class pointer_to_unary_function : public unary_function<_Arg, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg);
                
                    public:
                      pointer_to_unary_function() { }
                
                      explicit
                      pointer_to_unary_function(_Result (*__x)(_Arg))
                      : _M_ptr(__x) { }
                
                      _Result
                      operator()(_Arg __x) const
                      { return _M_ptr(__x); }
                    };
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg, typename _Result>
                    inline pointer_to_unary_function<_Arg, _Result>
                    ptr_fun(_Result (*__x)(_Arg))
                    { return pointer_to_unary_function<_Arg, _Result>(__x); }
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    class pointer_to_binary_function
                    : public binary_function<_Arg1, _Arg2, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg1, _Arg2);
                
                    public:
                      pointer_to_binary_function() { }
                
                      explicit
                      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
                      : _M_ptr(__x) { }
                
                      _Result
                      operator()(_Arg1 __x, _Arg2 __y) const
                      { return _M_ptr(__x, __y); }
                    };
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
                    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
                    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
                  /** @}  */
                
                  template<typename _Tp>
                    struct _Identity
                    : public unary_function<_Tp,_Tp>
                    {
                      _Tp&
                      operator()(_Tp& __x) const
                      { return __x; }
                
                      const _Tp&
                      operator()(const _Tp& __x) const
                      { return __x; }
                    };
                
                  template<typename _Pair>
                    struct _Select1st
                    : public unary_function<_Pair, typename _Pair::first_type>
                    {
                      typename _Pair::first_type&
                      operator()(_Pair& __x) const
                      { return __x.first; }
                
                      const typename _Pair::first_type&
       59321 ->       operator()(const _Pair& __x) const
                      { return __x.first; }
                
                #if __cplusplus >= 201103L
                      template<typename _Pair2>
                        typename _Pair2::first_type&
                        operator()(_Pair2& __x) const
                        { return __x.first; }
                
                      template<typename _Pair2>
                        const typename _Pair2::first_type&
                        operator()(const _Pair2& __x) const
                        { return __x.first; }
                #endif
                    };
                
                  template<typename _Pair>
                    struct _Select2nd
                    : public unary_function<_Pair, typename _Pair::second_type>
                    {
                      typename _Pair::second_type&
                      operator()(_Pair& __x) const
                      { return __x.second; }
                
                      const typename _Pair::second_type&
                      operator()(const _Pair& __x) const
                      { return __x.second; }
                    };
                
                  // 20.3.8 adaptors pointers members
                  /** @defgroup memory_adaptors Adaptors for pointers to members
                   * @ingroup functors
                   *
                   *  There are a total of 8 = 2^3 function objects in this family.
                   *   (1) Member functions taking no arguments vs member functions taking
                   *        one argument.
                   *   (2) Call through pointer vs call through reference.
                   *   (3) Const vs non-const member function.
                   *
                   *  All of this complexity is in the function objects themselves.  You can
                   *   ignore it by using the helper function mem_fun and mem_fun_ref,
                   *   which create whichever type of adaptor is appropriate.
                   *
                   *  @{
                   */
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class mem_fun_t : public unary_function<_Tp*, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp* __p) const
                      { return (__p->*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)();
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp* __p) const
                      { return (__p->*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_ref_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp& __r) const
                      { return (__r.*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)();
                  };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp& __r) const
                      { return (__r.*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  // Mem_fun adaptor helper functions.  There are only two:
                  // mem_fun and mem_fun_ref.
                  template<typename _Ret, typename _Tp>
                    inline mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)())
                    { return mem_fun_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline const_mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)())
                    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline const_mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  /** @}  */
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if (__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED
                # include <backward/binders.h>
                #endif
                
                #endif /* _STL_FUNCTION_H */


Top 10 Lines:

     Line      Count

      386      64185
      891      59321
      118       2853
      105        801

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

   127160   Total number of line executions
 31790.00   Average executions per line


*** File /home/sbillah/dmclock/sim/../src/dmclock_recs.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                
                #include <ostream>
                #include <assert.h>
                
                
                namespace crimson {
                  namespace dmclock {
                    using Counter = uint64_t;
                
                    enum class PhaseType { reservation, priority };
                
                    inline std::ostream& operator<<(std::ostream& out, const PhaseType& phase) {
                      out << (PhaseType::reservation == phase ? "reservation" : "priority");
                      return out;
                    }
                
                    struct ReqParams {
                      // count of all replies since last request; MUSTN'T BE 0
                      uint32_t delta;
                
                      // count of reservation replies since last request; MUSTN'T BE 0
                      uint32_t rho;
                
        1802 ->       ReqParams(uint32_t _delta, uint32_t _rho) :
                	delta(_delta),
                	rho(_rho)
                      {
                	assert(0 != delta && 0 != rho && rho <= delta);
                      }
                
                      ReqParams() :
                	ReqParams(1, 1)
                      {
                	// empty
                      }
                
                      ReqParams(const ReqParams& other) :
                	delta(other.delta),
                	rho(other.rho)
                      {
                	// empty
                      }
                
                      friend std::ostream& operator<<(std::ostream& out, const ReqParams& rp) {
                	out << "ReqParams{ delta:" << rp.delta <<
                	  ", rho:" << rp.rho << " }";
                	return out;
                      }
                    }; // class ReqParams
                  }
                }


Top 10 Lines:

     Line      Count

       34       1802

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     1802   Total number of line executions
  1802.00   Average executions per line


*** File /home/sbillah/dmclock/sim/sim_server.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                
                #include <thread>
                #include <mutex>
                #include <condition_variable>
                #include <chrono>
                #include <deque>
                
                #include "sim_recs.h"
                
                
                namespace crimson {
                  namespace qos_simulation {
                
                    template<typename Q, typename ReqPm, typename RespPm, typename Accum>
                    class SimulatedServer {
                
        8122 ->       struct QueueItem {
                	ClientId                     client;
                	std::unique_ptr<TestRequest> request;
                	RespPm                       additional;
                
        2415 -> 	QueueItem(const ClientId&                _client,
                		  std::unique_ptr<TestRequest>&& _request,
                		  const RespPm&                  _additional) :
                	  client(_client),
                	  request(std::move(_request)),
                	  additional(_additional)
                	{
                	  // empty
                	}
                      }; // QueueItem
                
                    public:
                
                      struct InternalStats {
                	std::mutex mtx;
                	std::chrono::nanoseconds add_request_time;
                	std::chrono::nanoseconds request_complete_time;
                	uint32_t add_request_count;
                	uint32_t request_complete_count;
                
         100 -> 	InternalStats() :
                	  add_request_time(0),
                	  request_complete_time(0),
                	  add_request_count(0),
                	  request_complete_count(0)
                	{
                	  // empty
                	}
                      };
                
                      using ClientRespFunc = std::function<void(ClientId,
                						const TestResponse&,
                						const ServerId&,
                						const RespPm&)>;
                
                      using ServerAccumFunc = std::function<void(Accum& accumulator,
                						 const RespPm& additional)>;
                
                    protected:
                
                      const ServerId                 id;
                      Q*                             priority_queue;
                      ClientRespFunc                 client_resp_f;
                      int                            iops;
                      size_t                         thread_pool_size;
                
                      bool                           finishing;
                      std::chrono::microseconds      op_time;
                
                      std::mutex                     inner_queue_mtx;
                      std::condition_variable        inner_queue_cv;
                      std::deque<QueueItem>          inner_queue;
                
                      std::thread*                   threads;
                
                      using InnerQGuard = std::lock_guard<decltype(inner_queue_mtx)>;
                      using Lock = std::unique_lock<std::mutex>;
                
                      // data collection
                
                      ServerAccumFunc accum_f;
                      Accum accumulator;
                
                      InternalStats internal_stats;
                
                    public:
                
                      using CanHandleRequestFunc = std::function<bool(void)>;
                      using HandleRequestFunc =
                	std::function<void(const ClientId&,std::unique_ptr<TestRequest>,const RespPm&)>;
                      using CreateQueueF = std::function<Q*(CanHandleRequestFunc,HandleRequestFunc)>;
                					
                
         100 ->       SimulatedServer(ServerId _id,
                		      int _iops,
                		      size_t _thread_pool_size,
                		      const ClientRespFunc& _client_resp_f,
                		      const ServerAccumFunc& _accum_f,
                		      CreateQueueF _create_queue_f) :
                	id(_id),
                	priority_queue(_create_queue_f(std::bind(&SimulatedServer::has_avail_thread,
                						 this),
                				       std::bind(&SimulatedServer::inner_post,
                						 this,
                						 std::placeholders::_1,
                						 std::placeholders::_2,
                						 std::placeholders::_3))),
                	client_resp_f(_client_resp_f),
                	iops(_iops),
                	thread_pool_size(_thread_pool_size),
                	finishing(false),
                	accum_f(_accum_f)
                      {
                	op_time =
                	  std::chrono::microseconds((int) (0.5 +
                					   thread_pool_size * 1000000.0 / iops));
                	std::chrono::milliseconds delay(1000);
                	threads = new std::thread[thread_pool_size];
                	for (size_t i = 0; i < thread_pool_size; ++i) {
                	  threads[i] = std::thread(&SimulatedServer::run, this, delay);
                	}
                      }
                
         200 ->       virtual ~SimulatedServer() {
                	Lock l(inner_queue_mtx);
                	finishing = true;
                	inner_queue_cv.notify_all();
                	l.unlock();
                
                	for (size_t i = 0; i < thread_pool_size; ++i) {
                	  threads[i].join();
                	}
                
                	delete[] threads;
                      }
                
        1882 ->       void post(const TestRequest& request,
                		const ClientId& client_id,
                		const ReqPm& req_params)
                      {
                	time_stats(internal_stats.mtx,
                		   internal_stats.add_request_time,
        1891 -> 		   [&](){
                		     priority_queue->add_request(request, client_id, req_params);
                		   });
                	count_stats(internal_stats.mtx,
                		    internal_stats.add_request_count);
                      }
                
        4662 ->       bool has_avail_thread() {
                	InnerQGuard g(inner_queue_mtx);
                	return inner_queue.size() <= thread_pool_size;
                      }
                
         200 ->       const Accum& get_accumulator() const { return accumulator; }
                      const Q& get_priority_queue() const { return *priority_queue; }
         100 ->       const InternalStats& get_internal_stats() const { return internal_stats; }
                
                    protected:
                
        2382 ->       void inner_post(const ClientId& client,
                		      std::unique_ptr<TestRequest> request,
                		      const RespPm& additional) {
                	Lock l(inner_queue_mtx);
                	assert(!finishing);
                	accum_f(accumulator, additional);
                	inner_queue.emplace_back(QueueItem(client,
                					   std::move(request),
                					   additional));
                	inner_queue_cv.notify_one();
                      }
                
          42 ->       void run(std::chrono::milliseconds check_period) {
                	Lock l(inner_queue_mtx);
                	while(true) {
                	  while(inner_queue.empty() && !finishing) {
                	    inner_queue_cv.wait_for(l, check_period);
                	  }
                	  if (!inner_queue.empty()) {
                	    auto& front = inner_queue.front();
                	    auto client = front.client;
                	    auto req = std::move(front.request);
                	    auto additional = front.additional;
                	    inner_queue.pop_front();
                
                	    l.unlock();
                
                	    // simulation operation by sleeping; then call function to
                	    // notify server of completion
                	    std::this_thread::sleep_for(op_time);
                
                	    TestResponse resp(req->epoch);
                	    // TODO: rather than assuming this constructor exists, perhaps
                	    // pass in a function that does this mapping?
                	    client_resp_f(client, resp, id, additional);
                
                	    time_stats(internal_stats.mtx,
                		       internal_stats.request_complete_time,
        2595 -> 		       [&](){
                			 priority_queue->request_completed();
                		       });
                	    count_stats(internal_stats.mtx,
                			internal_stats.request_complete_count);
                
                	    l.lock(); // in prep for next iteration of loop
                	  } else {
                	    break;
                	  }
                	}
                      }
                    }; // class SimulatedServer
                
                  }; // namespace qos_simulation
                }; // namespace crimson


Top 10 Lines:

     Line      Count

       27       8122
      161       4662
      210       2595
       32       2415
      172       2382
      154       1891
      148       1882
      135        200
      166        200
       52        100

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

    24691   Total number of line executions
  1899.31   Average executions per line


*** File /usr/include/c++/5/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Alloc>
                    void
           8 ->     vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp = _M_allocate_and_copy(__n,
                	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			_M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
        2287 ->       vector<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                	  && __position == end())
                	{
                	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                #if __cplusplus >= 201103L
                	  const auto __pos = begin() + (__position - cbegin());
                	  if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	    {
                	      _Tp __x_copy = __x;
                	      _M_insert_aux(__pos, std::move(__x_copy));
                	    }
                	  else
                	    _M_insert_aux(__pos, __x);
                #else
                	    _M_insert_aux(__position, __x);
                #endif
                	}
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	{
                	  if (__last != end())
                	    _GLIBCXX_MOVE3(__last, end(), __first);
                	  _M_erase_at_end(__first.base() + (end() - __last));
                	}
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
       ##### ->     vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // replacement allocator cannot free existing storage
                		  this->clear();
                		  _M_deallocate(this->_M_impl._M_start,
                				this->_M_impl._M_end_of_storage
                				- this->_M_impl._M_start);
                		  this->_M_impl._M_start = nullptr;
                		  this->_M_impl._M_finish = nullptr;
                		  this->_M_impl._M_end_of_storage = nullptr;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                			    end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                					  __x._M_impl._M_finish,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp._M_impl._M_swap_data(this->_M_impl);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					  __n - size(), __val,
                					  _M_get_Tp_allocator());
                	}
                      else
                        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	pointer __cur(this->_M_impl._M_start);
                	for (; __first != __last && __cur != this->_M_impl._M_finish;
                	     ++__cur, ++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  _M_erase_at_end(__cur);
                	else
                	  insert(end(), __first, __last);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	  }
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      typename vector<_Tp, _Alloc>::iterator
                      vector<_Tp, _Alloc>::
                      emplace(const_iterator __position, _Args&&... __args)
                      {
                	const size_type __n = __position - begin();
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                	    && __position == end())
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_insert_aux(begin() + (__position - cbegin()),
                			std::forward<_Args>(__args)...);
                	return iterator(this->_M_impl._M_start + __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      vector<_Tp, _Alloc>::
                      _M_insert_aux(iterator __position, _Args&&... __args)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_insert_aux(iterator __position, const _Tp& __x)
                #endif
                    {
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	{
                	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                			           _GLIBCXX_MOVE(*(this->_M_impl._M_finish
                				                   - 1)));
                	  ++this->_M_impl._M_finish;
                #if __cplusplus < 201103L
                	  _Tp __x_copy = __x;
                #endif
                	  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                				  this->_M_impl._M_finish - 2,
                				  this->_M_impl._M_finish - 1);
                #if __cplusplus < 201103L
                	  *__position = __x_copy;
                #else
                	  *__position = _Tp(std::forward<_Args>(__args)...);
                #endif
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector::_M_insert_aux");
                	  const size_type __elems_before = __position - begin();
                	  pointer __new_start(this->_M_allocate(__len));
                	  pointer __new_finish(__new_start);
                	  __try
                	    {
                	      // The order of the three operations is dictated by the C++0x
                	      // case, where the moves could alter a new element belonging
                	      // to the existing vector.  This is an issue only for callers
                	      // taking the element by const lvalue ref (see 23.1/13).
                	      _Alloc_traits::construct(this->_M_impl,
                		                       __new_start + __elems_before,
                #if __cplusplus >= 201103L
                				       std::forward<_Args>(__args)...);
                #else
                	                               __x);
                #endif
                	      __new_finish = pointer();
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(this->_M_impl._M_start, __position.base(),
                		 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__position.base(), this->_M_impl._M_finish,
                		 __new_finish, _M_get_Tp_allocator());
                	    }
                          __catch(...)
                	    {
                	      if (!__new_finish)
                		_Alloc_traits::destroy(this->_M_impl,
                		                       __new_start + __elems_before);
                	      else
                		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	      _M_deallocate(__new_start, __len);
                	      __throw_exception_again;
                	    }
                	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			_M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __new_start;
                	  this->_M_impl._M_finish = __new_finish;
                	  this->_M_impl._M_end_of_storage = __new_start + __len;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
         135 ->       vector<_Tp, _Alloc>::
                      _M_emplace_back_aux(_Args&&... __args)
                      {
                	const size_type __len =
                	  _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
                	pointer __new_start(this->_M_allocate(__len));
                	pointer __new_finish(__new_start);
                	__try
                	  {
                	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
                				     std::forward<_Args>(__args)...);
                	    __new_finish = pointer();
                
                	    __new_finish
                	      = std::__uninitialized_move_if_noexcept_a
                	      (this->_M_impl._M_start, this->_M_impl._M_finish,
                	       __new_start, _M_get_Tp_allocator());
                
                	    ++__new_finish;
                	  }
                	__catch(...)
                	  {
                	    if (!__new_finish)
                	      _Alloc_traits::destroy(this->_M_impl, __new_start + size());
                	    else
                	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	    _M_deallocate(__new_start, __len);
                	    __throw_exception_again;
                	  }
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	_M_deallocate(this->_M_impl._M_start,
                		      this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start);
                	this->_M_impl._M_start = __new_start;
                	this->_M_impl._M_finish = __new_finish;
                	this->_M_impl._M_end_of_storage = __new_start + __len;
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                	      value_type __x_copy = __x;
                	      const size_type __elems_after = end() - __position;
                	      pointer __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					  __old_finish - __n, __old_finish);
                		  std::fill(__position.base(), __position.base() + __n,
                			    __x_copy);
                		}
                	      else
                		{
                		  this->_M_impl._M_finish =
                		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						  __n - __elems_after,
                						  __x_copy,
                						  _M_get_Tp_allocator());
                		  std::__uninitialized_move_a(__position.base(), __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  std::fill(__position.base(), __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_fill_insert");
                	      const size_type __elems_before = __position - begin();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  // See _M_insert_aux above.
                		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                						__n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish = pointer();
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, __position.base(),
                		     __new_start, _M_get_Tp_allocator());
                
                		  __new_finish += __n;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (__position.base(), this->_M_impl._M_finish,
                		     __new_finish, _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  if (!__new_finish)
                		    std::_Destroy(__new_start + __elems_before,
                				  __new_start + __elems_before + __n,
                				  _M_get_Tp_allocator());
                		  else
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                	      this->_M_impl._M_finish =
                		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                						 __n, _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_default_append");
                	      const size_type __old_size = this->size();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, this->_M_impl._M_finish,
                		     __new_start, _M_get_Tp_allocator());
                		  __new_finish =
                		    std::__uninitialized_default_n_a(__new_finish, __n,
                						     _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  std::_Destroy(__new_start, __new_finish,
                				_M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    bool
                    vector<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() == size())
                	return false;
                      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                    }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __pos, _InputIterator __first,
                		      _InputIterator __last, std::input_iterator_tag)
                      {
                	for (; __first != __last; ++__first)
                	  {
                	    __pos = insert(__pos, *__first);
                	    ++__pos;
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		pointer __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					    __old_finish - __n, __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    std::__uninitialized_move_a(__position.base(),
                						__old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector::_M_range_insert");
                		pointer __new_start(this->_M_allocate(__len));
                		pointer __new_finish(__new_start);
                		__try
                		  {
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (this->_M_impl._M_start, __position.base(),
                		       __new_start, _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_copy_a(__first, __last,
                						    __new_finish,
                						    _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (__position.base(), this->_M_impl._M_finish,
                		       __new_finish, _M_get_Tp_allocator());
                		  }
                		__catch(...)
                		  {
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start, __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start;
                		this->_M_impl._M_finish = __new_finish;
                		this->_M_impl._M_end_of_storage = __new_start + __len;
                	      }
                	  }
                      }
                
                
                  // vector<bool>
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_reallocate(size_type __n)
                    {
                      _Bit_pointer __q = this->_M_allocate(__n);
                      iterator __start(std::__addressof(*__q), 0);
                      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), __start);
                      this->_M_deallocate();
                      this->_M_impl._M_start = __start;
                      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                    }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, bool __x)
                    {
                      if (__n == 0)
                	return;
                      if (capacity() - size() >= __n)
                	{
                	  std::copy_backward(__position, end(),
                			     this->_M_impl._M_finish + difference_type(__n));
                	  std::fill(__position, __position + difference_type(__n), __x);
                	  this->_M_impl._M_finish += difference_type(__n);
                	}
                      else
                	{
                	  const size_type __len = 
                	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  std::fill(__i, __i + difference_type(__n), __x);
                	  this->_M_impl._M_finish = std::copy(__position, end(),
                					      __i + difference_type(__n));
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	}
                    }
                
                  template<typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<bool, _Alloc>::
                      _M_insert_range(iterator __position, _ForwardIterator __first, 
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    size_type __n = std::distance(__first, __last);
                	    if (capacity() - size() >= __n)
                	      {
                		std::copy_backward(__position, end(),
                				   this->_M_impl._M_finish
                				   + difference_type(__n));
                		std::copy(__first, __last, __position);
                		this->_M_impl._M_finish += difference_type(__n);
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                		_Bit_pointer __q = this->_M_allocate(__len);
                		iterator __start(std::__addressof(*__q), 0);
                		iterator __i = _M_copy_aligned(begin(), __position, __start);
                		__i = std::copy(__first, __last, __i);
                		this->_M_impl._M_finish = std::copy(__position, end(), __i);
                		this->_M_deallocate();
                		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                		this->_M_impl._M_start = __start;
                	      }
                	  }
                      }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_insert_aux(iterator __position, bool __x)
                    {
                      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
                	{
                	  std::copy_backward(__position, this->_M_impl._M_finish, 
                			     this->_M_impl._M_finish + 1);
                	  *__position = __x;
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  *__i++ = __x;
                	  this->_M_impl._M_finish = std::copy(__position, end(), __i);
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	}
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                        std::copy(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      return __position;
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	_M_erase_at_end(std::copy(__last, end(), __first));
                      return __first;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    bool
                    vector<bool, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() - size() < int(_S_word_bit))
                	return false;
                      __try
                	{
                	  _M_reallocate(size());
                	  return true;
                	}
                      __catch(...)
                	{ return false; }
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc>
                    size_t
                    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                    {
                      size_t __hash = 0;
                      using _GLIBCXX_STD_C::_S_word_bit;
                      using _GLIBCXX_STD_C::_Bit_type;
                
                      const size_t __words = __b.size() / _S_word_bit;
                      if (__words)
                	{
                	  const size_t __clength = __words * sizeof(_Bit_type);
                	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                	}
                
                      const size_t __extrabits = __b.size() % _S_word_bit;
                      if (__extrabits)
                	{
                	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                
                	  const size_t __clength
                	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                	  if (__words)
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                	  else
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                	}
                
                      return __hash;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

       91       2287
      407        135
       65          8

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

     2430   Total number of line executions
   607.50   Average executions per line


*** File /usr/include/c++/5/bits/allocated_ptr.h:
                // Guarded Allocation -*- C++ -*-
                
                // Copyright (C) 2014-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/allocated_ptr.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATED_PTR_H
                #define _ALLOCATED_PTR_H 1
                
                #if __cplusplus < 201103L
                # include <bits/c++0xwarning.h>
                #else
                # include <type_traits>
                # include <bits/ptr_traits.h>
                # include <bits/alloc_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /// Non-standard RAII type for managing pointers obtained from allocators.
                  template<typename _Alloc>
                    struct __allocated_ptr
                    {
                      using pointer = typename allocator_traits<_Alloc>::pointer;
                      using value_type = typename allocator_traits<_Alloc>::value_type;
                
                      /// Take ownership of __ptr
         513 ->       __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
                      : _M_alloc(&__a), _M_ptr(__ptr)
                      { }
                
                      /// Convert __ptr to allocator's pointer type and take ownership of it
                      template<typename _Ptr,
                	       typename _Req = _Require<is_same<_Ptr, value_type*>>>
                      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
                      : _M_alloc(&__a), _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
                      { }
                
                      /// Transfer ownership of the owned pointer
                      __allocated_ptr(__allocated_ptr&& __gd) noexcept
                      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
                      { __gd._M_ptr = nullptr; }
                
                      /// Deallocate the owned pointer
         511 ->       ~__allocated_ptr()
                      {
                	if (_M_ptr != nullptr)
                	  std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
                      }
                
                      /// Release ownership of the owned pointer
                      __allocated_ptr&
         390 ->       operator=(std::nullptr_t) noexcept
                      {
                	_M_ptr = nullptr;
                	return *this;
                      }
                
                      /// Get the address that the owned pointer refers to.
         393 ->       value_type* get() { return _S_raw_ptr(_M_ptr); }
                
                    private:
         393 ->       value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }
                
                      template<typename _Ptr>
                	auto _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))
                	{ return _S_raw_ptr(__ptr.operator->()); }
                
                      _Alloc* _M_alloc;
                      pointer _M_ptr;
                    };
                
                  /// Allocate space for a single object using __a
                  template<typename _Alloc>
                    __allocated_ptr<_Alloc>
         392 ->     __allocate_guarded(_Alloc& __a)
                    {
                      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif
                #endif


Top 10 Lines:

     Line      Count

       52        513
       69        511
       84        393
       87        393
      100        392
       77        390

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

     2592   Total number of line executions
   432.00   Average executions per line


*** File /home/sbillah/dmclock/sim/../src/dmclock_client.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                #include <map>
                #include <deque>
                #include <chrono>
                #include <thread>
                #include <mutex>
                #include <condition_variable>
                
                #include "run_every.h"
                #include "dmclock_util.h"
                #include "dmclock_recs.h"
                
                #include "gtest/gtest_prod.h"
                
                
                namespace crimson {
                  namespace dmclock {
                    struct ServerInfo {
                      Counter   delta_prev_req;
                      Counter   rho_prev_req;
                      uint32_t  my_delta;
                      uint32_t  my_rho;
                
          79 ->       ServerInfo(Counter _delta_prev_req,
                		 Counter _rho_prev_req) :
                	delta_prev_req(_delta_prev_req),
                	rho_prev_req(_rho_prev_req),
                	my_delta(0),
                	my_rho(0)
                      {
                	// empty
                      }
                
        1732 ->       inline void req_update(Counter delta, Counter rho) {
                	delta_prev_req = delta;
                	rho_prev_req = rho;
                	my_delta = 0;
                	my_rho = 0;
                      }
                
        2600 ->       inline void resp_update(PhaseType phase) {
                	++my_delta;
                	if (phase == PhaseType::reservation) ++my_rho;
                      }
                    };
                
                
                    // S is server identifier type
                    template<typename S>
          10 ->     class ServiceTracker {
                      FRIEND_TEST(dmclock_client, server_erase);
                
                      using TimePoint = decltype(std::chrono::steady_clock::now());
                      using Duration = std::chrono::milliseconds;
                      using MarkPoint = std::pair<TimePoint,Counter>;
                
                      Counter                 delta_counter; // # reqs completed
                      Counter                 rho_counter;   // # reqs completed via reservation
                      std::map<S,ServerInfo>  server_map;
                      mutable std::mutex      data_mtx;      // protects Counters and map
                
                      using DataGuard = std::lock_guard<decltype(data_mtx)>;
                
                      // clean config
                
                      std::deque<MarkPoint>     clean_mark_points;
                      Duration                  clean_age;     // age at which ServerInfo cleaned
                
                      // NB: All threads declared at end, so they're destructed firs!
                
                      std::unique_ptr<RunEvery> cleaning_job;
                
                
                    public:
                
                      // we have to start the counters at 1, as 0 is used in the
                      // cleaning process
                      template<typename Rep, typename Per>
           5 ->       ServiceTracker(std::chrono::duration<Rep,Per> _clean_every,
                		     std::chrono::duration<Rep,Per> _clean_age) :
                	delta_counter(1),
                	rho_counter(1),
                	clean_age(std::chrono::duration_cast<Duration>(_clean_age))
                      {
                	cleaning_job =
                	  std::unique_ptr<RunEvery>(
                	    new RunEvery(_clean_every,
                			 std::bind(&ServiceTracker::do_clean, this)));
                      }
                
                
                      // the reason we're overloading the constructor rather than
                      // using default values for the arguments is so that callers
                      // have to either use all defaults or specify all timings; with
                      // default arguments they could specify some without others
           4 ->       ServiceTracker() :
                	ServiceTracker(std::chrono::minutes(5), std::chrono::minutes(10))
                      {
                	// empty
                      }
                
                
                      /*
                       * Incorporates the RespParams received into the various counter.
                       */
        2361 ->       void track_resp(const S& server_id, const PhaseType& phase) {
                	DataGuard g(data_mtx);
                
                	auto it = server_map.find(server_id);
                	if (server_map.end() == it) {
                	  // this code can only run if a request did not precede the
                	  // response or if the record was cleaned up b/w when
                	  // the request was made and now
                	  ServerInfo si(delta_counter, rho_counter);
                	  si.resp_update(phase);
                	  server_map.emplace(server_id, si);
                	} else {
                	  it->second.resp_update(phase);
                	}
                
                	++delta_counter;
                	if (PhaseType::reservation == phase) {
                	  ++rho_counter;
                	}
                      }
                
                
                      /*
                       * Returns the ReqParams for the given server.
                       */
        1800 ->       ReqParams get_req_params(const S& server) {
                	DataGuard g(data_mtx);
                	auto it = server_map.find(server);
                	if (server_map.end() == it) {
                	  server_map.emplace(server, ServerInfo(delta_counter, rho_counter));
                	  return ReqParams(1, 1);
                	} else {
                	  Counter delta =
                	    1 + delta_counter - it->second.delta_prev_req - it->second.my_delta;
                	  Counter rho =
                	    1 + rho_counter - it->second.rho_prev_req - it->second.my_rho;
                	  
                	  it->second.req_update(delta_counter, rho_counter);
                
                	  return ReqParams(uint32_t(delta), uint32_t(rho));
                	}
                      }
                
                    private:
                
                      /*
                       * This is being called regularly by RunEvery. Every time it's
                       * called it notes the time and delta counter (mark point) in a
                       * deque. It also looks at the deque to find the most recent
                       * mark point that is older than clean_age. It then walks the
                       * map and delete all server entries that were last used before
                       * that mark point.
                       */
       ##### ->       void do_clean() {
                	TimePoint now = std::chrono::steady_clock::now();
                	DataGuard g(data_mtx);
                	clean_mark_points.emplace_back(MarkPoint(now, delta_counter));
                
                	Counter earliest = 0;
                	auto point = clean_mark_points.front();
                	while (point.first <= now - clean_age) {
                	  earliest = point.second;
                	  clean_mark_points.pop_front();
                	  point = clean_mark_points.front();
                	}
                
                	if (earliest > 0) {
                	  for (auto i = server_map.begin();
                	       i != server_map.end();
                	       /* empty */) {
                	    auto i2 = i++;
                	    if (i2->second.delta_prev_req <= earliest) {
                	      server_map.erase(i2);
                	    }
                	  }
                	}
                      } // do_clean
                    }; // class ServiceTracker
                  }
                }


Top 10 Lines:

     Line      Count

       50       2600
      115       2361
      140       1800
       43       1732
       33         79
       59         10
       88          5
      105          4

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

     8591   Total number of line executions
   954.56   Average executions per line


*** File /home/sbillah/dmclock/sim/../src/dmclock_server.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                /*
                 * The prop_heap does not seem to be necessary. The only thing it
                 * would help with is quickly finding the mininum proportion/prioity
                 * when an idle client became active
                 */
                // #define USE_PROP_HEAP
                
                #pragma once
                
                
                #include <assert.h>
                
                #include <cmath>
                #include <memory>
                #include <map>
                #include <deque>
                #include <queue>
                #include <atomic>
                #include <mutex>
                #include <condition_variable>
                #include <thread>
                #include <iostream>
                #include <limits>
                
                #include <boost/variant.hpp>
                
                #include "indirect_intrusive_heap.h"
                #include "run_every.h"
                #include "dmclock_util.h"
                #include "dmclock_recs.h"
                
                #ifdef PROFILE
                #include "profile.h"
                #endif
                
                #include "gtest/gtest_prod.h"
                
                
                namespace crimson {
                
                  namespace dmclock {
                
                    namespace c = crimson;
                
                    constexpr double max_tag = std::numeric_limits<double>::max();
                    constexpr double min_tag = std::numeric_limits<double>::lowest();
                
                    struct ClientInfo {
                      const double reservation;  // minimum
                      const double weight;       // proportional
                      const double limit;        // maximum
                
                      // multiplicative inverses of above, which we use in calculations
                      // and don't want to recalculate repeatedly
                      const double reservation_inv;
                      const double weight_inv;
                      const double limit_inv;
                
                      // order parameters -- min, "normal", max
           1 ->       ClientInfo(double _reservation, double _weight, double _limit) :
                	reservation(_reservation),
                	weight(_weight),
                	limit(_limit),
                	reservation_inv(0.0 == reservation ? 0.0 : 1.0 / reservation),
                	weight_inv(     0.0 == weight      ? 0.0 : 1.0 / weight),
                	limit_inv(      0.0 == limit       ? 0.0 : 1.0 / limit)
                      {
                	// empty
                      }
                
                
                      friend std::ostream& operator<<(std::ostream& out,
                				      const ClientInfo& client) {
                	out <<
                	  "{ r:" << client.reservation <<
                	  " w:" << client.weight <<
                	  " l:" << client.limit <<
                	  " 1/r:" << client.reservation_inv <<
                	  " 1/w:" << client.weight_inv <<
                	  " 1/l:" << client.limit_inv <<
                	  " }";
                	return out;
                      }
                    }; // class ClientInfo
                
                
                    std::ostream& operator<<(std::ostream& out,
                			     const crimson::dmclock::ClientInfo& client);
                
                    struct RequestTag {
                      double reservation;
                      double proportion;
                      double limit;
                      bool   ready; // true when within limit
                
        2055 ->       RequestTag(const RequestTag& prev_tag,
                		 const ClientInfo& client,
                		 const ReqParams& req_params,
                		 const Time& time,
                		 const double cost = 0.0) :
                	reservation(cost + tag_calc(time,
                				    prev_tag.reservation,
                				    client.reservation_inv,
                				    req_params.rho,
                				    true)),
                	proportion(tag_calc(time,
                			    prev_tag.proportion,
                			    client.weight_inv,
                			    req_params.delta,
                			    true)),
                	limit(tag_calc(time,
                		       prev_tag.limit,
                		       client.limit_inv,
                		       req_params.delta,
                		       false)),
                	ready(false)
                      {
                	assert(reservation < max_tag || proportion < max_tag);
                      }
                
          78 ->       RequestTag(double _res, double _prop, double _lim) :
                	reservation(_res),
                	proportion(_prop),
                	limit(_lim),
                	ready(false)
                      {
                	assert(reservation < max_tag || proportion < max_tag);
                      }
                
        3889 ->       RequestTag(const RequestTag& other) :
                	reservation(other.reservation),
                	proportion(other.proportion),
                	limit(other.limit),
                	ready(other.ready)
                      {
                	// empty
                      }
                
                    private:
                
        5733 ->       static double tag_calc(const Time& time,
                			     double prev,
                			     double increment,
                			     uint32_t dist_req_val,
                			     bool extreme_is_high) {
                	if (0.0 == increment) {
                	  return extreme_is_high ? max_tag : min_tag;
                	} else {
                	  if (0 != dist_req_val) {
                	    increment *= dist_req_val;
                	  }
                	  return std::max(time, prev + increment);
                	}
                      }
                
                      friend std::ostream& operator<<(std::ostream& out,
                				      const RequestTag& tag) {
                	out <<
                	  "{ r:" << format_time(tag.reservation) <<
                	  " p:" << format_time(tag.proportion) <<
                	  " l:" << format_time(tag.limit) << " }";
                	return out;
                      }
                    }; // class RequestTag
                
                
                    std::ostream& operator<<(std::ostream& out,
                			     const crimson::dmclock::RequestTag& tag);
                
                
                    // C is client identifier type, R is request type
                    template<typename C, typename R>
                    class PriorityQueueBase {
                      FRIEND_TEST(dmclock_server, client_idle_erase);
                      FRIEND_TEST(dmclock_server, test_iiv);
                
                    public:
                
                      using RequestRef = std::unique_ptr<R>;
                
                    protected:
                
                      using TimePoint = decltype(std::chrono::steady_clock::now());
                      using Duration = std::chrono::milliseconds;
                      using MarkPoint = std::pair<TimePoint,Counter>;
                
                      enum class ReadyOption {ignore, lowers, raises};
                
                      // forward decl for friend decls
                      template<double RequestTag::*, ReadyOption, bool>
                      struct ClientCompare;
                
        6333 ->       class ClientReq {
                	friend PriorityQueueBase;
                
                	RequestTag tag;
                	C          client_id;
                	RequestRef request;
                
                      public:
                
        1941 -> 	ClientReq(const RequestTag& _tag,
                		  const C&          _client_id,
                		  RequestRef&&      _request) :
                	  tag(_tag),
                	  client_id(_client_id),
                	  request(std::move(_request))
                	{
                	  // empty
                	}
                
                	friend std::ostream& operator<<(std::ostream& out, const ClientReq& c) {
                	  out << c.tag;
                	  return out;
                	}
                      }; // class ClientReq
                
                
       ##### ->       class ClientRec {
                	friend PriorityQueueBase<C,R>;
                
                	C                     client;
                	RequestTag            prev_tag;
                	std::deque<ClientReq> requests;
                
                	// amount added from the proportion tag as a result of
                	// an idle client becoming unidle
                	double                prop_delta = 0.0;
                
                	c::IndIntruHeapData   reserv_heap_data;
                	c::IndIntruHeapData   lim_heap_data;
                	c::IndIntruHeapData   ready_heap_data;
                
                	// index in look_up vector
                	c::IndIntruHeapData   lookup_vector_data;
                #if USE_PROP_HEAP
                	c::IndIntruHeapData   prop_heap_data;
                #endif
                
                      public:
                
                	ClientInfo            info;
                	bool                  idle;
                	Counter               last_tick;
                
          86 -> 	ClientRec(C _client,
                		  const ClientInfo& _info,
                		  Counter current_tick) :
                	  client(_client),
                	  prev_tag(0.0, 0.0, 0.0),
                	  info(_info),
                	  idle(true),
                	  last_tick(current_tick)
                	{
                	  // empty
                	}
                
        1939 -> 	inline const RequestTag& get_req_tag() const {
                	  return prev_tag;
                	}
                
        2044 -> 	inline void update_req_tag(const RequestTag& _prev,
                				   const Counter& _tick) {
                	  prev_tag = _prev;
                	  last_tick = _tick;
                	}
                
                	inline double get_prev_prop_tag() const {
                	  return prev_tag.proportion;
                	}
                
                	inline void set_prev_prop_tag(double value,
                				      bool adjust_by_inc = false) {
                	  prev_tag.proportion = value - (adjust_by_inc ? info.weight_inv : 0.0);
                	}
                
        1974 -> 	inline void add_request(const RequestTag& tag,
                				const C&          client_id,
                				RequestRef&&      request) {
                	  requests.emplace_back(ClientReq(tag, client_id, std::move(request)));
                	}
                
       ##### -> 	inline const ClientReq& next_request() const {
                	  return requests.front();
                	}
                
       11449 -> 	inline ClientReq& next_request() {
                	  return requests.front();
                	}
                
        2225 -> 	inline void pop_request() {
                	  requests.pop_front();
                	}
                
       21263 -> 	inline bool has_request() const {
                	  return !requests.empty();
                	}
                
                	inline size_t request_count() const {
                	  return requests.size();
                	}
                
                	// NB: because a deque is the underlying structure, this
                	// operation might be expensive
                	template<typename Collect>
                	bool remove_by_req_filter_forwards(std::function<bool(const R&)> filter,
                					   Collect& out) {
                	  bool any_removed = false;
                	  for (auto i = requests.begin();
                	       i != requests.end();
                	       /* no inc */) {
                	    if (filter(*i->request)) {
                	      any_removed = true;
                	      out.push_back(*i->request);
                	      i = requests.erase(i);
                	    } else {
                	      ++i;
                	    }
                	  }
                	  return any_removed;
                	}
                
                	// NB: because a deque is the underlying structure, this
                	// operation might be expensive
                	template<typename Collect>
                	bool remove_by_req_filter_backwards(std::function<bool(const R&)> filter,
                					    Collect& out) {
                	  bool any_removed = false;
                	  for (auto i = --requests.end();
                	       /* no cond */;
                	       --i) {
                	    if (filter(*i->request)) {
                	      any_removed = true;
                	      out.push_back(*i->request);
                	      i = requests.erase(i);
                	    }
                	    if (requests.begin() == i) break;
                	  }
                	  return any_removed;
                	}
                
                	template<typename Collect>
                	inline bool remove_by_req_filter(std::function<bool(const R&)> filter,
                					 Collect& out,
                					 bool visit_backwards) {
                	  if (visit_backwards) {
                	    return remove_by_req_filter_backwards(filter, out);
                	  } else {
                	    return remove_by_req_filter_forwards(filter, out);
                	  }
                	}
                	
                	friend std::ostream&
                	operator<<(std::ostream& out,
                		   const typename PriorityQueueBase<C,R>::ClientRec& e) {
                	  out << "{ client:" << e.client << " top req: " <<
                	    (e.has_request() ? e.next_request() : "none") << " }";
                	  return out;
                	}
                      }; // class ClientRec
                
                
                      using ClientRecRef = std::shared_ptr<ClientRec>;
                
                
                      // Indirect Intrusive Vector Data Structure
                      using IndIntruVectorData = size_t;
                
                      template<typename I, typename T, IndIntruVectorData T::*index_info,
                	template < double RequestTag::*, ReadyOption, bool > class Cmp>
       ##### ->       class IndIntruVector {
                	friend PriorityQueueBase;
                
                	static_assert(
                	  std::is_same<T,typename std::pointer_traits<I>::element_type>::value,
                	  "class I must resolve to class T by indirection (pointer dereference)");
                
                	Cmp<&RequestTag::reservation,
                	    ReadyOption::ignore,
                	    false >              cmp_resv;
                
                //	static_assert(
                //	  std::is_same< bool,
                //	  typename std::result_of<Cmp(const T&, const T&)>::type >::value,
                //	  "class Cmp must define operator() to take two const T& and return a bool");
                
                	Cmp<&RequestTag::proportion,
                	    ReadyOption::raises,
                	    true >               cmp_ready;
                
                	Cmp<&RequestTag::limit,
                	    ReadyOption::lowers,
                	    false >              cmp_limit;
                
                      protected:
                	using index_t = IndIntruVectorData;
                	std::vector<I>           data;
                	index_t                  count;
                	const index_t            top_default;
                
                      public:
                	index_t                  resv;
                	index_t                  ready;
                	index_t                  limit;
                
                
         100 -> 	IndIntruVector() :
                	  count(0),
                	  top_default(0),
                	  resv(0),
                	  ready(0),
                	  limit(0)
                	{
                	  // empty
                	}
                
                	IndIntruVector(const IndIntruVector < I , T, index_info , Cmp > &other) :
                	  count(other.count),
                	  top_default(0),
                	  resv(other.resv),
                	  ready(other.ready),
                	  limit(other.limit)
                	{
                	  for (uint i = 0; i < other.count; ++i) {
                	    data.push_back(other.data[i]);
                	  }
                	}
                
        4845 -> 	bool empty() const { return 0 == count; }
                
                	size_t size() const { return count; }
                
       19238 -> 	T& top(index_t IndIntruVector::*which_top) {
                	  return *data[this->*which_top];
                	}
                
                	const T& top(index_t IndIntruVector::*which_top) const {
                	  return *data[this->*which_top];
                	}
                
                	I& top_ind(index_t IndIntruVector::*which_top) {
                	  return data[this->*which_top];
                	}
                
                	const I& top_ind(index_t IndIntruVector::*which_top) const {
                	  return data[this->*which_top];
                	}
                
          78 -> 	void push(I&& item) {
                	  index_t i = count++;
                	  index_of(item) = i;
                	  data.emplace_back(std::move(item));
                	  adjust();
                	}
                
          79 -> 	void push(const I& item) {
                	  I copy(item);
                	  push(std::move(copy));
                	}
                
                	void pop(index_t IndIntruVector::*where) {
                	  remove(this->*where);
                	}
                
                	void pop() {
                	  pop(&IndIntruVector::top_default);
                	}
                	// use native loop to update 3 tops in one sweep
        7451 -> 	void adjust() {
                	  resv = ready = limit = 0;
                
                	  for (index_t i = 1 ; i < count; i++){
                	    if (cmp_resv(*data[i], *data[resv])){
                	      resv = i;
                	    }
                
                	    if (cmp_ready(*data[i], *data[ready])){
                	      ready = i;
                	    }
                
                	    if (cmp_limit(*data[i], *data[limit])){
                	      limit = i;
                	    }
                	  }
                	}
                
       ##### -> 	void remove(const I& item) {
                	  index_t i = (*item).*index_info;
                	  if (i < count) {
                	    remove(i);
                	  }
                	}
                
                	friend std::ostream& operator<<(std::ostream& out, const IndIntruVector& h) {
                	  bool first = true;
                	  for (index_t i = 0 ; i < h.count ; i++){
                	    if(!first){
                	      out << ", ";
                	    }
                	    out << h.data[i] << " (" << i << ") ";
                	    first = false;
                	  }
                	  return out;
                	}
                
                      protected:
                
          84 -> 	static index_t& index_of(I& item) {
                	  return (*item).*index_info;
                	}
                
       ##### -> 	void remove(index_t i) {
                	  std::swap(data[i], data[--count]);
                	  index_of(data[i]) = i;
                	  data.pop_back();
                	  adjust();
                	}
                
                      }; // class IntruIndirectVector
                
                      // IndIntruVector based ClientRec data-structure
                      using iiv = IndIntruVector<ClientRecRef,
                				 ClientRec,
                				 &ClientRec::lookup_vector_data,
                				 ClientCompare>;
                      iiv                        cl_vec;
                
                
                    public:
                      // when we try to get the next request, we'll be in one of three
                      // situations -- we'll have one to return, have one that can
                      // fire in the future, or not have any
                      enum class NextReqType { returning, future, none };
                
                      // specifies which queue next request will get popped from
                      enum class HeapId { reservation, ready
                #if USE_PROP_HEAP
                	  , proportional
                #endif
                	  };
                
                
                      // this is returned from next_req to tell the caller the situation
                      struct NextReq {
                	NextReqType type;
                	union {
                	  HeapId    heap_id;
                	  Time      when_ready;
                	};
                      };
                
                
                      // a function that can be called to look up client information
                      using ClientInfoFunc = std::function<ClientInfo(const C&)>;
                
                
                      bool empty() const {
                	DataGuard g(data_mtx);
                	if (use_heap) {
                	  return (resv_heap.empty() || !resv_heap.top().has_request());
                	} else {
                	  return (cl_vec.empty() || !cl_vec.top(&iiv::resv).has_request());
                	}
                      }
                
                      size_t client_count() const {
                	DataGuard g(data_mtx);
                	if (use_heap) {
                	  return resv_heap.size();
                	} else {
                	  return cl_vec.size();
                	}
                      }
                
                      size_t request_count() const {
                	DataGuard g(data_mtx);
                	size_t total = 0;
                	if (use_heap) {
                	  for (auto i = resv_heap.cbegin(); i != resv_heap.cend(); ++i) {
                	    total += i->request_count();
                	  }
                	} else {
                	  for ( auto i = 0 ; i < cl_vec.count ; i++) {
                	    total += cl_vec.data[i]->request_count();
                	  }
                	}
                	return total;
                      }
                
                
                      bool remove_by_req_filter(std::function<bool(const R&)> filter,
                				bool visit_backwards = false) {
                	struct Sink {
                	  void push_back(const R& v) {} // do nothing
                	};
                	static Sink my_sink;
                	return remove_by_req_filter(filter, my_sink, visit_backwards);
                      }
                
                      
                      template<typename Collect>
                      bool remove_by_req_filter(std::function<bool(const R&)> filter,
                				Collect& out,
                				bool visit_backwards = false) {
                	bool any_removed = false;
                	DataGuard g(data_mtx);
                	for (auto i : client_map) {
                	  bool modified =
                	    i.second->remove_by_req_filter(filter, out, visit_backwards);
                	  if (modified) {
                	    if (use_heap) {
                	      resv_heap.adjust(*i.second);
                	      limit_heap.adjust(*i.second);
                	      ready_heap.adjust(*i.second);
                #if USE_PROP_HEAP
                	      resv_heap.adjust(*i.second);
                #endif
                	    } else {
                	      cl_vec.adjust();
                	    }
                	    any_removed = true;
                	  }
                	}
                	return any_removed;
                      }
                
                
                      void remove_by_client(const C& client) {
                	struct Sink {
                	  void push_back(const R& v) {}
                	};
                	static Sink my_sink;
                	remove_by_client(client, my_sink);
                      }
                
                
                      // Collect must support calls to push_back(R), such as
                      // std::list<R>.
                      template<typename Collect>
                      void remove_by_client(const C& client, Collect& out) {
                	DataGuard g(data_mtx);
                
                	auto i = client_map.find(client);
                
                	if (i == client_map.end()) return;
                
                	for (auto j = i->second->requests.begin();
                	     j != i->second->requests.end();
                	     ++j) {
                	  out.push_back(*j->request);
                	}
                
                	i->second->requests.clear();
                
                	if (use_heap) {
                	  resv_heap.adjust(*i->second);
                	  limit_heap.adjust(*i->second);
                	  ready_heap.adjust(*i->second);
                #if USE_PROP_HEAP
                	  resv_heap.adjust(*i->second);
                #endif
                	} else {
                	  cl_vec.adjust();
                	}
                      }
                
                
                    protected:
                
                      // The ClientCompare functor is essentially doing a precedes?
                      // operator, returning true if and only if the first parameter
                      // must precede the second parameter. If the second must precede
                      // the first, or if they are equivalent, false should be
                      // returned. The reason for this behavior is that it will be
                      // called to test if two items are out of order and if true is
                      // returned it will reverse the items. Therefore false is the
                      // default return when it doesn't matter to prevent unnecessary
                      // re-ordering.
                      //
                      // The template is supporting variations in sorting based on the
                      // heap in question and allowing these variations to be handled
                      // at compile-time.
                      //
                      // tag_field determines which tag is being used for comparison
                      //
                      // ready_opt determines how the ready flag influences the sort
                      //
                      // use_prop_delta determines whether the proportional delta is
                      // added in for comparison
                      template<double RequestTag::*tag_field,
                	       ReadyOption ready_opt,
                	       bool use_prop_delta>
                      struct ClientCompare {
       ##### -> 	bool operator()(const ClientRec& n1, const ClientRec& n2) const {
                	  if (n1.has_request()) {
                	    if (n2.has_request()) {
                	      const auto& t1 = n1.next_request().tag;
                	      const auto& t2 = n2.next_request().tag;
                	      if (ReadyOption::ignore == ready_opt || t1.ready == t2.ready) {
                		// if we don't care about ready or the ready values are the same
                		if (use_prop_delta) {
                		  return (t1.*tag_field + n1.prop_delta) <
                		    (t2.*tag_field + n2.prop_delta);
                		} else {
                		  return t1.*tag_field < t2.*tag_field;
                		}
                	      } else if (ReadyOption::raises == ready_opt) {
                		// use_ready == true && the ready fields are different
                		return t1.ready;
                	      } else {
                		return t2.ready;
                	      }
                	    } else {
                	      // n1 has request but n2 does not
                	      return true;
                	    }
                	  } else if (n2.has_request()) {
                	    // n2 has request but n1 does not
                	    return false;
                	  } else {
                	    // both have none; keep stable w false
                	    return false;
                	  }
                	}
                      };
                
                      ClientInfoFunc       client_info_f;
                
                      mutable std::mutex data_mtx;
                      using DataGuard = std::lock_guard<decltype(data_mtx)>;
                
                      // stable mapping between client ids and client queues
                      std::map<C,ClientRecRef> client_map;
                
                
                      c::IndIntruHeap<ClientRecRef,
                		      ClientRec,
                		      &ClientRec::reserv_heap_data,
                		      ClientCompare<&RequestTag::reservation,
                				    ReadyOption::ignore,
                				    false>> resv_heap;
                #if USE_PROP_HEAP
                      c::IndIntruHeap<ClientRecRef,
                		      ClientRec,
                		      &ClientRec::prop_heap_data,
                		      ClientCompare<&RequestTag::proportion,
                				    ReadyOption::ignore,
                				    true>> prop_heap;
                #endif
                      c::IndIntruHeap<ClientRecRef,
                		      ClientRec,
                		      &ClientRec::lim_heap_data,
                		      ClientCompare<&RequestTag::limit,
                				    ReadyOption::lowers,
                				    false>> limit_heap;
                      c::IndIntruHeap<ClientRecRef,
                		      ClientRec,
                		      &ClientRec::ready_heap_data,
                		      ClientCompare<&RequestTag::proportion,
                				    ReadyOption::raises,
                				    true>> ready_heap;
                
                
                
                      // if all reservations are met and all other requests are under
                      // limit, this will allow the request next in terms of
                      // proportion to still get issued
                      bool                       allow_limit_break;
                
                      std::atomic_bool           finishing;
                
                      // every request creates a tick
                      Counter tick = 0;
                
                      // performance data collection
                      size_t                    reserv_sched_count = 0;
                      size_t                    prop_sched_count = 0;
                      size_t                    limit_break_sched_count = 0;
                
                      Duration                  idle_age;
                      Duration                  erase_age;
                      Duration                  check_time;
                      std::deque<MarkPoint>     clean_mark_points;
                
                      // switching thresholds for IndIntruVector & IndIntruHeap
                      size_t                    cutoff_for_iiv;
                      size_t                    cutoff_for_iih;
                      bool                      use_heap;
                
                      // NB: All threads declared at end, so they're destructed first!
                      std::unique_ptr<RunEvery> cleaning_job;
                
                
                    public:
                      // COMMON constructor that others feed into; we can accept three
                      // different variations of durations
                      template<typename Rep, typename Per>
         100 ->       PriorityQueueBase(ClientInfoFunc _client_info_f,
                			std::chrono::duration<Rep,Per> _idle_age,
                			std::chrono::duration<Rep,Per> _erase_age,
                			std::chrono::duration<Rep,Per> _check_time,
                			bool _allow_limit_break) :
                	client_info_f(_client_info_f),
                	allow_limit_break(_allow_limit_break),
                	finishing(false),
                	idle_age(std::chrono::duration_cast<Duration>(_idle_age)),
                	erase_age(std::chrono::duration_cast<Duration>(_erase_age)),
                	check_time(std::chrono::duration_cast<Duration>(_check_time)),
                	cutoff_for_iiv(100),
                	cutoff_for_iih(1000),
                	use_heap(false)
                      {
                	assert(_erase_age >= _idle_age);
                	assert(_check_time < _idle_age);
                	cleaning_job =
                	  std::unique_ptr<RunEvery>(
                	    new RunEvery(check_time,
                			 std::bind(&PriorityQueueBase::do_clean, this)));
                      }
                
                
       ##### ->       ~PriorityQueueBase() {
                	finishing = true;
                      }
                
                
                      // data_mtx must be held by caller
        2218 ->       void do_add_request(RequestRef&&     request,
                			  const C&         client_id,
                			  const ReqParams& req_params,
                			  const Time       time,
                			  const double     cost = 0.0) {
                	++tick;
                
                	// this pointer will help us create a reference to a shared
                	// pointer, no matter which of two codepaths we take
                	ClientRec* temp_client;
                	
                	auto client_it = client_map.find(client_id);
                	if (client_map.end() != client_it) {
                	  temp_client = &(*client_it->second); // address of obj of shared_ptr
                	} else {
                	  ClientInfo info = client_info_f(client_id);
                	  ClientRecRef client_rec =
                	    std::make_shared<ClientRec>(client_id, info, tick);
                
                	  // make a decision which data-structure to use -- need more thoughts
                #if 0
                	  if (cutoff_for_iiv > client_map.size()) {
                	    use_heap = true;
                	  } else {
                	    use_heap = false;
                	  }
                #endif
                
                
                
                	  if (use_heap) {
                	    resv_heap.push(client_rec);
                #if USE_PROP_HEAP
                	    prop_heap.push(client_rec);
                #endif
                	    limit_heap.push(client_rec);
                	    ready_heap.push(client_rec);
                	  } else {
                	    cl_vec.push(client_rec);
                	  }
                
                	  client_map[client_id] = client_rec;
                	  temp_client = &(*client_rec); // address of obj of shared_ptr
                	}
                
                	// for convenience, we'll create a reference to the shared pointer
                	ClientRec& client = *temp_client;
                
                	if (client.idle) {
                	  // We need to do an adjustment so that idle clients compete
                	  // fairly on proportional tags since those tags may have
                	  // drifted from real-time. Either use the lowest existing
                	  // proportion tag -- O(1) -- or the client with the lowest
                	  // previous proportion tag -- O(n) where n = # clients.
                	  //
                	  // So we don't have to maintain a proportional queue that
                	  // keeps the minimum on proportional tag alone (we're
                	  // instead using a ready queue), we'll have to check each
                	  // client.
                	  //
                	  // The alternative would be to maintain a proportional queue
                	  // (define USE_PROP_TAG) and do an O(1) operation here.
                	  double lowest_prop_tag = NaN; // mark unset value as NaN
                	  for (auto const &c : client_map) {
                	    // don't use ourselves (or anything else that might be
                	    // listed as idle) since we're now in the map
                	    if (!c.second->idle) {
                	      // use either lowest proportion tag or previous proportion tag
                	      if (c.second->has_request()) {
                		double p = c.second->next_request().tag.proportion +
                		  c.second->prop_delta;
                		if (std::isnan(lowest_prop_tag) || p < lowest_prop_tag) {
                		  lowest_prop_tag = p;
                		}
                	      }
                	    }
                	  }
                	  if (!std::isnan(lowest_prop_tag)) {
                	    client.prop_delta = lowest_prop_tag - time;
                	  }
                	  client.idle = false;
                	} // if this client was idle
                
                	RequestTag tag(client.get_req_tag(), client.info, req_params, time, cost);
                	client.add_request(tag, client.client, std::move(request));
                
                	// copy tag to previous tag for client
                	client.update_req_tag(tag, tick);
                
                	if (use_heap) {
                	  resv_heap.adjust(client);
                	  limit_heap.adjust(client);
                	  ready_heap.adjust(client);
                #if USE_PROP_HEAP
                	  prop_heap.adjust(client);
                #endif
                	} else {
                	  cl_vec.adjust();
                	}
                      } // add_request
                
                
                      // data_mtx should be held when called; top of heap should have
                      // a ready request
                      template<typename C1, IndIntruHeapData ClientRec::*C2, typename C3>
       ##### ->       void pop_process_request(IndIntruHeap<C1, ClientRec, C2, C3>& heap,
                			       std::function<void(const C& client,
                						  RequestRef& request)> process) {
                	// gain access to data
                	ClientRec& top = heap.top();
                	ClientReq& first = top.next_request();
                	RequestRef request = std::move(first.request);
                
                	// pop request and adjust heaps
                	top.pop_request();
                	resv_heap.demote(top);
                	limit_heap.demote(top);
                #if USE_PROP_HEAP
                	prop_heap.demote(top);
                #endif
                	ready_heap.demote(top);
                
                	// process
                	process(top.client, request);
                      } // pop_process_request
                
                      // iiv version
        2225 ->       void pop_process_request(size_t iiv::* which_tag,
                			       std::function<void(const C& client,
                						  RequestRef& request)> process) {
                	// gain access to data
                	ClientRec& top = cl_vec.top(which_tag);
                	ClientReq& first = top.next_request();
                	RequestRef request = std::move(first.request);
                
                	// pop request and adjust vector
                	top.pop_request();
                	cl_vec.adjust();
                
                	// process
                	process(top.client, request);
                      } // pop_process_request
                
                      // for debugging
                      void display_queues(bool show_res = true,
                			  bool show_lim = true,
                			  bool show_ready = true,
                			  bool show_prop = true) {
                	auto filter = [](const ClientRecRef& e)->bool { return !e->handled; };
                	if (use_heap){
                	  if (show_res) {
                	    resv_heap.display_sorted(std::cout << "RESER:", filter) << std::endl;
                	  }
                	  if (show_lim) {
                	    limit_heap.display_sorted(std::cout << "LIMIT:", filter) << std::endl;
                	  }
                	  if (show_ready) {
                	    ready_heap.display_sorted(std::cout << "READY:", filter) << std::endl;
                	  }
                #if USE_PROP_HEAP
                	  if (show_prop) {
                	    prop_heap.display_sorted(std::cout << "PROPO:", filter) << std::endl;
                	  }
                #endif
                	} else {
                	  std::cout << cl_vec << std::endl;
                	}
                      } // display_queues
                
                
                      // data_mtx should be held when called
        1622 ->       void reduce_reservation_tags(ClientRec& client) {
                	for (auto& r : client.requests) {
                	  r.tag.reservation -= client.info.reservation_inv;
                	}
                	// don't forget to update previous tag
                	client.prev_tag.reservation -= client.info.reservation_inv;
                	if (use_heap) {
                	  resv_heap.promote(client);
                	} else {
                	  cl_vec.adjust();
                	}
                      }
                
                
                      // data_mtx should be held when called
        1770 ->       void reduce_reservation_tags(const C& client_id) {
                	auto client_it = client_map.find(client_id);
                
                	// means the client was cleaned from map; should never happen
                	// as long as cleaning times are long enough
                	assert(client_map.end() != client_it);
                	reduce_reservation_tags(*client_it->second);
                      }
                
                
                      // data_mtx should be held when called
        4463 ->       NextReq do_next_request(Time now) {
                	NextReq result;
                
                	// if resv_heap or client_vec is empty, all are empty (i.e., no active clients)
                	if((use_heap && resv_heap.empty()) ||
                	  (!use_heap && cl_vec.empty())) {
                	  result.type = NextReqType::none;
                	  return result;
                	}
                
                	// try constraint (reservation) based scheduling
                	auto& reserv = use_heap ? resv_heap.top() : cl_vec.top(&iiv::resv);
                	if (reserv.has_request() &&
                	    reserv.next_request().tag.reservation <= now) {
                	  result.type = NextReqType::returning;
                	  result.heap_id = HeapId::reservation;
                	  return result;
                	}
                
                	// no existing reservations before now, so try weight-based
                	// scheduling
                
                	// all items that are within limit are eligible based on
                	// priority
                	auto limits = use_heap ? &limit_heap.top() : &cl_vec.top(&iiv::limit);
                	while (limits->has_request() &&
                	       !limits->next_request().tag.ready &&
                	       limits->next_request().tag.limit <= now) {
                	  limits->next_request().tag.ready = true;
                	  if (use_heap) {
                	    ready_heap.promote(*limits);
                	    limit_heap.demote(*limits);
                	  } else {
                	    cl_vec.adjust();
                	  }
                	  limits = use_heap ? &limit_heap.top() : &cl_vec.top(&iiv::limit);
                	}
                
                	auto& readys = use_heap ? ready_heap.top() : cl_vec.top (&iiv::ready);
                	if (readys.has_request() &&
                	    readys.next_request().tag.ready &&
                	    readys.next_request().tag.proportion < max_tag) {
                	  result.type = NextReqType::returning;
                	  result.heap_id = HeapId::ready;
                	  return result;
                	}
                
                	// if nothing is schedulable by reservation or
                	// proportion/weight, and if we allow limit break, try to
                	// schedule something with the lowest proportion tag or
                	// alternatively lowest reservation tag.
                	if (allow_limit_break) {
                	  if (readys.has_request() &&
                	      readys.next_request().tag.proportion < max_tag) {
                	    result.type = NextReqType::returning;
                	    result.heap_id = HeapId::ready;
                	    return result;
                	  } else if (reserv.has_request() &&
                		     reserv.next_request().tag.reservation < max_tag) {
                	    result.type = NextReqType::returning;
                	    result.heap_id = HeapId::reservation;
                	    return result;
                	  }
                	}
                
                	// nothing scheduled; make sure we re-run when next
                	// reservation item or next limited item comes up
                
                	Time next_call = TimeMax;
                	auto& r_top = use_heap ? resv_heap.top() : cl_vec.top(&iiv::resv);
                	if (r_top.has_request()) {
                	  next_call =
                	    min_not_0_time(next_call,
                			   r_top.next_request().tag.reservation);
                	}
                
                	auto& l_top = use_heap ? limit_heap.top() : cl_vec.top(&iiv::limit);
                	if (l_top.has_request()) {
                	  const auto& next = l_top.next_request();
                	  assert(!next.tag.ready);
                	  next_call = min_not_0_time(next_call, next.tag.limit);
                	}
                
                	if (next_call < TimeMax) {
                	  result.type = NextReqType::future;
                	  result.when_ready = next_call;
                	  return result;
                	} else {
                	  result.type = NextReqType::none;
                	  return result;
                	}
                      } // schedule_request
                
                      // if possible is not zero and less than current then return it;
                      // otherwise return current; the idea is we're trying to find
                      // the minimal time but ignoring zero
       ##### ->       static inline const Time& min_not_0_time(const Time& current,
                					       const Time& possible) {
                	return TimeZero == possible ? current : std::min(current, possible);
                      }
                
                
                      /*
                       * This is being called regularly by RunEvery. Every time it's
                       * called it notes the time and delta counter (mark point) in a
                       * deque. It also looks at the deque to find the most recent
                       * mark point that is older than clean_age. It then walks the
                       * map and delete all server entries that were last used before
                       * that mark point.
                       */
       ##### ->       void do_clean() {
                	TimePoint now = std::chrono::steady_clock::now();
                	DataGuard g(data_mtx);
                	clean_mark_points.emplace_back(MarkPoint(now, tick));
                
                	// first erase the super-old client records
                
                	Counter erase_point = 0;
                	auto point = clean_mark_points.front();
                	while (point.first <= now - erase_age) {
                	  erase_point = point.second;
                	  clean_mark_points.pop_front();
                	  point = clean_mark_points.front();
                	}
                
                	Counter idle_point = 0;
                	for (auto i : clean_mark_points) {
                	  if (i.first <= now - idle_age) {
                	    idle_point = i.second;
                	  } else {
                	    break;
                	  }
                	}
                
                	if (erase_point > 0 || idle_point > 0) {
                	  for (auto i = client_map.begin(); i != client_map.end(); /* empty */) {
                	    auto i2 = i++;
                	    if (erase_point && i2->second->last_tick <= erase_point) {
                	      client_map.erase(i2);
                	      delete_from_heaps(i2->second);
                	    } else if (idle_point && i2->second->last_tick <= idle_point) {
                	      i2->second->idle = true;
                	    }
                	  } // for
                	} // if
                      } // do_clean
                
                
                      // data_mtx must be held by caller
                      template<IndIntruHeapData ClientRec::*C1,typename C2>
       ##### ->       void delete_from_heap(ClientRecRef& client,
                			    c::IndIntruHeap<ClientRecRef,ClientRec,C1,C2>& heap) {
                	auto i = heap.rfind(client);
                	heap.remove(i);
                      }
                
                
                      // data_mtx must be held by caller
       ##### ->       void delete_from_heaps(ClientRecRef& client) {
                	if (use_heap) {
                	  delete_from_heap(client, resv_heap);
                #if USE_PROP_HEAP
                	  delete_from_heap(client, prop_heap);
                #endif
                	  delete_from_heap(client, limit_heap);
                	  delete_from_heap(client, ready_heap);
                	} else {
                	  cl_vec.remove(client);
                	}
                      }
                    }; // class PriorityQueueBase
                
                
                    template<typename C, typename R>
                    class PullPriorityQueue : public PriorityQueueBase<C,R> {
                      using super = PriorityQueueBase<C,R>;
                
                    public:
                
                      // When a request is pulled, this is the return type.
                      struct PullReq {
                	struct Retn {
                	  C                           client;
                	  typename super::RequestRef  request;
                	  PhaseType                   phase;
                	};
                
                	typename super::NextReqType   type;
                	boost::variant<Retn,Time>     data;
                
                	bool is_none() const { return type == super::NextReqType::none; }
                
                	bool is_retn() const { return type == super::NextReqType::returning; }
                	Retn& get_retn() {
                	  return boost::get<Retn>(data);
                	}
                
                	bool is_future() const { return type == super::NextReqType::future; }
                	Time getTime() const { return boost::get<Time>(data); }
                      };
                
                
                #ifdef PROFILE
                      ProfileTimer<std::chrono::nanoseconds> pull_request_timer;
                      ProfileTimer<std::chrono::nanoseconds> add_request_timer;
                #endif
                
                      template<typename Rep, typename Per>
                      PullPriorityQueue(typename super::ClientInfoFunc _client_info_f,
                			std::chrono::duration<Rep,Per> _idle_age,
                			std::chrono::duration<Rep,Per> _erase_age,
                			std::chrono::duration<Rep,Per> _check_time,
                			bool _allow_limit_break = false) :
                	super(_client_info_f,
                	      _idle_age, _erase_age, _check_time,
                	      _allow_limit_break)
                      {
                	// empty
                      }
                
                
                      // pull convenience constructor
                      PullPriorityQueue(typename super::ClientInfoFunc _client_info_f,
                			bool _allow_limit_break = false) :
                	PullPriorityQueue(_client_info_f,
                			  std::chrono::minutes(10),
                			  std::chrono::minutes(15),
                			  std::chrono::minutes(6),
                			  _allow_limit_break)
                      {
                	// empty
                      }
                
                
                      inline void add_request(const R& request,
                			      const C& client_id,
                			      const ReqParams& req_params,
                			      double addl_cost = 0.0) {
                	add_request(typename super::RequestRef(new R(request)),
                		    client_id,
                		    req_params,
                		    get_time(),
                		    addl_cost);
                      }
                
                
                      inline void add_request(const R& request,
                			      const C& client_id,
                			      double addl_cost = 0.0) {
                	static const ReqParams null_req_params;
                	add_request(typename super::RequestRef(new R(request)),
                		    client_id,
                		    null_req_params,
                		    get_time(),
                		    addl_cost);
                      }
                
                
                
                      inline void add_request_time(const R& request,
                				   const C& client_id,
                				   const ReqParams& req_params,
                				   const Time time,
                				   double addl_cost = 0.0) {
                	add_request(typename super::RequestRef(new R(request)),
                		    client_id,
                		    req_params,
                		    time,
                		    addl_cost);
                      }
                
                
                      inline void add_request(typename super::RequestRef&& request,
                			      const C& client_id,
                			      const ReqParams& req_params,
                			      double addl_cost = 0.0) {
                	add_request(request, req_params, client_id, get_time(), addl_cost);
                      }
                
                
                      inline void add_request(typename super::RequestRef&& request,
                			      const C& client_id,
                			      double addl_cost = 0.0) {
                	static const ReqParams null_req_params;
                	add_request(request, null_req_params, client_id, get_time(), addl_cost);
                      }
                
                
                      // this does the work; the versions above provide alternate interfaces
                      void add_request(typename super::RequestRef&& request,
                		       const C&                     client_id,
                		       const ReqParams&             req_params,
                		       const Time                   time,
                		       double                       addl_cost = 0.0) {
                	typename super::DataGuard g(this->data_mtx);
                #ifdef PROFILE
                	add_request_timer.start();
                #endif
                	super::do_add_request(std::move(request),
                			      client_id,
                			      req_params,
                			      time,
                			      addl_cost);
                	// no call to schedule_request for pull version
                #ifdef PROFILE
                	add_request_timer.stop();
                #endif
                      }
                
                
                      inline PullReq pull_request() {
                	return pull_request(get_time());
                      }
                
                
                      PullReq pull_request(Time now) {
                	PullReq result;
                	typename super::DataGuard g(this->data_mtx);
                #ifdef PROFILE
                	pull_request_timer.start();
                #endif
                
                	typename super::NextReq next = super::do_next_request(now);
                	result.type = next.type;
                	switch(next.type) {
                	case super::NextReqType::none:
                	  return result;
                	  break;
                	case super::NextReqType::future:
                	  result.data = next.when_ready;
                	  return result;
                	  break;
                	case super::NextReqType::returning:
                	  // to avoid nesting, break out and let code below handle this case
                	  break;
                	default:
                	  assert(false);
                	}
                
                	// we'll only get here if we're returning an entry
                
                	auto process_f =
                	  [&] (PullReq& pull_result, PhaseType phase) ->
                	  std::function<void(const C&,
                			     typename super::RequestRef&)> {
                	  return [&pull_result, phase](const C& client,
                				       typename super::RequestRef& request) {
                	    pull_result.data =
                	    typename PullReq::Retn{client, std::move(request), phase};
                	  };
                	};
                
                	switch(next.heap_id) {
                	case super::HeapId::reservation:
                	  if (super::use_heap) {
                	    super::pop_process_request(this->resv_heap,
                				     process_f(result, PhaseType::reservation));
                	  } else {
                	    super::pop_process_request(&super::iiv::resv,
                				     process_f(result, PhaseType::reservation));
                	  }
                	  ++this->reserv_sched_count;
                	  break;
                	case super::HeapId::ready:
                	{
                	  if (super::use_heap) {
                	  super::pop_process_request(this->ready_heap,
                				     process_f(result, PhaseType::priority));
                	  } else {
                	    super::pop_process_request(&super::iiv::ready,
                				     process_f(result, PhaseType::priority));
                	  }
                	  auto& retn = boost::get<typename PullReq::Retn>(result.data);
                	  super::reduce_reservation_tags(retn.client);
                	  ++this->prop_sched_count;
                	}
                	break;
                #if USE_PROP_HEAP
                	case super::HeapId::proportional:
                	{
                	  super::pop_process_request(this->prop_heap,
                				     process_f(result, PhaseType::priority));
                	  auto& retn = boost::get<typename PullReq::Retn>(result.data);
                	  super::reduce_reservation_tags(retn.client);
                	  ++this->limit_break_sched_count;
                	}
                	break;
                #endif
                	default:
                	  assert(false);
                	}
                
                #ifdef PROFILE
                	pull_request_timer.stop();
                #endif
                	return result;
                      } // pull_request
                
                
                    protected:
                
                
                      // data_mtx should be held when called; unfortunately this
                      // function has to be repeated in both push & pull
                      // specializations
                      typename super::NextReq next_request() {
                	return next_request(get_time());
                      }
                    }; // class PullPriorityQueue
                
                
                    // PUSH version
                    template<typename C, typename R>
                    class PushPriorityQueue : public PriorityQueueBase<C,R> {
                
                    protected:
                
                      using super = PriorityQueueBase<C,R>;
                
                    public:
                
                      // a function to see whether the server can handle another request
                      using CanHandleRequestFunc = std::function<bool(void)>;
                
                      // a function to submit a request to the server; the second
                      // parameter is a callback when it's completed
                      using HandleRequestFunc =
                	std::function<void(const C&,typename super::RequestRef,PhaseType)>;
                
                    protected:
                
                      CanHandleRequestFunc can_handle_f;
                      HandleRequestFunc    handle_f;
                      // for handling timed scheduling
                      std::mutex  sched_ahead_mtx;
                      std::condition_variable sched_ahead_cv;
                      Time sched_ahead_when = TimeZero;
                
                #ifdef PROFILE
                    public:
                      ProfileTimer<std::chrono::nanoseconds> add_request_timer;
                      ProfileTimer<std::chrono::nanoseconds> request_complete_timer;
                    protected:
                #endif
                
                      // NB: threads declared last, so constructed last and destructed first
                
                      std::thread sched_ahead_thd;
                
                    public:
                
                      // push full constructor
                      template<typename Rep, typename Per>
         100 ->       PushPriorityQueue(typename super::ClientInfoFunc _client_info_f,
                			CanHandleRequestFunc _can_handle_f,
                			HandleRequestFunc _handle_f,
                			std::chrono::duration<Rep,Per> _idle_age,
                			std::chrono::duration<Rep,Per> _erase_age,
                			std::chrono::duration<Rep,Per> _check_time,
                			bool _allow_limit_break = false) :
                	super(_client_info_f,
                	      _idle_age, _erase_age, _check_time,
                	      _allow_limit_break)
                      {
                	can_handle_f = _can_handle_f;
                	handle_f = _handle_f;
                	sched_ahead_thd = std::thread(&PushPriorityQueue::run_sched_ahead, this);
                      }
                
                
                      // push convenience constructor
         100 ->       PushPriorityQueue(typename super::ClientInfoFunc _client_info_f,
                			CanHandleRequestFunc _can_handle_f,
                			HandleRequestFunc _handle_f,
                			bool _allow_limit_break = false) :
                	PushPriorityQueue(_client_info_f,
                			  _can_handle_f,
                			  _handle_f,
                			  std::chrono::minutes(10),
                			  std::chrono::minutes(15),
                			  std::chrono::minutes(6),
                			  _allow_limit_break)
                      {
                	// empty
                      }
                
                
                      ~PushPriorityQueue() {
                	this->finishing = true;
                	sched_ahead_cv.notify_one();
                	sched_ahead_thd.join();
                      }
                
                    public:
                
        1913 ->       inline void add_request(const R& request,
                			      const C& client_id,
                			      const ReqParams& req_params,
                			      double addl_cost = 0.0) {
                	add_request(typename super::RequestRef(new R(request)),
                		    client_id,
                		    req_params,
                		    get_time(),
                		    addl_cost);
                      }
                
                
                      inline void add_request(typename super::RequestRef&& request,
                			      const C& client_id,
                			      const ReqParams& req_params,
                			      double addl_cost = 0.0) {
                	add_request(request, req_params, client_id, get_time(), addl_cost);
                      }
                
                
                      inline void add_request_time(const R& request,
                				   const C& client_id,
                				   const ReqParams& req_params,
                				   const Time time,
                				   double addl_cost = 0.0) {
                	add_request(typename super::RequestRef(new R(request)),
                		    client_id,
                		    req_params,
                		    time,
                		    addl_cost);
                      }
                
                
        1885 ->       void add_request(typename super::RequestRef&& request,
                		       const C&         client_id,
                		       const ReqParams& req_params,
                		       const Time       time,
                		       double           addl_cost = 0.0) {
                	typename super::DataGuard g(this->data_mtx);
                #ifdef PROFILE
                	add_request_timer.start();
                #endif
                	super::do_add_request(std::move(request),
                			      client_id,
                			      req_params,
                			      time,
                			      addl_cost);
                	schedule_request();
                #ifdef PROFILE
                	add_request_timer.stop();
                #endif
                      }
                
                
        2582 ->       void request_completed() {
                	typename super::DataGuard g(this->data_mtx);
                #ifdef PROFILE
                	request_complete_timer.start();
                #endif
                	schedule_request();
                #ifdef PROFILE
                	request_complete_timer.stop();
                #endif
                      }
                
                    protected:
                
                      // data_mtx should be held when called; furthermore, the heap
                      // should not be empty and the top element of the heap should
                      // not be already handled
                      template<typename C1, IndIntruHeapData super::ClientRec::*C2, typename C3>
       ##### ->       C submit_top_request(IndIntruHeap<C1,typename super::ClientRec,C2,C3>& heap,
                			   PhaseType phase) {
                	C client_result;
                	super::pop_process_request(heap,
                				   [this, phase, &client_result]
                				   (const C& client,
       ##### -> 				    typename super::RequestRef& request) {
                				     client_result = client;
                				     handle_f(client, std::move(request), phase);
                				   });
                	return client_result;
                      }
                
                      // iiv version
        2441 ->       C submit_top_request(size_t super::iiv::*which_top,  PhaseType phase) {
                	C client_result;
                
                	super::pop_process_request( which_top,
                				   [this, phase, &client_result]
                				   (const C& client,
        2210 -> 				    typename super::RequestRef& request) {
                				     client_result = client;
                				     handle_f(client, std::move(request), phase);
                				   });
                	return client_result;
                      }
                
                
                      // data_mtx should be held when called
        2081 ->       void submit_request(typename super::HeapId heap_id) {
                	C client;
                	switch(heap_id) {
                	case super::HeapId::reservation:
                	  // don't need to note client
                	  if (super::use_heap) {
                	    (void) submit_top_request(this->resv_heap, PhaseType::reservation);
                	  } else {
                	    (void) submit_top_request(&super::iiv::resv, PhaseType::reservation);
                	  }
                	  // unlike the other two cases, we do not reduce reservation
                	  // tags here
                	  ++this->reserv_sched_count;
                	  break;
                	case super::HeapId::ready:
                	  if (super::use_heap) {
                	    client = submit_top_request(this->ready_heap, PhaseType::priority);
                	  } else {
                	    client = submit_top_request(&super::iiv::ready, PhaseType::priority);
                	  }
                	  super::reduce_reservation_tags(client);
                	  ++this->prop_sched_count;
                	  break;
                #if USE_PROP_HEAP
                	case super::HeapId::proportional:
                	  client = submit_top_request(this->prop_heap, PhaseType::priority);
                	  super::reduce_reservation_tags(client);
                	  ++this->limit_break_sched_count;
                	  break;
                #endif
                	default:
                	  assert(false);
                	}
                      } // submit_request
                
                
                      // data_mtx should be held when called; unfortunately this
                      // function has to be repeated in both push & pull
                      // specializations
        4921 ->       typename super::NextReq next_request() {
                	return next_request(get_time());
                      }
                
                
                      // data_mtx should be held when called; overrides member
                      // function in base class to add check for whether a request can
                      // be pushed to the server
        4783 ->       typename super::NextReq next_request(Time now) {
                	if (!can_handle_f()) {
                	  typename super::NextReq result;
                	  result.type = super::NextReqType::none;
                	  return result;
                	} else {
                	  return super::do_next_request(now);
                	}
                      } // next_request
                
                
                      // data_mtx should be held when called
        4850 ->       void schedule_request() {
                	typename super::NextReq next_req = next_request();
                	switch (next_req.type) {
                	case super::NextReqType::none:
                	  return;
                	case super::NextReqType::future:
                	  sched_at(next_req.when_ready);
                	  break;
                	case super::NextReqType::returning:
                	  submit_request(next_req.heap_id);
                	  break;
                	default:
                	  assert(false);
                	}
                      }
                
                
                      // this is the thread that handles running schedule_request at
                      // future times when nothing can be scheduled immediately
          36 ->       void run_sched_ahead() {
                	std::unique_lock<std::mutex> l(sched_ahead_mtx);
                
                	while (!this->finishing) {
                	  if (TimeZero == sched_ahead_when) {
                	    sched_ahead_cv.wait(l);
                	  } else {
                	    Time now;
                	    while (!this->finishing && (now = get_time()) < sched_ahead_when) {
                	      long microseconds_l = long(1 + 1000000 * (sched_ahead_when - now));
                	      auto microseconds = std::chrono::microseconds(microseconds_l);
                	      sched_ahead_cv.wait_for(l, microseconds);
                	    }
                	    sched_ahead_when = TimeZero;
                	    if (this->finishing) return;
                
                	    l.unlock();
                	    if (!this->finishing) {
                	      typename super::DataGuard g(this->data_mtx);
                	      schedule_request();
                	    }
                	    l.lock();
                	  }
                	}
                      }
                
                
       ##### ->       void sched_at(Time when) {
                	std::lock_guard<std::mutex> l(sched_ahead_mtx);
                	if (TimeZero == sched_ahead_when || when < sched_ahead_when) {
                	  sched_ahead_when = when;
                	  sched_ahead_cv.notify_one();
                	}
                      }
                    }; // class PushPriorityQueue
                
                  } // namespace dmclock
                } // namespace crimson


Top 10 Lines:

     Line      Count

      303      21263
      441      19238
      295      11449
      477       7451
      201       6333
      149       5733
     1667       4921
     1687       4850
      437       4845
     1675       4783

Execution Summary:

       54   Executable lines in this file
       54   Lines executed
   100.00   Percent of the file executed

   133185   Total number of line executions
  2466.39   Average executions per line


*** File /usr/include/c++/5/initializer_list:
                // std::initializer_list support -*- C++ -*-
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                //
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file initializer_list
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _INITIALIZER_LIST
                #define _INITIALIZER_LIST
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else // C++0x
                
                #pragma GCC visibility push(default)
                
                #include <bits/c++config.h>
                
                namespace std
                {
                  /// initializer_list
                  template<class _E>
                    class initializer_list
                    {
                    public:
                      typedef _E 		value_type;
                      typedef const _E& 	reference;
                      typedef const _E& 	const_reference;
                      typedef size_t 		size_type;
                      typedef const _E* 	iterator;
                      typedef const _E* 	const_iterator;
                
                    private:
                      iterator			_M_array;
                      size_type			_M_len;
                
                      // The compiler can call a private constructor.
                      constexpr initializer_list(const_iterator __a, size_type __l)
                      : _M_array(__a), _M_len(__l) { }
                
                    public:
                      constexpr initializer_list() noexcept
                      : _M_array(0), _M_len(0) { }
                
                      // Number of elements.
                      constexpr size_type
           2 ->       size() const noexcept { return _M_len; }
                
                      // First element.
                      constexpr const_iterator
           4 ->       begin() const noexcept { return _M_array; }
                
                      // One past the last element.
                      constexpr const_iterator
           2 ->       end() const noexcept { return begin() + size(); }
                    };
                
                  /**
                   *  @brief  Return an iterator pointing to the first element of
                   *          the initializer_list.
                   *  @param  __ils  Initializer list.
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    begin(initializer_list<_Tp> __ils) noexcept
                    { return __ils.begin(); }
                
                  /**
                   *  @brief  Return an iterator pointing to one past the last element
                   *          of the initializer_list.
                   *  @param  __ils  Initializer list.
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    end(initializer_list<_Tp> __ils) noexcept
                    { return __ils.end(); }
                }
                
                #pragma GCC visibility pop
                
                #endif // C++11
                
                #endif // _INITIALIZER_LIST


Top 10 Lines:

     Line      Count

       75          4
       71          2
       79          2

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     2.67   Average executions per line


*** File /usr/include/c++/5/bits/shared_ptr.h:
                // shared_ptr and weak_ptr implementation -*- C++ -*-
                
                // Copyright (C) 2007-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                // GCC Note: Based on files from version 1.32.0 of the Boost library.
                
                //  shared_count.hpp
                //  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
                
                //  shared_ptr.hpp
                //  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.
                //  Copyright (C) 2001, 2002, 2003 Peter Dimov
                
                //  weak_ptr.hpp
                //  Copyright (C) 2001, 2002, 2003 Peter Dimov
                
                //  enable_shared_from_this.hpp
                //  Copyright (C) 2002 Peter Dimov
                
                // Distributed under the Boost Software License, Version 1.0. (See
                // accompanying file LICENSE_1_0.txt or copy at
                // http://www.boost.org/LICENSE_1_0.txt)
                
                /** @file bits/shared_ptr.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _SHARED_PTR_H
                #define _SHARED_PTR_H 1
                
                #include <bits/shared_ptr_base.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup pointer_abstractions
                   * @{
                   */
                
                  /// 20.7.2.2.11 shared_ptr I/O
                  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
                    inline std::basic_ostream<_Ch, _Tr>&
                    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
                	       const __shared_ptr<_Tp, _Lp>& __p)
                    {
                      __os << __p.get();
                      return __os;
                    }
                
                  /// 20.7.2.2.10 shared_ptr get_deleter
                  template<typename _Del, typename _Tp, _Lock_policy _Lp>
                    inline _Del*
                    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
                    {
                #if __cpp_rtti
                      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));
                #else
                      return 0;
                #endif
                    }
                
                
                  /**
                   *  @brief  A smart pointer with reference-counted copy semantics.
                   *
                   *  The object pointed to is deleted when the last shared_ptr pointing to
                   *  it is destroyed or reset.
                  */
                  template<typename _Tp>
        1002 ->     class shared_ptr : public __shared_ptr<_Tp>
                    {
                      template<typename _Ptr>
                	using _Convertible
                	  = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;
                
                    public:
                      /**
                       *  @brief  Construct an empty %shared_ptr.
                       *  @post   use_count()==0 && get()==0
                       */
         393 ->       constexpr shared_ptr() noexcept
                      : __shared_ptr<_Tp>() { }
                
          77 ->       shared_ptr(const shared_ptr&) noexcept = default;
                
                      /**
                       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.
                       *  @param  __p  A pointer that is convertible to element_type*.
                       *  @post   use_count() == 1 && get() == __p
                       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.
                       */
                      template<typename _Tp1>
                	explicit shared_ptr(_Tp1* __p)
                        : __shared_ptr<_Tp>(__p) { }
                
                      /**
                       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
                       *          and the deleter @a __d.
                       *  @param  __p  A pointer.
                       *  @param  __d  A deleter.
                       *  @post   use_count() == 1 && get() == __p
                       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
                       *
                       *  Requirements: _Deleter's copy constructor and destructor must
                       *  not throw
                       *
                       *  __shared_ptr will release __p by calling __d(__p)
                       */
                      template<typename _Tp1, typename _Deleter>
                	shared_ptr(_Tp1* __p, _Deleter __d)
                        : __shared_ptr<_Tp>(__p, __d) { }
                
                      /**
                       *  @brief  Construct a %shared_ptr that owns a null pointer
                       *          and the deleter @a __d.
                       *  @param  __p  A null pointer constant.
                       *  @param  __d  A deleter.
                       *  @post   use_count() == 1 && get() == __p
                       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
                       *
                       *  Requirements: _Deleter's copy constructor and destructor must
                       *  not throw
                       *
                       *  The last owner will call __d(__p)
                       */
                      template<typename _Deleter>
                	shared_ptr(nullptr_t __p, _Deleter __d)
                        : __shared_ptr<_Tp>(__p, __d) { }
                
                      /**
                       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
                       *          and the deleter @a __d.
                       *  @param  __p  A pointer.
                       *  @param  __d  A deleter.
                       *  @param  __a  An allocator.
                       *  @post   use_count() == 1 && get() == __p
                       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
                       *
                       *  Requirements: _Deleter's copy constructor and destructor must
                       *  not throw _Alloc's copy constructor and destructor must not
                       *  throw.
                       *
                       *  __shared_ptr will release __p by calling __d(__p)
                       */
                      template<typename _Tp1, typename _Deleter, typename _Alloc>
                	shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
                	: __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
                
                      /**
                       *  @brief  Construct a %shared_ptr that owns a null pointer
                       *          and the deleter @a __d.
                       *  @param  __p  A null pointer constant.
                       *  @param  __d  A deleter.
                       *  @param  __a  An allocator.
                       *  @post   use_count() == 1 && get() == __p
                       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
                       *
                       *  Requirements: _Deleter's copy constructor and destructor must
                       *  not throw _Alloc's copy constructor and destructor must not
                       *  throw.
                       *
                       *  The last owner will call __d(__p)
                       */
                      template<typename _Deleter, typename _Alloc>
                	shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
                	: __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
                
                      // Aliasing constructor
                
                      /**
                       *  @brief  Constructs a %shared_ptr instance that stores @a __p
                       *          and shares ownership with @a __r.
                       *  @param  __r  A %shared_ptr.
                       *  @param  __p  A pointer that will remain valid while @a *__r is valid.
                       *  @post   get() == __p && use_count() == __r.use_count()
                       *
                       *  This can be used to construct a @c shared_ptr to a sub-object
                       *  of an object managed by an existing @c shared_ptr.
                       *
                       * @code
                       * shared_ptr< pair<int,int> > pii(new pair<int,int>());
                       * shared_ptr<int> pi(pii, &pii->first);
                       * assert(pii.use_count() == 2);
                       * @endcode
                       */
                      template<typename _Tp1>
                	shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p) noexcept
                	: __shared_ptr<_Tp>(__r, __p) { }
                
                      /**
                       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;
                       *          otherwise construct a %shared_ptr that shares ownership
                       *          with @a __r.
                       *  @param  __r  A %shared_ptr.
                       *  @post   get() == __r.get() && use_count() == __r.use_count()
                       */
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	shared_ptr(const shared_ptr<_Tp1>& __r) noexcept
                        : __shared_ptr<_Tp>(__r) { }
                
                      /**
                       *  @brief  Move-constructs a %shared_ptr instance from @a __r.
                       *  @param  __r  A %shared_ptr rvalue.
                       *  @post   *this contains the old value of @a __r, @a __r is empty.
                       */
          79 ->       shared_ptr(shared_ptr&& __r) noexcept
                      : __shared_ptr<_Tp>(std::move(__r)) { }
                
                      /**
                       *  @brief  Move-constructs a %shared_ptr instance from @a __r.
                       *  @param  __r  A %shared_ptr rvalue.
                       *  @post   *this contains the old value of @a __r, @a __r is empty.
                       */
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
         316 -> 	shared_ptr(shared_ptr<_Tp1>&& __r) noexcept
                	: __shared_ptr<_Tp>(std::move(__r)) { }
                
                      /**
                       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r
                       *          and stores a copy of the pointer stored in @a __r.
                       *  @param  __r  A weak_ptr.
                       *  @post   use_count() == __r.use_count()
                       *  @throw  bad_weak_ptr when __r.expired(),
                       *          in which case the constructor has no effect.
                       */
                      template<typename _Tp1>
                	explicit shared_ptr(const weak_ptr<_Tp1>& __r)
                	: __shared_ptr<_Tp>(__r) { }
                
                #if _GLIBCXX_USE_DEPRECATED
                      template<typename _Tp1>
                	shared_ptr(std::auto_ptr<_Tp1>&& __r);
                #endif
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2399. shared_ptr's constructor from unique_ptr should be constrained
                      template<typename _Tp1, typename _Del, typename
                	       = _Convertible<typename unique_ptr<_Tp1, _Del>::pointer>>
                	shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
                	: __shared_ptr<_Tp>(std::move(__r)) { }
                
                      /**
                       *  @brief  Construct an empty %shared_ptr.
                       *  @post   use_count() == 0 && get() == nullptr
                       */
                      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
                
                      shared_ptr& operator=(const shared_ptr&) noexcept = default;
                
                      template<typename _Tp1>
                	shared_ptr&
                	operator=(const shared_ptr<_Tp1>& __r) noexcept
                	{
                	  this->__shared_ptr<_Tp>::operator=(__r);
                	  return *this;
                	}
                
                #if _GLIBCXX_USE_DEPRECATED
                      template<typename _Tp1>
                	shared_ptr&
                	operator=(std::auto_ptr<_Tp1>&& __r)
                	{
                	  this->__shared_ptr<_Tp>::operator=(std::move(__r));
                	  return *this;
                	}
                #endif
                
                      shared_ptr&
                      operator=(shared_ptr&& __r) noexcept
                      {
                	this->__shared_ptr<_Tp>::operator=(std::move(__r));
                	return *this;
                      }
                
                      template<class _Tp1>
                	shared_ptr&
                	operator=(shared_ptr<_Tp1>&& __r) noexcept
                	{
                	  this->__shared_ptr<_Tp>::operator=(std::move(__r));
                	  return *this;
                	}
                
                      template<typename _Tp1, typename _Del>
                	shared_ptr&
                	operator=(std::unique_ptr<_Tp1, _Del>&& __r)
                	{
                	  this->__shared_ptr<_Tp>::operator=(std::move(__r));
                	  return *this;
                	}
                
                    private:
                      // This constructor is non-standard, it is used by allocate_shared.
                      template<typename _Alloc, typename... _Args>
         391 -> 	shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
                		   _Args&&... __args)
                	: __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
                	{ }
                
                      template<typename _Tp1, typename _Alloc, typename... _Args>
                	friend shared_ptr<_Tp1>
                	allocate_shared(const _Alloc& __a, _Args&&... __args);
                
                      // This constructor is non-standard, it is used by weak_ptr::lock().
                      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
                      : __shared_ptr<_Tp>(__r, std::nothrow) { }
                
                      friend class weak_ptr<_Tp>;
                    };
                
                  // 20.7.2.2.7 shared_ptr comparisons
                  template<typename _Tp1, typename _Tp2>
                    inline bool
       ##### ->     operator==(const shared_ptr<_Tp1>& __a,
                	       const shared_ptr<_Tp2>& __b) noexcept
                    { return __a.get() == __b.get(); }
                
                  template<typename _Tp>
                    inline bool
                    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
                    { return !__a; }
                
                  template<typename _Tp>
                    inline bool
                    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
                    { return !__a; }
                
                  template<typename _Tp1, typename _Tp2>
                    inline bool
                    operator!=(const shared_ptr<_Tp1>& __a,
                	       const shared_ptr<_Tp2>& __b) noexcept
                    { return __a.get() != __b.get(); }
                
                  template<typename _Tp>
                    inline bool
                    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
                    { return (bool)__a; }
                
                  template<typename _Tp>
                    inline bool
                    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
                    { return (bool)__a; }
                
                  template<typename _Tp1, typename _Tp2>
                    inline bool
                    operator<(const shared_ptr<_Tp1>& __a,
                	      const shared_ptr<_Tp2>& __b) noexcept
                    {
                      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
                      return std::less<_CT>()(__a.get(), __b.get());
                    }
                
                  template<typename _Tp>
                    inline bool
                    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
                    { return std::less<_Tp*>()(__a.get(), nullptr); }
                
                  template<typename _Tp>
                    inline bool
                    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
                    { return std::less<_Tp*>()(nullptr, __a.get()); }
                
                  template<typename _Tp1, typename _Tp2>
                    inline bool
                    operator<=(const shared_ptr<_Tp1>& __a,
                	       const shared_ptr<_Tp2>& __b) noexcept
                    { return !(__b < __a); }
                
                  template<typename _Tp>
                    inline bool
                    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
                    { return !(nullptr < __a); }
                
                  template<typename _Tp>
                    inline bool
                    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
                    { return !(__a < nullptr); }
                
                  template<typename _Tp1, typename _Tp2>
                    inline bool
                    operator>(const shared_ptr<_Tp1>& __a,
                	      const shared_ptr<_Tp2>& __b) noexcept
                    { return (__b < __a); }
                
                  template<typename _Tp>
                    inline bool
                    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
                    { return std::less<_Tp*>()(nullptr, __a.get()); }
                
                  template<typename _Tp>
                    inline bool
                    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
                    { return std::less<_Tp*>()(__a.get(), nullptr); }
                
                  template<typename _Tp1, typename _Tp2>
                    inline bool
                    operator>=(const shared_ptr<_Tp1>& __a,
                	       const shared_ptr<_Tp2>& __b) noexcept
                    { return !(__a < __b); }
                
                  template<typename _Tp>
                    inline bool
                    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
                    { return !(__a < nullptr); }
                
                  template<typename _Tp>
                    inline bool
                    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
                    { return !(nullptr < __a); }
                
                  template<typename _Tp>
                    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>
                    { };
                
                  // 20.7.2.2.8 shared_ptr specialized algorithms.
                  template<typename _Tp>
                    inline void
       ##### ->     swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
                    { __a.swap(__b); }
                
                  // 20.7.2.2.9 shared_ptr casts.
                  template<typename _Tp, typename _Tp1>
                    inline shared_ptr<_Tp>
                    static_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
                    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }
                
                  template<typename _Tp, typename _Tp1>
                    inline shared_ptr<_Tp>
                    const_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
                    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }
                
                  template<typename _Tp, typename _Tp1>
                    inline shared_ptr<_Tp>
                    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
                    {
                      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
                	return shared_ptr<_Tp>(__r, __p);
                      return shared_ptr<_Tp>();
                    }
                
                
                  /**
                   *  @brief  A smart pointer with weak semantics.
                   *
                   *  With forwarding constructors and assignment operators.
                   */
                  template<typename _Tp>
                    class weak_ptr : public __weak_ptr<_Tp>
                    {
                      template<typename _Ptr>
                	using _Convertible
                	  = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;
                
                    public:
                      constexpr weak_ptr() noexcept = default;
                
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	weak_ptr(const shared_ptr<_Tp1>& __r) noexcept
                	: __weak_ptr<_Tp>(__r) { }
                
                      weak_ptr(const weak_ptr&) noexcept = default;
                
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	weak_ptr(const weak_ptr<_Tp1>& __r) noexcept
                	: __weak_ptr<_Tp>(__r) { }
                
                      weak_ptr(weak_ptr&&) noexcept = default;
                
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	weak_ptr(weak_ptr<_Tp1>&& __r) noexcept
                	: __weak_ptr<_Tp>(std::move(__r)) { }
                
                      weak_ptr&
                      operator=(const weak_ptr& __r) noexcept = default;
                
                      template<typename _Tp1>
                	weak_ptr&
                	operator=(const weak_ptr<_Tp1>& __r) noexcept
                	{
                	  this->__weak_ptr<_Tp>::operator=(__r);
                	  return *this;
                	}
                
                      template<typename _Tp1>
                	weak_ptr&
                	operator=(const shared_ptr<_Tp1>& __r) noexcept
                	{
                	  this->__weak_ptr<_Tp>::operator=(__r);
                	  return *this;
                	}
                
                      weak_ptr&
                      operator=(weak_ptr&& __r) noexcept = default;
                
                      template<typename _Tp1>
                	weak_ptr&
                	operator=(weak_ptr<_Tp1>&& __r) noexcept
                	{
                	  this->__weak_ptr<_Tp>::operator=(std::move(__r));
                	  return *this;
                	}
                
                      shared_ptr<_Tp>
                      lock() const noexcept
                      { return shared_ptr<_Tp>(*this, std::nothrow); }
                    };
                
                  // 20.7.2.3.6 weak_ptr specialized algorithms.
                  template<typename _Tp>
                    inline void
                    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
                    { __a.swap(__b); }
                
                
                  /// Primary template owner_less
                  template<typename _Tp>
                    struct owner_less;
                
                  /// Partial specialization of owner_less for shared_ptr.
                  template<typename _Tp>
                    struct owner_less<shared_ptr<_Tp>>
                    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
                    { };
                
                  /// Partial specialization of owner_less for weak_ptr.
                  template<typename _Tp>
                    struct owner_less<weak_ptr<_Tp>>
                    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
                    { };
                
                  /**
                   *  @brief Base class allowing use of member function shared_from_this.
                   */
                  template<typename _Tp>
                    class enable_shared_from_this
                    {
                    protected:
                      constexpr enable_shared_from_this() noexcept { }
                
                      enable_shared_from_this(const enable_shared_from_this&) noexcept { }
                
                      enable_shared_from_this&
                      operator=(const enable_shared_from_this&) noexcept
                      { return *this; }
                
                      ~enable_shared_from_this() { }
                
                    public:
                      shared_ptr<_Tp>
                      shared_from_this()
                      { return shared_ptr<_Tp>(this->_M_weak_this); }
                
                      shared_ptr<const _Tp>
                      shared_from_this() const
                      { return shared_ptr<const _Tp>(this->_M_weak_this); }
                
                    private:
                      template<typename _Tp1>
                	void
                	_M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
                	{ _M_weak_this._M_assign(__p, __n); }
                
                      template<typename _Tp1, typename _Tp2>
                	friend void
                	__enable_shared_from_this_helper(const __shared_count<>&,
                					 const enable_shared_from_this<_Tp1>*,
                					 const _Tp2*) noexcept;
                
                      mutable weak_ptr<_Tp>  _M_weak_this;
                    };
                
                  template<typename _Tp1, typename _Tp2>
                    inline void
                    __enable_shared_from_this_helper(const __shared_count<>& __pn,
                				     const enable_shared_from_this<_Tp1>*
                				     __pe, const _Tp2* __px) noexcept
                    {
                      if (__pe != nullptr)
                	__pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
                    }
                
                  /**
                   *  @brief  Create an object that is owned by a shared_ptr.
                   *  @param  __a     An allocator.
                   *  @param  __args  Arguments for the @a _Tp object's constructor.
                   *  @return A shared_ptr that owns the newly created object.
                   *  @throw  An exception thrown from @a _Alloc::allocate or from the
                   *          constructor of @a _Tp.
                   *
                   *  A copy of @a __a will be used to allocate memory for the shared_ptr
                   *  and the new object.
                   */
                  template<typename _Tp, typename _Alloc, typename... _Args>
                    inline shared_ptr<_Tp>
         391 ->     allocate_shared(const _Alloc& __a, _Args&&... __args)
                    {
                      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,
                			     std::forward<_Args>(__args)...);
                    }
                
                  /**
                   *  @brief  Create an object that is owned by a shared_ptr.
                   *  @param  __args  Arguments for the @a _Tp object's constructor.
                   *  @return A shared_ptr that owns the newly created object.
                   *  @throw  std::bad_alloc, or an exception thrown from the
                   *          constructor of @a _Tp.
                   */
                  template<typename _Tp, typename... _Args>
                    inline shared_ptr<_Tp>
         386 ->     make_shared(_Args&&... __args)
                    {
                      typedef typename std::remove_const<_Tp>::type _Tp_nc;
                      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
                				       std::forward<_Args>(__args)...);
                    }
                
                  /// std::hash specialization for shared_ptr.
                  template<typename _Tp>
                    struct hash<shared_ptr<_Tp>>
                    : public __hash_base<size_t, shared_ptr<_Tp>>
                    {
                      size_t
                      operator()(const shared_ptr<_Tp>& __s) const noexcept
                      { return std::hash<_Tp*>()(__s.get()); }
                    };
                
                  // @} group pointer_abstractions
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif // _SHARED_PTR_H


Top 10 Lines:

     Line      Count

       93       1002
      104        393
      317        391
      617        391
      632        386
      238        316
      229         79
      107         77

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

     3035   Total number of line executions
   303.50   Average executions per line


*** File /usr/include/c++/5/cmath:
                // -*- C++ -*- C forwarding header.
                
                // Copyright (C) 1997-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/cmath
                 *  This is a Standard C++ Library file.  You should @c \#include this file
                 *  in your programs, rather than any of the @a *.h implementation files.
                 *
                 *  This is the C++ version of the Standard C Library header @c math.h,
                 *  and its contents are (mostly) the same as that header, but are all
                 *  contained in the namespace @c std (except for names which are defined
                 *  as macros in C).
                 */
                
                //
                // ISO C++ 14882: 26.5  C library
                //
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <math.h>
                
                #ifndef _GLIBCXX_CMATH
                #define _GLIBCXX_CMATH 1
                
                // Get rid of those macros defined in <math.h> in lieu of real functions.
                #undef abs
                #undef div
                #undef acos
                #undef asin
                #undef atan
                #undef atan2
                #undef ceil
                #undef cos
                #undef cosh
                #undef exp
                #undef fabs
                #undef floor
                #undef fmod
                #undef frexp
                #undef ldexp
                #undef log
                #undef log10
                #undef modf
                #undef pow
                #undef sin
                #undef sinh
                #undef sqrt
                #undef tan
                #undef tanh
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR double
                  abs(double __x)
                  { return __builtin_fabs(__x); }
                #endif
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  abs(float __x)
                  { return __builtin_fabsf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  abs(long double __x)
                  { return __builtin_fabsl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    abs(_Tp __x)
                    { return __builtin_fabs(__x); }
                
                  using ::acos;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  acos(float __x)
                  { return __builtin_acosf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  acos(long double __x)
                  { return __builtin_acosl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    acos(_Tp __x)
                    { return __builtin_acos(__x); }
                
                  using ::asin;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  asin(float __x)
                  { return __builtin_asinf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  asin(long double __x)
                  { return __builtin_asinl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    asin(_Tp __x)
                    { return __builtin_asin(__x); }
                
                  using ::atan;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  atan(float __x)
                  { return __builtin_atanf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  atan(long double __x)
                  { return __builtin_atanl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    atan(_Tp __x)
                    { return __builtin_atan(__x); }
                
                  using ::atan2;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  atan2(float __y, float __x)
                  { return __builtin_atan2f(__y, __x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  atan2(long double __y, long double __x)
                  { return __builtin_atan2l(__y, __x); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    atan2(_Tp __y, _Up __x)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return atan2(__type(__y), __type(__x));
                    }
                
                  using ::ceil;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  ceil(float __x)
                  { return __builtin_ceilf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  ceil(long double __x)
                  { return __builtin_ceill(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    ceil(_Tp __x)
                    { return __builtin_ceil(__x); }
                
                  using ::cos;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  cos(float __x)
                  { return __builtin_cosf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  cos(long double __x)
                  { return __builtin_cosl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    cos(_Tp __x)
                    { return __builtin_cos(__x); }
                
                  using ::cosh;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  cosh(float __x)
                  { return __builtin_coshf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  cosh(long double __x)
                  { return __builtin_coshl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    cosh(_Tp __x)
                    { return __builtin_cosh(__x); }
                
                  using ::exp;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  exp(float __x)
                  { return __builtin_expf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  exp(long double __x)
                  { return __builtin_expl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    exp(_Tp __x)
                    { return __builtin_exp(__x); }
                
                  using ::fabs;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  fabs(float __x)
                  { return __builtin_fabsf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  fabs(long double __x)
                  { return __builtin_fabsl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    fabs(_Tp __x)
                    { return __builtin_fabs(__x); }
                
                  using ::floor;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  floor(float __x)
                  { return __builtin_floorf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  floor(long double __x)
                  { return __builtin_floorl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    floor(_Tp __x)
                    { return __builtin_floor(__x); }
                
                  using ::fmod;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  fmod(float __x, float __y)
                  { return __builtin_fmodf(__x, __y); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  fmod(long double __x, long double __y)
                  { return __builtin_fmodl(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    fmod(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return fmod(__type(__x), __type(__y));
                    }
                
                  using ::frexp;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline float
                  frexp(float __x, int* __exp)
                  { return __builtin_frexpf(__x, __exp); }
                
                  inline long double
                  frexp(long double __x, int* __exp)
                  { return __builtin_frexpl(__x, __exp); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    frexp(_Tp __x, int* __exp)
                    { return __builtin_frexp(__x, __exp); }
                
                  using ::ldexp;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  ldexp(float __x, int __exp)
                  { return __builtin_ldexpf(__x, __exp); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  ldexp(long double __x, int __exp)
                  { return __builtin_ldexpl(__x, __exp); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    ldexp(_Tp __x, int __exp)
                    { return __builtin_ldexp(__x, __exp); }
                
                  using ::log;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  log(float __x)
                  { return __builtin_logf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  log(long double __x)
                  { return __builtin_logl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    log(_Tp __x)
                    { return __builtin_log(__x); }
                
                  using ::log10;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  log10(float __x)
                  { return __builtin_log10f(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  log10(long double __x)
                  { return __builtin_log10l(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                    double>::__type
                    log10(_Tp __x)
                    { return __builtin_log10(__x); }
                
                  using ::modf;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline float
                  modf(float __x, float* __iptr)
                  { return __builtin_modff(__x, __iptr); }
                
                  inline long double
                  modf(long double __x, long double* __iptr)
                  { return __builtin_modfl(__x, __iptr); }
                #endif
                
                  using ::pow;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  pow(float __x, float __y)
                  { return __builtin_powf(__x, __y); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  pow(long double __x, long double __y)
                  { return __builtin_powl(__x, __y); }
                
                #if __cplusplus < 201103L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 550. What should the return type of pow(float,int) be?
                  inline double
                  pow(double __x, int __i)
                  { return __builtin_powi(__x, __i); }
                
                  inline float
                  pow(float __x, int __n)
                  { return __builtin_powif(__x, __n); }
                
                  inline long double
                  pow(long double __x, int __n)
                  { return __builtin_powil(__x, __n); }
                #endif
                #endif
                
                  template<typename _Tp, typename _Up>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    pow(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return pow(__type(__x), __type(__y));
                    }
                
                  using ::sin;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  sin(float __x)
                  { return __builtin_sinf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  sin(long double __x)
                  { return __builtin_sinl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    sin(_Tp __x)
                    { return __builtin_sin(__x); }
                
                  using ::sinh;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  sinh(float __x)
                  { return __builtin_sinhf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  sinh(long double __x)
                  { return __builtin_sinhl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    sinh(_Tp __x)
                    { return __builtin_sinh(__x); }
                
                  using ::sqrt;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  sqrt(float __x)
                  { return __builtin_sqrtf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  sqrt(long double __x)
                  { return __builtin_sqrtl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    sqrt(_Tp __x)
                    { return __builtin_sqrt(__x); }
                
                  using ::tan;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  tan(float __x)
                  { return __builtin_tanf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  tan(long double __x)
                  { return __builtin_tanl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    tan(_Tp __x)
                    { return __builtin_tan(__x); }
                
                  using ::tanh;
                
                #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
                  inline _GLIBCXX_CONSTEXPR float
                  tanh(float __x)
                  { return __builtin_tanhf(__x); }
                
                  inline _GLIBCXX_CONSTEXPR long double
                  tanh(long double __x)
                  { return __builtin_tanhl(__x); }
                #endif
                
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    double>::__type
                    tanh(_Tp __x)
                    { return __builtin_tanh(__x); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if _GLIBCXX_USE_C99_MATH
                #if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC
                
                // These are possible macros imported from C99-land.
                #undef fpclassify
                #undef isfinite
                #undef isinf
                #undef isnan
                #undef isnormal
                #undef signbit
                #undef isgreater
                #undef isgreaterequal
                #undef isless
                #undef islessequal
                #undef islessgreater
                #undef isunordered
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201103L
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr int
                  fpclassify(float __x)
                  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
                				FP_SUBNORMAL, FP_ZERO, __x); }
                
                  constexpr int
                  fpclassify(double __x)
                  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
                				FP_SUBNORMAL, FP_ZERO, __x); }
                
                  constexpr int
                  fpclassify(long double __x)
                  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
                				FP_SUBNORMAL, FP_ZERO, __x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                              int>::__type
                    fpclassify(_Tp __x)
                    { return __x != 0 ? FP_NORMAL : FP_ZERO; }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isfinite(float __x)
                  { return __builtin_isfinite(__x); }
                
                  constexpr bool
                  isfinite(double __x)
                  { return __builtin_isfinite(__x); }
                
                  constexpr bool
                  isfinite(long double __x)
                  { return __builtin_isfinite(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                              bool>::__type
                    isfinite(_Tp __x)
                    { return true; }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isinf(float __x)
                  { return __builtin_isinf(__x); }
                
                  constexpr bool
                  isinf(double __x)
                  { return __builtin_isinf(__x); }
                
                  constexpr bool
                  isinf(long double __x)
                  { return __builtin_isinf(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                              bool>::__type
                    isinf(_Tp __x)
                    { return false; }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isnan(float __x)
                  { return __builtin_isnan(__x); }
                
                  constexpr bool
                  isnan(double __x)
          78 ->   { return __builtin_isnan(__x); }
                
                  constexpr bool
                  isnan(long double __x)
                  { return __builtin_isnan(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                              bool>::__type
                    isnan(_Tp __x)
                    { return false; }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isnormal(float __x)
                  { return __builtin_isnormal(__x); }
                
                  constexpr bool
                  isnormal(double __x)
                  { return __builtin_isnormal(__x); }
                
                  constexpr bool
                  isnormal(long double __x)
                  { return __builtin_isnormal(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                              bool>::__type
                    isnormal(_Tp __x)
                    { return __x != 0 ? true : false; }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  // The front-end doesn't provide a type generic builtin (libstdc++/58625).
                  constexpr bool
                  signbit(float __x)
                  { return __builtin_signbitf(__x); }
                
                  constexpr bool
                  signbit(double __x)
                  { return __builtin_signbit(__x); }
                
                  constexpr bool
                  signbit(long double __x)
                  { return __builtin_signbitl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                              bool>::__type
                    signbit(_Tp __x)
                    { return __x < 0 ? true : false; }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isgreater(float __x, float __y)
                  { return __builtin_isgreater(__x, __y); }
                
                  constexpr bool
                  isgreater(double __x, double __y)
                  { return __builtin_isgreater(__x, __y); }
                
                  constexpr bool
                  isgreater(long double __x, long double __y)
                  { return __builtin_isgreater(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename
                    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
                			    && __is_arithmetic<_Up>::__value), bool>::__type
                    isgreater(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return __builtin_isgreater(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isgreaterequal(float __x, float __y)
                  { return __builtin_isgreaterequal(__x, __y); }
                
                  constexpr bool
                  isgreaterequal(double __x, double __y)
                  { return __builtin_isgreaterequal(__x, __y); }
                
                  constexpr bool
                  isgreaterequal(long double __x, long double __y)
                  { return __builtin_isgreaterequal(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename
                    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
                			    && __is_arithmetic<_Up>::__value), bool>::__type
                    isgreaterequal(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return __builtin_isgreaterequal(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isless(float __x, float __y)
                  { return __builtin_isless(__x, __y); }
                
                  constexpr bool
                  isless(double __x, double __y)
                  { return __builtin_isless(__x, __y); }
                
                  constexpr bool
                  isless(long double __x, long double __y)
                  { return __builtin_isless(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename
                    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
                			    && __is_arithmetic<_Up>::__value), bool>::__type
                    isless(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return __builtin_isless(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  islessequal(float __x, float __y)
                  { return __builtin_islessequal(__x, __y); }
                
                  constexpr bool
                  islessequal(double __x, double __y)
                  { return __builtin_islessequal(__x, __y); }
                
                  constexpr bool
                  islessequal(long double __x, long double __y)
                  { return __builtin_islessequal(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename
                    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
                			    && __is_arithmetic<_Up>::__value), bool>::__type
                    islessequal(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return __builtin_islessequal(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  islessgreater(float __x, float __y)
                  { return __builtin_islessgreater(__x, __y); }
                
                  constexpr bool
                  islessgreater(double __x, double __y)
                  { return __builtin_islessgreater(__x, __y); }
                
                  constexpr bool
                  islessgreater(long double __x, long double __y)
                  { return __builtin_islessgreater(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename
                    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
                			    && __is_arithmetic<_Up>::__value), bool>::__type
                    islessgreater(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return __builtin_islessgreater(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr bool
                  isunordered(float __x, float __y)
                  { return __builtin_isunordered(__x, __y); }
                
                  constexpr bool
                  isunordered(double __x, double __y)
                  { return __builtin_isunordered(__x, __y); }
                
                  constexpr bool
                  isunordered(long double __x, long double __y)
                  { return __builtin_isunordered(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename
                    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
                			    && __is_arithmetic<_Up>::__value), bool>::__type
                    isunordered(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return __builtin_isunordered(__type(__x), __type(__y));
                    }
                
                #else
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    fpclassify(_Tp __f)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
                				  FP_SUBNORMAL, FP_ZERO, __type(__f));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isfinite(_Tp __f)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isfinite(__type(__f));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isinf(_Tp __f)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isinf(__type(__f));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isnan(_Tp __f)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isnan(__type(__f));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isnormal(_Tp __f)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isnormal(__type(__f));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    signbit(_Tp __f)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return sizeof(__type) == sizeof(float)
                	? __builtin_signbitf(__type(__f))
                	: sizeof(__type) == sizeof(double)
                	? __builtin_signbit(__type(__f))
                	: __builtin_signbitl(__type(__f));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isgreater(_Tp __f1, _Tp __f2)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isgreater(__type(__f1), __type(__f2));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isgreaterequal(_Tp __f1, _Tp __f2)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isless(_Tp __f1, _Tp __f2)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isless(__type(__f1), __type(__f2));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    islessequal(_Tp __f1, _Tp __f2)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_islessequal(__type(__f1), __type(__f2));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    islessgreater(_Tp __f1, _Tp __f2)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_islessgreater(__type(__f1), __type(__f2));
                    }
                
                  template<typename _Tp>
                    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
                					   int>::__type
                    isunordered(_Tp __f1, _Tp __f2)
                    {
                      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
                      return __builtin_isunordered(__type(__f1), __type(__f2));
                    }
                
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC */
                #endif
                
                #if __cplusplus >= 201103L
                
                #ifdef _GLIBCXX_USE_C99_MATH_TR1
                
                #undef acosh
                #undef acoshf
                #undef acoshl
                #undef asinh
                #undef asinhf
                #undef asinhl
                #undef atanh
                #undef atanhf
                #undef atanhl
                #undef cbrt
                #undef cbrtf
                #undef cbrtl
                #undef copysign
                #undef copysignf
                #undef copysignl
                #undef erf
                #undef erff
                #undef erfl
                #undef erfc
                #undef erfcf
                #undef erfcl
                #undef exp2
                #undef exp2f
                #undef exp2l
                #undef expm1
                #undef expm1f
                #undef expm1l
                #undef fdim
                #undef fdimf
                #undef fdiml
                #undef fma
                #undef fmaf
                #undef fmal
                #undef fmax
                #undef fmaxf
                #undef fmaxl
                #undef fmin
                #undef fminf
                #undef fminl
                #undef hypot
                #undef hypotf
                #undef hypotl
                #undef ilogb
                #undef ilogbf
                #undef ilogbl
                #undef lgamma
                #undef lgammaf
                #undef lgammal
                #undef llrint
                #undef llrintf
                #undef llrintl
                #undef llround
                #undef llroundf
                #undef llroundl
                #undef log1p
                #undef log1pf
                #undef log1pl
                #undef log2
                #undef log2f
                #undef log2l
                #undef logb
                #undef logbf
                #undef logbl
                #undef lrint
                #undef lrintf
                #undef lrintl
                #undef lround
                #undef lroundf
                #undef lroundl
                #undef nan
                #undef nanf
                #undef nanl
                #undef nearbyint
                #undef nearbyintf
                #undef nearbyintl
                #undef nextafter
                #undef nextafterf
                #undef nextafterl
                #undef nexttoward
                #undef nexttowardf
                #undef nexttowardl
                #undef remainder
                #undef remainderf
                #undef remainderl
                #undef remquo
                #undef remquof
                #undef remquol
                #undef rint
                #undef rintf
                #undef rintl
                #undef round
                #undef roundf
                #undef roundl
                #undef scalbln
                #undef scalblnf
                #undef scalblnl
                #undef scalbn
                #undef scalbnf
                #undef scalbnl
                #undef tgamma
                #undef tgammaf
                #undef tgammal
                #undef trunc
                #undef truncf
                #undef truncl
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // types
                  using ::double_t;
                  using ::float_t;
                
                  // functions
                  using ::acosh;
                  using ::acoshf;
                  using ::acoshl;
                
                  using ::asinh;
                  using ::asinhf;
                  using ::asinhl;
                
                  using ::atanh;
                  using ::atanhf;
                  using ::atanhl;
                
                  using ::cbrt;
                  using ::cbrtf;
                  using ::cbrtl;
                
                  using ::copysign;
                  using ::copysignf;
                  using ::copysignl;
                
                  using ::erf;
                  using ::erff;
                  using ::erfl;
                
                  using ::erfc;
                  using ::erfcf;
                  using ::erfcl;
                
                  using ::exp2;
                  using ::exp2f;
                  using ::exp2l;
                
                  using ::expm1;
                  using ::expm1f;
                  using ::expm1l;
                
                  using ::fdim;
                  using ::fdimf;
                  using ::fdiml;
                
                  using ::fma;
                  using ::fmaf;
                  using ::fmal;
                
                  using ::fmax;
                  using ::fmaxf;
                  using ::fmaxl;
                
                  using ::fmin;
                  using ::fminf;
                  using ::fminl;
                
                  using ::hypot;
                  using ::hypotf;
                  using ::hypotl;
                
                  using ::ilogb;
                  using ::ilogbf;
                  using ::ilogbl;
                
                  using ::lgamma;
                  using ::lgammaf;
                  using ::lgammal;
                
                  using ::llrint;
                  using ::llrintf;
                  using ::llrintl;
                
                  using ::llround;
                  using ::llroundf;
                  using ::llroundl;
                
                  using ::log1p;
                  using ::log1pf;
                  using ::log1pl;
                
                  using ::log2;
                  using ::log2f;
                  using ::log2l;
                
                  using ::logb;
                  using ::logbf;
                  using ::logbl;
                
                  using ::lrint;
                  using ::lrintf;
                  using ::lrintl;
                
                  using ::lround;
                  using ::lroundf;
                  using ::lroundl;
                
                  using ::nan;
                  using ::nanf;
                  using ::nanl;
                
                  using ::nearbyint;
                  using ::nearbyintf;
                  using ::nearbyintl;
                
                  using ::nextafter;
                  using ::nextafterf;
                  using ::nextafterl;
                
                  using ::nexttoward;
                  using ::nexttowardf;
                  using ::nexttowardl;
                
                  using ::remainder;
                  using ::remainderf;
                  using ::remainderl;
                
                  using ::remquo;
                  using ::remquof;
                  using ::remquol;
                
                  using ::rint;
                  using ::rintf;
                  using ::rintl;
                
                  using ::round;
                  using ::roundf;
                  using ::roundl;
                
                  using ::scalbln;
                  using ::scalblnf;
                  using ::scalblnl;
                
                  using ::scalbn;
                  using ::scalbnf;
                  using ::scalbnl;
                
                  using ::tgamma;
                  using ::tgammaf;
                  using ::tgammal;
                
                  using ::trunc;
                  using ::truncf;
                  using ::truncl;
                
                  /// Additional overloads.
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  acosh(float __x)
                  { return __builtin_acoshf(__x); }
                
                  constexpr long double
                  acosh(long double __x)
                  { return __builtin_acoshl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    acosh(_Tp __x)
                    { return __builtin_acosh(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  asinh(float __x)
                  { return __builtin_asinhf(__x); }
                
                  constexpr long double
                  asinh(long double __x)
                  { return __builtin_asinhl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    asinh(_Tp __x)
                    { return __builtin_asinh(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  atanh(float __x)
                  { return __builtin_atanhf(__x); }
                
                  constexpr long double
                  atanh(long double __x)
                  { return __builtin_atanhl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    atanh(_Tp __x)
                    { return __builtin_atanh(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  cbrt(float __x)
                  { return __builtin_cbrtf(__x); }
                
                  constexpr long double
                  cbrt(long double __x)
                  { return __builtin_cbrtl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    cbrt(_Tp __x)
                    { return __builtin_cbrt(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  copysign(float __x, float __y)
                  { return __builtin_copysignf(__x, __y); }
                
                  constexpr long double
                  copysign(long double __x, long double __y)
                  { return __builtin_copysignl(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    copysign(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return copysign(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  erf(float __x)
                  { return __builtin_erff(__x); }
                
                  constexpr long double
                  erf(long double __x)
                  { return __builtin_erfl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    erf(_Tp __x)
                    { return __builtin_erf(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  erfc(float __x)
                  { return __builtin_erfcf(__x); }
                
                  constexpr long double
                  erfc(long double __x)
                  { return __builtin_erfcl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    erfc(_Tp __x)
                    { return __builtin_erfc(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  exp2(float __x)
                  { return __builtin_exp2f(__x); }
                
                  constexpr long double
                  exp2(long double __x)
                  { return __builtin_exp2l(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    exp2(_Tp __x)
                    { return __builtin_exp2(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  expm1(float __x)
                  { return __builtin_expm1f(__x); }
                
                  constexpr long double
                  expm1(long double __x)
                  { return __builtin_expm1l(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    expm1(_Tp __x)
                    { return __builtin_expm1(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  fdim(float __x, float __y)
                  { return __builtin_fdimf(__x, __y); }
                
                  constexpr long double
                  fdim(long double __x, long double __y)
                  { return __builtin_fdiml(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    fdim(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return fdim(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  fma(float __x, float __y, float __z)
                  { return __builtin_fmaf(__x, __y, __z); }
                
                  constexpr long double
                  fma(long double __x, long double __y, long double __z)
                  { return __builtin_fmal(__x, __y, __z); }
                #endif
                
                  template<typename _Tp, typename _Up, typename _Vp>
                    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
                    fma(_Tp __x, _Up __y, _Vp __z)
                    {
                      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
                      return fma(__type(__x), __type(__y), __type(__z));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  fmax(float __x, float __y)
                  { return __builtin_fmaxf(__x, __y); }
                
                  constexpr long double
                  fmax(long double __x, long double __y)
                  { return __builtin_fmaxl(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    fmax(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return fmax(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  fmin(float __x, float __y)
                  { return __builtin_fminf(__x, __y); }
                
                  constexpr long double
                  fmin(long double __x, long double __y)
                  { return __builtin_fminl(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    fmin(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return fmin(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  hypot(float __x, float __y)
                  { return __builtin_hypotf(__x, __y); }
                
                  constexpr long double
                  hypot(long double __x, long double __y)
                  { return __builtin_hypotl(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    hypot(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return hypot(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr int
                  ilogb(float __x)
                  { return __builtin_ilogbf(__x); }
                
                  constexpr int
                  ilogb(long double __x)
                  { return __builtin_ilogbl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr
                    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                    int>::__type
                    ilogb(_Tp __x)
                    { return __builtin_ilogb(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  lgamma(float __x)
                  { return __builtin_lgammaf(__x); }
                
                  constexpr long double
                  lgamma(long double __x)
                  { return __builtin_lgammal(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    lgamma(_Tp __x)
                    { return __builtin_lgamma(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr long long
                  llrint(float __x)
                  { return __builtin_llrintf(__x); }
                
                  constexpr long long
                  llrint(long double __x)
                  { return __builtin_llrintl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              long long>::__type
                    llrint(_Tp __x)
                    { return __builtin_llrint(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr long long
                  llround(float __x)
                  { return __builtin_llroundf(__x); }
                
                  constexpr long long
                  llround(long double __x)
                  { return __builtin_llroundl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              long long>::__type
                    llround(_Tp __x)
                    { return __builtin_llround(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  log1p(float __x)
                  { return __builtin_log1pf(__x); }
                
                  constexpr long double
                  log1p(long double __x)
                  { return __builtin_log1pl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    log1p(_Tp __x)
                    { return __builtin_log1p(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  // DR 568.
                  constexpr float
                  log2(float __x)
                  { return __builtin_log2f(__x); }
                
                  constexpr long double
                  log2(long double __x)
                  { return __builtin_log2l(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    log2(_Tp __x)
                    { return __builtin_log2(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  logb(float __x)
                  { return __builtin_logbf(__x); }
                
                  constexpr long double
                  logb(long double __x)
                  { return __builtin_logbl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    logb(_Tp __x)
                    { return __builtin_logb(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr long
                  lrint(float __x)
                  { return __builtin_lrintf(__x); }
                
                  constexpr long
                  lrint(long double __x)
                  { return __builtin_lrintl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              long>::__type
                    lrint(_Tp __x)
                    { return __builtin_lrint(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr long
                  lround(float __x)
                  { return __builtin_lroundf(__x); }
                
                  constexpr long
                  lround(long double __x)
                  { return __builtin_lroundl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              long>::__type
                    lround(_Tp __x)
                    { return __builtin_lround(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  nearbyint(float __x)
                  { return __builtin_nearbyintf(__x); }
                
                  constexpr long double
                  nearbyint(long double __x)
                  { return __builtin_nearbyintl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    nearbyint(_Tp __x)
                    { return __builtin_nearbyint(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  nextafter(float __x, float __y)
                  { return __builtin_nextafterf(__x, __y); }
                
                  constexpr long double
                  nextafter(long double __x, long double __y)
                  { return __builtin_nextafterl(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    nextafter(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return nextafter(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  nexttoward(float __x, long double __y)
                  { return __builtin_nexttowardf(__x, __y); }
                
                  constexpr long double
                  nexttoward(long double __x, long double __y)
                  { return __builtin_nexttowardl(__x, __y); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    nexttoward(_Tp __x, long double __y)
                    { return __builtin_nexttoward(__x, __y); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  remainder(float __x, float __y)
                  { return __builtin_remainderf(__x, __y); }
                
                  constexpr long double
                  remainder(long double __x, long double __y)
                  { return __builtin_remainderl(__x, __y); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    remainder(_Tp __x, _Up __y)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return remainder(__type(__x), __type(__y));
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  inline float
                  remquo(float __x, float __y, int* __pquo)
                  { return __builtin_remquof(__x, __y, __pquo); }
                
                  inline long double
                  remquo(long double __x, long double __y, int* __pquo)
                  { return __builtin_remquol(__x, __y, __pquo); }
                #endif
                
                  template<typename _Tp, typename _Up>
                    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
                    remquo(_Tp __x, _Up __y, int* __pquo)
                    {
                      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
                      return remquo(__type(__x), __type(__y), __pquo);
                    }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  rint(float __x)
                  { return __builtin_rintf(__x); }
                
                  constexpr long double
                  rint(long double __x)
                  { return __builtin_rintl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    rint(_Tp __x)
                    { return __builtin_rint(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  round(float __x)
                  { return __builtin_roundf(__x); }
                
                  constexpr long double
                  round(long double __x)
                  { return __builtin_roundl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    round(_Tp __x)
                    { return __builtin_round(__x); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  scalbln(float __x, long __ex)
                  { return __builtin_scalblnf(__x, __ex); }
                
                  constexpr long double
                  scalbln(long double __x, long __ex)
                  { return __builtin_scalblnl(__x, __ex); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    scalbln(_Tp __x, long __ex)
                    { return __builtin_scalbln(__x, __ex); }
                 
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  scalbn(float __x, int __ex)
                  { return __builtin_scalbnf(__x, __ex); }
                
                  constexpr long double
                  scalbn(long double __x, int __ex)
                  { return __builtin_scalbnl(__x, __ex); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    scalbn(_Tp __x, int __ex)
                    { return __builtin_scalbn(__x, __ex); }
                
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  tgamma(float __x)
                  { return __builtin_tgammaf(__x); }
                
                  constexpr long double
                  tgamma(long double __x)
                  { return __builtin_tgammal(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    tgamma(_Tp __x)
                    { return __builtin_tgamma(__x); }
                 
                #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO
                  constexpr float
                  trunc(float __x)
                  { return __builtin_truncf(__x); }
                
                  constexpr long double
                  trunc(long double __x)
                  { return __builtin_truncl(__x); }
                #endif
                
                  template<typename _Tp>
                    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                                              double>::__type
                    trunc(_Tp __x)
                    { return __builtin_trunc(__x); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif // _GLIBCXX_USE_C99_MATH_TR1
                
                #endif // C++11
                
                #endif


Top 10 Lines:

     Line      Count

      631         78

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       78   Total number of line executions
    78.00   Average executions per line


*** File /home/sbillah/dmclock/sim/../support/src/indirect_intrusive_heap.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                
                #include <memory>
                #include <vector>
                #include <string>
                #include <iostream>
                #include <functional>
                
                #include "assert.h"
                
                
                namespace crimson {
                  using IndIntruHeapData = size_t;
                
                  /* T is the ultimate data that's being stored in the heap, although
                   *   through indirection.
                   *
                   * I is the indirect type that will actually be stored in the heap
                   *   and that must allow dereferencing (via operator*) to yield a
                   *   T&.
                   *
                   * C is a functor when given two T&'s will return true if the first
                   *   must precede the second.
                   *
                   * heap_info is a data member pointer as to where the heap data in T
                   * is stored.
                   */
                  template<typename I, typename T, IndIntruHeapData T::*heap_info, typename C>
       ##### ->   class IndIntruHeap {
                
                    static_assert(
                      std::is_same<T,typename std::pointer_traits<I>::element_type>::value,
                      "class I must resolve to class T by indirection (pointer dereference)");
                
                    static_assert(
                      std::is_same<bool,
                      typename std::result_of<C(const T&,const T&)>::type>::value,
                      "class C must define operator() to take two const T& and return a bool");
                
                
                    class Iterator {
                      friend IndIntruHeap<I, T, heap_info, C>;
                
                      IndIntruHeap<I, T, heap_info, C>& heap;
                      size_t                            index;
                
       ##### ->       Iterator(IndIntruHeap<I, T, heap_info, C>& _heap, size_t _index) :
                	heap(_heap),
                	index(_index)
                      {
                	// empty
                      }
                
                    public:
                
                      Iterator(Iterator&& other) :
                	heap(other.heap),
                	index(other.index)
                      {
                	// empty
                      }
                
                      Iterator(const Iterator& other) :
                	heap(other.heap),
                	index(other.index)
                      {
                	// empty
                      }
                
       ##### ->       Iterator& operator=(Iterator&& other) {
                	std::swap(heap, other.heap);
                	std::swap(index, other.index);
                	return *this;
                      }
                
                      Iterator& operator=(const Iterator& other) {
                	heap = other.heap;
                	index = other.index;
                      }
                
                      Iterator& operator++() {
                	if (index <= heap.count) {
                	  ++index;
                	}
                	return *this;
                      }
                
                      bool operator==(const Iterator& other) const {
                	return index == other.index;
                      }
                
                      bool operator!=(const Iterator& other) const {
                	return !(*this == other);
                      }
                
                      T& operator*() {
                	return *heap.data[index];
                      }
                
                      T* operator->() {
                	return &(*heap.data[index]);
                      }
                
                #if 0
                      // the item this iterator refers to
                      void increase() {
                	heap.siftUp(index);
                      }
                #endif
                    }; // class Iterator
                
                    
                    class ConstIterator {
                      friend IndIntruHeap<I, T, heap_info, C>;
                
                      const IndIntruHeap<I, T, heap_info, C>& heap;
                      size_t                                  index;
                
                      ConstIterator(const IndIntruHeap<I, T, heap_info, C>& _heap, size_t _index) :
                	heap(_heap),
                	index(_index)
                      {
                	// empty
                      }
                
                    public:
                
                      ConstIterator(ConstIterator&& other) :
                	heap(other.heap),
                	index(other.index)
                      {
                	// empty
                      }
                
                      ConstIterator(const ConstIterator& other) :
                	heap(other.heap),
                	index(other.index)
                      {
                	// empty
                      }
                
                      ConstIterator& operator=(ConstIterator&& other) {
                	std::swap(heap, other.heap);
                	std::swap(index, other.index);
                	return *this;
                      }
                
                      ConstIterator& operator=(const ConstIterator& other) {
                	heap = other.heap;
                	index = other.index;
                      }
                
                      ConstIterator& operator++() {
                	if (index <= heap.count) {
                	  ++index;
                	}
                	return *this;
                      }
                
                      bool operator==(const ConstIterator& other) const {
                	return &heap == &other.heap && index == other.index;
                      }
                
                      bool operator!=(const ConstIterator& other) const {
                	return !(*this == other);
                      }
                
                      const T& operator*() {
                	return *heap.data[index];
                      }
                
                      const T* operator->() {
                	return &(*heap.data[index]);
                      }
                    }; // class ConstIterator
                
                    
                  protected:
                    using index_t = IndIntruHeapData;
                
                    std::vector<I> data;
                    index_t        count;
                    C              comparator;
                
                  public:
                
         300 ->     IndIntruHeap() :
                      count(0)
                    {
                      // empty
                    }
                
       ##### ->     IndIntruHeap(const IndIntruHeap<I,T,heap_info,C>& other) :
                      count(other.count)
                    {
                      for (uint i = 0; i < other.count; ++i) {
                	data.push_back(other.data[i]);
                      }
                    }
                
       ##### ->     bool empty() const { return 0 == count; }
                
                    size_t size() const { return count; }
                
       ##### ->     T& top() { return *data[0]; }
                
                    const T& top() const { return *data[0]; }
                
                    I& top_ind() { return data[0]; }
                
                    const I& top_ind() const { return data[0]; }
                
       ##### ->     void push(I&& item) {
                      index_t i = count++;
                      intru_data_of(item) = i;
                      data.emplace_back(std::move(item));
                      sift_up(i);
                    }
                
       ##### ->     void push(const I& item) {
                      I copy(item);
                      push(std::move(copy));
                    }
                
                    void pop() {
                      remove(0);
                    }
                
       ##### ->     void remove(Iterator& i) {
                      remove(i.index);
                      i = end();
                    }
                
                    Iterator find(const I& item) {
                      for (index_t i = 0; i < count; ++i) {
                	if (data[i] == item) {
                	  return Iterator(*this, i);
                	}
                      }
                      return end();
                    }
                
                    // NB: should we be using operator== instead of address check?
                    Iterator find(const T& item) {
                      for (index_t i = 0; i < count; ++i) {
                	if (data[i].get() == &item) {
                	  return Iterator(*this, i);
                	}
                      }
                      return end();
                    }
                
                    // reverse find -- start looking from bottom of heap
       ##### ->     Iterator rfind(const I& item) {
                      // index_t is unsigned, so we can't allow to go negative; so
                      // we'll keep it one more than actual index
                      for (index_t i = count; i > 0; --i) {
                	if (data[i-1] == item) {
                	  return Iterator(*this, i-1);
                	}
                      }
                      return end();
                    }
                
                    // reverse find -- start looking from bottom of heap
                    Iterator rfind(const T& item) {
                      // index_t is unsigned, so we can't allow to go negative; so
                      // we'll keep it one more than actual index
                      for (index_t i = count; i > 0; --i) {
                	if (data[i-1].get() == &item) {
                	  return Iterator(*this, i-1);
                	}
                      }
                      return end();
                    }
                
       ##### ->     void promote(T& item) {
                      sift_up(item.*heap_info);
                    }
                
       ##### ->     void demote(T& item) {
                      sift_down(item.*heap_info);
                    }
                
       ##### ->     void adjust(T& item) {
                      sift(item.*heap_info);
                    }
                
                    Iterator begin() {
                      return Iterator(*this, 0);
                    }
                
       ##### ->     Iterator end() {
                      return Iterator(*this, count);
                    }
                
                    ConstIterator cbegin() const {
                      return ConstIterator(*this, 0);
                    }
                
                    ConstIterator cend() const {
                      return ConstIterator(*this, count);
                    }
                
                    friend std::ostream& operator<<(std::ostream& out, const IndIntruHeap& h) {
                      auto i = h.data.cbegin();
                      if (i != h.data.cend()) {
                	out << **i;
                	++i;
                	while (i != h.data.cend()) {
                	  out << ", " << **i;
                	}
                      }
                      return out;
                    }
                
                    // can only be called if I is copyable
                    std::ostream&
                    display_sorted(std::ostream& out,
                		   std::function<bool(const T&)> filter = all_filter) const {
                      static_assert(std::is_copy_constructible<I>::value,
                		    "cannot call display_sorted when class I is not copy"
                		    " constructible");
                
                      IndIntruHeap<I,T,heap_info,C> copy = *this;
                
                      bool first = true;
                      while(!copy.empty()) {
                	const T& top = copy.top();
                	if (filter(top)) {
                	  if (!first) {
                	    out << ", ";
                	  }
                	  out << copy.top();
                	  first = false;
                	}
                	copy.pop();
                      }
                
                      return out;
                    }
                
                
                  protected:
                
       ##### ->     static index_t& intru_data_of(I& item) {
                      return (*item).*heap_info;
                    }
                
       ##### ->     void remove(index_t i) {
                      std::swap(data[i], data[--count]);
                      intru_data_of(data[i]) = i;
                      data.pop_back();
                      sift_down(i);
                    }
                
                    // default value of filter parameter to display_sorted
                    static bool all_filter(const T& data) { return true; }
                
                    // when i is negative?
       ##### ->     static inline index_t parent(index_t i) {
                      assert(0 != i);
                      return (i - 1) / 2;
                    }
                
       ##### ->     static inline index_t lhs(index_t i) { return 2*i + 1; }
                
       ##### ->     static inline index_t rhs(index_t i) { return 2*i + 2; }
                
       ##### ->     void sift_up(index_t i) {
                      while (i > 0) {
                	index_t pi = parent(i);
                	if (!comparator(*data[i], *data[pi])) {
                	  break;
                	}
                
                	std::swap(data[i], data[pi]);
                	intru_data_of(data[i]) = i;
                	intru_data_of(data[pi]) = pi;
                	i = pi;
                      }
                    } // sift_up
                
       ##### ->     void sift_down(index_t i) {
                      while (i < count) {
                	index_t li = lhs(i);
                	index_t ri = rhs(i);
                
                	if (li < count) {
                	  if (comparator(*data[li], *data[i])) {
                	    if (ri < count && comparator(*data[ri], *data[li])) {
                	      std::swap(data[i], data[ri]);
                	      intru_data_of(data[i]) = i;
                	      intru_data_of(data[ri]) = ri;
                	      i = ri;
                	    } else {
                	      std::swap(data[i], data[li]);
                	      intru_data_of(data[i]) = i;
                	      intru_data_of(data[li]) = li;
                	      i = li;
                	    }
                	  } else if (ri < count && comparator(*data[ri], *data[i])) {
                	    std::swap(data[i], data[ri]);
                	    intru_data_of(data[i]) = i;
                	    intru_data_of(data[ri]) = ri;
                	    i = ri;
                	  } else {
                	    break;
                	  }
                	} else {
                	  break;
                	}
                      }
                    } // sift_down
                
       ##### ->     void sift(index_t i) {
                      if (i == 0) {
                	// if we're at top, can only go down
                	sift_down(i);
                      } else {
                	index_t pi = parent(i);
                	if (comparator(*data[i], *data[pi])) {
                	  // if we can go up, we will
                	  sift_up(i);
                	} else {
                	  // otherwise we'll try to go down
                	  sift_down(i);
                	}
                      }
                    } // sift
                  }; // class IndIntruHeap
                } // namespace crimson


Top 10 Lines:

     Line      Count

      196        300

Execution Summary:

       23   Executable lines in this file
       23   Lines executed
   100.00   Percent of the file executed

      300   Total number of line executions
    13.04   Average executions per line


*** File /usr/include/c++/5/bits/stl_pair.h:
                // Pair implementation -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_pair.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _STL_PAIR_H
                #define _STL_PAIR_H 1
                
                #include <bits/move.h> // for std::move / std::forward, and std::swap
                
                #if __cplusplus >= 201103L
                #include <type_traits> // for std::__decay_and_strip too
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                #if __cplusplus >= 201103L
                  /// piecewise_construct_t
                  struct piecewise_construct_t { };
                
                  /// piecewise_construct
                  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
                
                  // Forward declarations.
                  template<typename...>
                    class tuple;
                
                  template<std::size_t...>
                    struct _Index_tuple;
                #endif
                
                 /**
                   *  @brief Struct holding two objects of arbitrary type.
                   *
                   *  @tparam _T1  Type of first object.
                   *  @tparam _T2  Type of second object.
                   */
                  template<class _T1, class _T2>
          10 ->     struct pair
                    {
                      typedef _T1 first_type;    /// @c first_type is the first bound type
                      typedef _T2 second_type;   /// @c second_type is the second bound type
                
                      _T1 first;                 /// @c first is a copy of the first object
                      _T2 second;                /// @c second is a copy of the second object
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 265.  std::pair::pair() effects overly restrictive
                      /** The default constructor creates @c first and @c second using their
                       *  respective default constructors.  */
                      _GLIBCXX_CONSTEXPR pair()
                      : first(), second() { }
                
                      /** Two objects may be passed to a @c pair constructor to be copied.  */
                      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                
                      /** There is also a templated copy ctor for the @c pair class itself.  */
                #if __cplusplus < 201103L
                      template<class _U1, class _U2>
                	pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                #else
                      template<class _U1, class _U2, class = typename
                	       enable_if<__and_<is_convertible<const _U1&, _T1>,
                				is_convertible<const _U2&, _T2>>::value>::type>
                	constexpr pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                
                      constexpr pair(const pair&) = default;
                      constexpr pair(pair&&) = default;
                
                      // DR 811.
                      template<class _U1, class = typename
                	       enable_if<is_convertible<_U1, _T1>::value>::type>
       ##### -> 	constexpr pair(_U1&& __x, const _T2& __y)
                	: first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<class _U2, class = typename
                	       enable_if<is_convertible<_U2, _T2>::value>::type>
         192 -> 	constexpr pair(const _T1& __x, _U2&& __y)
                	: first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<class _U1, class _U2, class = typename
                	       enable_if<__and_<is_convertible<_U1, _T1>,
                				is_convertible<_U2, _T2>>::value>::type>
         250 -> 	constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                      template<class _U1, class _U2, class = typename
                	       enable_if<__and_<is_convertible<_U1, _T1>,
                				is_convertible<_U2, _T2>>::value>::type>
                	constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename... _Args1, typename... _Args2>
                        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
                
                      pair&
       ##### ->       operator=(const pair& __p)
                      {
                	first = __p.first;
                	second = __p.second;
                	return *this;
                      }
                
                      pair&
                      operator=(pair&& __p)
                      noexcept(__and_<is_nothrow_move_assignable<_T1>,
                	              is_nothrow_move_assignable<_T2>>::value)
                      {
                	first = std::forward<first_type>(__p.first);
                	second = std::forward<second_type>(__p.second);
                	return *this;
                      }
                
                      template<class _U1, class _U2>
                	pair&
                	operator=(const pair<_U1, _U2>& __p)
                	{
                	  first = __p.first;
                	  second = __p.second;
                	  return *this;
                	}
                
                      template<class _U1, class _U2>
                	pair&
                	operator=(pair<_U1, _U2>&& __p)
                	{
                	  first = std::forward<_U1>(__p.first);
                	  second = std::forward<_U2>(__p.second);
                	  return *this;
                	}
                
                      void
                      swap(pair& __p)
                      noexcept(noexcept(swap(first, __p.first))
                	       && noexcept(swap(second, __p.second)))
                      {
                	using std::swap;
                	swap(first, __p.first);
                	swap(second, __p.second);
                      }
                
                    private:
                      template<typename... _Args1, std::size_t... _Indexes1,
                               typename... _Args2, std::size_t... _Indexes2>
                        pair(tuple<_Args1...>&, tuple<_Args2...>&,
                             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
                #endif
                    };
                
                  /// Two pairs of the same type are equal iff their members are equal.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first == __y.first && __x.second == __y.second; }
                
                  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first < __y.first
                	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                
                  /// Uses @c operator== to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x == __y); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __y < __x; }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__y < __x); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x < __y); }
                
                #if __cplusplus >= 201103L
                  /// See std::pair::swap().
                  // Note:  no std::swap overloads in C++03 mode, this has performance
                  //        implications, see, eg, libstdc++/38466.
                  template<class _T1, class _T2>
                    inline void
                    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                #endif
                
                  /**
                   *  @brief A convenience wrapper for creating a pair from two objects.
                   *  @param  __x  The first object.
                   *  @param  __y  The second object.
                   *  @return   A newly-constructed pair<> object of the appropriate type.
                   *
                   *  The standard requires that the objects be passed by reference-to-const,
                   *  but LWG issue #181 says they should be passed by const value.  We follow
                   *  the LWG by default.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 181.  make_pair() unintended behavior
                #if __cplusplus >= 201103L
                  // NB: DR 706.
                  template<class _T1, class _T2>
                    constexpr pair<typename __decay_and_strip<_T1>::__type,
                                   typename __decay_and_strip<_T2>::__type>
                    make_pair(_T1&& __x, _T2&& __y)
                    {
                      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
                      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
                      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
                      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
                    }
                #else
                  template<class _T1, class _T2>
                    inline pair<_T1, _T2>
                    make_pair(_T1 __x, _T2 __y)
                    { return pair<_T1, _T2>(__x, __y); }
                #endif
                
                  /// @}
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_PAIR_H */


Top 10 Lines:

     Line      Count

      144        250
      138        192
       96         10

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

      452   Total number of line executions
    90.40   Average executions per line


*** File /usr/include/c++/5/thread:
                // <thread> -*- C++ -*-
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/thread
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_THREAD
                #define _GLIBCXX_THREAD 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <chrono>
                #include <functional>
                #include <memory>
                #include <bits/functexcept.h>
                #include <bits/functional_hash.h>
                #include <bits/gthr.h>
                
                #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @defgroup threads Threads
                   * @ingroup concurrency
                   *
                   * Classes for thread support.
                   * @{
                   */
                
                  /// thread
                  class thread
                  {
                  public:
                    typedef __gthread_t			native_handle_type;
                    struct _Impl_base;
                    typedef shared_ptr<_Impl_base>	__shared_base_type;
                
                    /// thread::id
                    class id
                    {
                      native_handle_type	_M_thread;
                
                    public:
        1317 ->       id() noexcept : _M_thread() { }
                
                      explicit
                      id(native_handle_type __id) : _M_thread(__id) { }
                
                    private:
                      friend class thread;
                      friend class hash<thread::id>;
                
                      friend bool
         811 ->       operator==(thread::id __x, thread::id __y) noexcept
                      { return __gthread_equal(__x._M_thread, __y._M_thread); }
                
                      friend bool
                      operator<(thread::id __x, thread::id __y) noexcept
                      { return __x._M_thread < __y._M_thread; }
                
                      template<class _CharT, class _Traits>
                	friend basic_ostream<_CharT, _Traits>&
                	operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
                    };
                
                    // Simple base type that the templatized, derived class containing
                    // an arbitrary functor can be converted to and called.
         428 ->     struct _Impl_base
                    {
                      __shared_base_type	_M_this_ptr;
                
                      inline virtual ~_Impl_base();
                
                      virtual void _M_run() = 0;
                    };
                
                    template<typename _Callable>
         118 ->       struct _Impl : public _Impl_base
                      {
                	_Callable		_M_func;
                
         314 -> 	_Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
                	{ }
                
                	void
       ##### -> 	_M_run() { _M_func(); }
                      };
                
                  private:
                    id				_M_id;
                
                  public:
         248 ->     thread() noexcept = default;
                    // _GLIBCXX_RESOLVE_LIB_DEFECTS
                    // 2097.  packaged_task constructors should be constrained
                    thread(thread&) = delete;
                    thread(const thread&) = delete;
                
                    thread(thread&& __t) noexcept
                    { swap(__t); }
                
                    template<typename _Callable, typename... _Args>
                      explicit 
         253 ->       thread(_Callable&& __f, _Args&&... __args)
                      {
                #ifdef GTHR_ACTIVE_PROXY
                	// Create a reference to pthread_create, not just the gthr weak symbol
                        _M_start_thread(_M_make_routine(std::__bind_simple(
                                std::forward<_Callable>(__f),
                                std::forward<_Args>(__args)...)),
                	    reinterpret_cast<void(*)()>(&pthread_create));
                #else
                        _M_start_thread(_M_make_routine(std::__bind_simple(
                                std::forward<_Callable>(__f),
                                std::forward<_Args>(__args)...)));
                #endif
                      }
                
         452 ->     ~thread()
                    {
                      if (joinable())
                	std::terminate();
                    }
                
                    thread& operator=(const thread&) = delete;
                
         321 ->     thread& operator=(thread&& __t) noexcept
                    {
                      if (joinable())
                	std::terminate();
                      swap(__t);
                      return *this;
                    }
                
                    void
         320 ->     swap(thread& __t) noexcept
                    { std::swap(_M_id, __t._M_id); }
                
                    bool
         811 ->     joinable() const noexcept
                    { return !(_M_id == id()); }
                
                    void
                    join();
                
                    void
                    detach();
                
                    thread::id
                    get_id() const noexcept
                    { return _M_id; }
                
                    /** @pre thread is joinable
                     */
                    native_handle_type
                    native_handle()
                    { return _M_id._M_thread; }
                
                    // Returns a value that hints at the number of hardware thread contexts.
                    static unsigned int
                    hardware_concurrency() noexcept;
                
                  private:
                    void
                    _M_start_thread(__shared_base_type, void (*)());
                
                    void
                    _M_start_thread(__shared_base_type);
                
                    template<typename _Callable>
                      shared_ptr<_Impl<_Callable>>
         301 ->       _M_make_routine(_Callable&& __f)
                      {
                	// Create and allocate full data structure, not base.
                	return std::make_shared<_Impl<_Callable>>(std::forward<_Callable>(__f));
                      }
                  };
                
                  inline thread::_Impl_base::~_Impl_base() = default;
                
                  inline void
                  swap(thread& __x, thread& __y) noexcept
                  { __x.swap(__y); }
                
                  inline bool
                  operator!=(thread::id __x, thread::id __y) noexcept
                  { return !(__x == __y); }
                
                  inline bool
                  operator<=(thread::id __x, thread::id __y) noexcept
                  { return !(__y < __x); }
                
                  inline bool
                  operator>(thread::id __x, thread::id __y) noexcept
                  { return __y < __x; }
                
                  inline bool
                  operator>=(thread::id __x, thread::id __y) noexcept
                  { return !(__x < __y); }
                
                  // DR 889.
                  /// std::hash specialization for thread::id.
                  template<>
                    struct hash<thread::id>
                    : public __hash_base<size_t, thread::id>
                    {
                      size_t
                      operator()(const thread::id& __id) const noexcept
                      { return std::_Hash_impl::hash(__id._M_thread); }
                    };
                
                  template<class _CharT, class _Traits>
                    inline basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id)
                    {
                      if (__id == thread::id())
                	return __out << "thread::id of a non-executing thread";
                      else
                	return __out << __id._M_thread;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                
                  /** @namespace std::this_thread
                   *  @brief ISO C++ 2011 entities sub-namespace for thread.
                   *  30.3.2 Namespace this_thread.
                   */
                  namespace this_thread
                  {
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                    /// get_id
                    inline thread::id
                    get_id() noexcept { return thread::id(__gthread_self()); }
                
                    /// yield
                    inline void
                    yield() noexcept
                    {
                #ifdef _GLIBCXX_USE_SCHED_YIELD
                      __gthread_yield();
                #endif
                    }
                
                    void
                    __sleep_for(chrono::seconds, chrono::nanoseconds);
                
                    /// sleep_for
                    template<typename _Rep, typename _Period>
                      inline void
        3213 ->       sleep_for(const chrono::duration<_Rep, _Period>& __rtime)
                      {
                	if (__rtime <= __rtime.zero())
                	  return;
                	auto __s = chrono::duration_cast<chrono::seconds>(__rtime);
                	auto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);
                #ifdef _GLIBCXX_USE_NANOSLEEP
                	__gthread_time_t __ts =
                	  {
                	    static_cast<std::time_t>(__s.count()),
                	    static_cast<long>(__ns.count())
                	  };
                	::nanosleep(&__ts, 0);
                #else
                	__sleep_for(__s, __ns);
                #endif
                      }
                
                    /// sleep_until
                    template<typename _Clock, typename _Duration>
                      inline void
                      sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)
                      {
                	auto __now = _Clock::now();
                	if (__now < __atime)
                	  sleep_for(__atime - __now);
                      }
                
                  _GLIBCXX_END_NAMESPACE_VERSION
                  }
                
                  // @} group threads
                
                } // namespace
                
                #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1
                
                #endif // C++11
                
                #endif // _GLIBCXX_THREAD


Top 10 Lines:

     Line      Count

      280       3213
       73       1317
       83        811
      169        811
      148        452
       97        428
      156        321
      165        320
      111        314
      201        301

Execution Summary:

       14   Executable lines in this file
       14   Lines executed
   100.00   Percent of the file executed

     8907   Total number of line executions
   636.21   Average executions per line


*** File /usr/include/c++/5/bits/stl_iterator_base_types.h:
                // Types used in iterator implementation -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_types.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility types,
                 *  such as iterator_traits and struct iterator.
                 */
                
                #ifndef _STL_ITERATOR_BASE_TYPES_H
                #define _STL_ITERATOR_BASE_TYPES_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>  // For __void_t, is_convertible
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @defgroup iterators Iterators
                   *  Abstractions for uniform iterating through various underlying types.
                  */
                  //@{ 
                
                  /**
                   *  @defgroup iterator_tags Iterator Tags
                   *  These are empty types, used to distinguish different iterators.  The
                   *  distinction is not made by what they contain, but simply by what they
                   *  are.  Different underlying algorithms can then be used based on the
                   *  different operations supported by different iterator types.
                  */
                  //@{ 
                  ///  Marking input iterators.
                  struct input_iterator_tag { };
                
                  ///  Marking output iterators.
                  struct output_iterator_tag { };
                
                  /// Forward iterators support a superset of input iterator operations.
                  struct forward_iterator_tag : public input_iterator_tag { };
                
                  /// Bidirectional iterators support a superset of forward iterator
                  /// operations.
                  struct bidirectional_iterator_tag : public forward_iterator_tag { };
                
                  /// Random-access iterators support a superset of bidirectional
                  /// iterator operations.
                  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
                  //@}
                
                  /**
                   *  @brief  Common %iterator class.
                   *
                   *  This class does nothing but define nested typedefs.  %Iterator classes
                   *  can inherit from this class to save some work.  The typedefs are then
                   *  used in specializations and overloading.
                   *
                   *  In particular, there are no default implementations of requirements
                   *  such as @c operator++ and the like.  (How could there be?)
                  */
                  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
                           typename _Pointer = _Tp*, typename _Reference = _Tp&>
                    struct iterator
                    {
                      /// One of the @link iterator_tags tag types@endlink.
                      typedef _Category  iterator_category;
                      /// The type "pointed to" by the iterator.
                      typedef _Tp        value_type;
                      /// Distance between iterators is represented as this type.
                      typedef _Distance  difference_type;
                      /// This type represents a pointer-to-value_type.
                      typedef _Pointer   pointer;
                      /// This type represents a reference-to-value_type.
                      typedef _Reference reference;
                    };
                
                  /**
                   *  @brief  Traits class for iterators.
                   *
                   *  This class does nothing but define nested typedefs.  The general
                   *  version simply @a forwards the nested typedefs from the Iterator
                   *  argument.  Specialized versions for pointers and pointers-to-const
                   *  provide tighter, more correct semantics.
                  */
                #if __cplusplus >= 201103L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14
                  template<typename _Iterator, typename = __void_t<>>
                    struct __iterator_traits { };
                
                  template<typename _Iterator>
                    struct __iterator_traits<_Iterator,
                			     __void_t<typename _Iterator::iterator_category,
                				      typename _Iterator::value_type,
                				      typename _Iterator::difference_type,
                				      typename _Iterator::pointer,
                				      typename _Iterator::reference>>
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                
                  template<typename _Iterator>
                    struct iterator_traits
                    : public __iterator_traits<_Iterator> { };
                #else
                  template<typename _Iterator>
                    struct iterator_traits
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif
                
                  /// Partial specialization for pointer types.
                  template<typename _Tp>
                    struct iterator_traits<_Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef _Tp*                        pointer;
                      typedef _Tp&                        reference;
                    };
                
                  /// Partial specialization for const pointer types.
                  template<typename _Tp>
                    struct iterator_traits<const _Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef const _Tp*                  pointer;
                      typedef const _Tp&                  reference;
                    };
                
                  /**
                   *  This function is not a part of the C++ standard but is syntactic
                   *  sugar for internal library use only.
                  */
                  template<typename _Iter>
                    inline typename iterator_traits<_Iter>::iterator_category
          18 ->     __iterator_category(const _Iter&)
                    { return typename iterator_traits<_Iter>::iterator_category(); }
                
                  //@}
                
                  // If _Iterator has a base returns it otherwise _Iterator is returned
                  // untouched
                  template<typename _Iterator, bool _HasBase>
                    struct _Iter_base
                    {
                      typedef _Iterator iterator_type;
         397 ->       static iterator_type _S_base(_Iterator __it)
                      { return __it; }
                    };
                
                  template<typename _Iterator>
                    struct _Iter_base<_Iterator, true>
                    {
                      typedef typename _Iterator::iterator_type iterator_type;
         104 ->       static iterator_type _S_base(_Iterator __it)
                      { return __it.base(); }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _InIter>
                    using _RequireInputIter = typename
                      enable_if<is_convertible<typename
                		iterator_traits<_InIter>::iterator_category,
                			       input_iterator_tag>::value>::type;
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_TYPES_H */
                


Top 10 Lines:

     Line      Count

      215        397
      223        104
      204         18

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

      519   Total number of line executions
   173.00   Average executions per line


*** File /usr/include/c++/5/bits/atomic_base.h:
                // -*- C++ -*- header.
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/atomic_base.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{atomic}
                 */
                
                #ifndef _GLIBCXX_ATOMIC_BASE_H
                #define _GLIBCXX_ATOMIC_BASE_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <stdint.h>
                #include <bits/atomic_lockfree_defines.h>
                
                #ifndef _GLIBCXX_ALWAYS_INLINE
                #define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @defgroup atomics Atomics
                   *
                   * Components for performing atomic operations.
                   * @{
                   */
                
                  /// Enumeration for memory_order
                  typedef enum memory_order
                    {
                      memory_order_relaxed,
                      memory_order_consume,
                      memory_order_acquire,
                      memory_order_release,
                      memory_order_acq_rel,
                      memory_order_seq_cst
                    } memory_order;
                
                  enum __memory_order_modifier
                    {
                      __memory_order_mask          = 0x0ffff,
                      __memory_order_modifier_mask = 0xffff0000,
                      __memory_order_hle_acquire   = 0x10000,
                      __memory_order_hle_release   = 0x20000
                    };
                
                  constexpr memory_order
                  operator|(memory_order __m, __memory_order_modifier __mod)
                  {
                    return memory_order(__m | int(__mod));
                  }
                
                  constexpr memory_order
                  operator&(memory_order __m, __memory_order_modifier __mod)
        8806 ->   {
                    return memory_order(__m & int(__mod));
                  }
                
                  // Drop release ordering as per [atomics.types.operations.req]/21
                  constexpr memory_order
                  __cmpexch_failure_order2(memory_order __m) noexcept
                  {
                    return __m == memory_order_acq_rel ? memory_order_acquire
                      : __m == memory_order_release ? memory_order_relaxed : __m;
                  }
                
                  constexpr memory_order
                  __cmpexch_failure_order(memory_order __m) noexcept
                  {
                    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
                      | (__m & __memory_order_modifier_mask));
                  }
                
                  _GLIBCXX_ALWAYS_INLINE void
                  atomic_thread_fence(memory_order __m) noexcept
                  { __atomic_thread_fence(__m); }
                
                  _GLIBCXX_ALWAYS_INLINE void
                  atomic_signal_fence(memory_order __m) noexcept
                  { __atomic_signal_fence(__m); }
                
                  /// kill_dependency
                  template<typename _Tp>
                    inline _Tp
                    kill_dependency(_Tp __y) noexcept
                    {
                      _Tp __ret(__y);
                      return __ret;
                    }
                
                
                  // Base types for atomics.
                  template<typename _IntTp>
                    struct __atomic_base;
                
                
                #define ATOMIC_VAR_INIT(_VI) { _VI }
                
                  template<typename _Tp>
                    struct atomic;
                
                  template<typename _Tp>
                    struct atomic<_Tp*>;
                
                    /* The target's "set" value for test-and-set may not be exactly 1.  */
                #if __GCC_ATOMIC_TEST_AND_SET_TRUEVAL == 1
                    typedef bool __atomic_flag_data_type;
                #else
                    typedef unsigned char __atomic_flag_data_type;
                #endif
                
                  /**
                   *  @brief Base type for atomic_flag.
                   *
                   *  Base type is POD with data, allowing atomic_flag to derive from
                   *  it and meet the standard layout type requirement. In addition to
                   *  compatibility with a C interface, this allows different
                   *  implementations of atomic_flag to use the same atomic operation
                   *  functions, via a standard conversion to the __atomic_flag_base
                   *  argument.
                  */
                  _GLIBCXX_BEGIN_EXTERN_C
                
                  struct __atomic_flag_base
                  {
                    __atomic_flag_data_type _M_i;
                  };
                
                  _GLIBCXX_END_EXTERN_C
                
                #define ATOMIC_FLAG_INIT { 0 }
                
                  /// atomic_flag
                  struct atomic_flag : public __atomic_flag_base
                  {
                    atomic_flag() noexcept = default;
                    ~atomic_flag() noexcept = default;
                    atomic_flag(const atomic_flag&) = delete;
                    atomic_flag& operator=(const atomic_flag&) = delete;
                    atomic_flag& operator=(const atomic_flag&) volatile = delete;
                
                    // Conversion to ATOMIC_FLAG_INIT.
                    constexpr atomic_flag(bool __i) noexcept
                      : __atomic_flag_base{ _S_init(__i) }
                    { }
                
                    _GLIBCXX_ALWAYS_INLINE bool
                    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
                    {
                      return __atomic_test_and_set (&_M_i, __m);
                    }
                
                    _GLIBCXX_ALWAYS_INLINE bool
                    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
                    {
                      return __atomic_test_and_set (&_M_i, __m);
                    }
                
                    _GLIBCXX_ALWAYS_INLINE void
                    clear(memory_order __m = memory_order_seq_cst) noexcept
                    {
                      memory_order __b = __m & __memory_order_mask;
                      __glibcxx_assert(__b != memory_order_consume);
                      __glibcxx_assert(__b != memory_order_acquire);
                      __glibcxx_assert(__b != memory_order_acq_rel);
                
                      __atomic_clear (&_M_i, __m);
                    }
                
                    _GLIBCXX_ALWAYS_INLINE void
                    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
                    {
                      memory_order __b = __m & __memory_order_mask;
                      __glibcxx_assert(__b != memory_order_consume);
                      __glibcxx_assert(__b != memory_order_acquire);
                      __glibcxx_assert(__b != memory_order_acq_rel);
                
                      __atomic_clear (&_M_i, __m);
                    }
                
                  private:
                    static constexpr __atomic_flag_data_type
                    _S_init(bool __i)
                    { return __i ? __GCC_ATOMIC_TEST_AND_SET_TRUEVAL : 0; }
                  };
                
                
                  /// Base class for atomic integrals.
                  //
                  // For each of the integral types, define atomic_[integral type] struct
                  //
                  // atomic_bool     bool
                  // atomic_char     char
                  // atomic_schar    signed char
                  // atomic_uchar    unsigned char
                  // atomic_short    short
                  // atomic_ushort   unsigned short
                  // atomic_int      int
                  // atomic_uint     unsigned int
                  // atomic_long     long
                  // atomic_ulong    unsigned long
                  // atomic_llong    long long
                  // atomic_ullong   unsigned long long
                  // atomic_char16_t char16_t
                  // atomic_char32_t char32_t
                  // atomic_wchar_t  wchar_t
                  //
                  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or
                  // 8 bytes, since that is what GCC built-in functions for atomic
                  // memory access expect.
                  template<typename _ITp>
                    struct __atomic_base
                    {
                    private:
                      typedef _ITp 	__int_type;
                
                      static constexpr int _S_alignment =
                	sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);
                
                      alignas(_S_alignment) __int_type _M_i;
                
                    public:
                      __atomic_base() noexcept = default;
                      ~__atomic_base() noexcept = default;
                      __atomic_base(const __atomic_base&) = delete;
                      __atomic_base& operator=(const __atomic_base&) = delete;
                      __atomic_base& operator=(const __atomic_base&) volatile = delete;
                
                      // Requires __int_type convertible to _M_i.
         110 ->       constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
                
        2092 ->       operator __int_type() const noexcept
                      { return load(); }
                
                      operator __int_type() const volatile noexcept
                      { return load(); }
                
                      __int_type
           6 ->       operator=(__int_type __i) noexcept
                      {
                	store(__i);
                	return __i;
                      }
                
                      __int_type
                      operator=(__int_type __i) volatile noexcept
                      {
                	store(__i);
                	return __i;
                      }
                
                      __int_type
                      operator++(int) noexcept
                      { return fetch_add(1); }
                
                      __int_type
                      operator++(int) volatile noexcept
                      { return fetch_add(1); }
                
                      __int_type
                      operator--(int) noexcept
                      { return fetch_sub(1); }
                
                      __int_type
                      operator--(int) volatile noexcept
                      { return fetch_sub(1); }
                
                      __int_type
        2975 ->       operator++() noexcept
                      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }
                
                      __int_type
                      operator++() volatile noexcept
                      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }
                
                      __int_type
        2916 ->       operator--() noexcept
                      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }
                
                      __int_type
                      operator--() volatile noexcept
                      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }
                
                      __int_type
                      operator+=(__int_type __i) noexcept
                      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator+=(__int_type __i) volatile noexcept
                      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator-=(__int_type __i) noexcept
                      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator-=(__int_type __i) volatile noexcept
                      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator&=(__int_type __i) noexcept
                      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator&=(__int_type __i) volatile noexcept
                      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator|=(__int_type __i) noexcept
                      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator|=(__int_type __i) volatile noexcept
                      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator^=(__int_type __i) noexcept
                      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      __int_type
                      operator^=(__int_type __i) volatile noexcept
                      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }
                
                      bool
                      is_lock_free() const noexcept
                      {
                	// Use a fake, minimally aligned pointer.
                	return __atomic_is_lock_free(sizeof(_M_i),
                	    reinterpret_cast<void *>(-__alignof(_M_i)));
                      }
                
                      bool
                      is_lock_free() const volatile noexcept
                      {
                	// Use a fake, minimally aligned pointer.
                	return __atomic_is_lock_free(sizeof(_M_i),
                	    reinterpret_cast<void *>(-__alignof(_M_i)));
                      }
                
                      _GLIBCXX_ALWAYS_INLINE void
                      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
                      {
                        memory_order __b = __m & __memory_order_mask;
                	__glibcxx_assert(__b != memory_order_acquire);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                	__glibcxx_assert(__b != memory_order_consume);
                
                	__atomic_store_n(&_M_i, __i, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE void
                      store(__int_type __i,
                	    memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                        memory_order __b = __m & __memory_order_mask;
                	__glibcxx_assert(__b != memory_order_acquire);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                	__glibcxx_assert(__b != memory_order_consume);
                
                	__atomic_store_n(&_M_i, __i, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      load(memory_order __m = memory_order_seq_cst) const noexcept
                      {
                       memory_order __b = __m & __memory_order_mask;
                	__glibcxx_assert(__b != memory_order_release);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                
                	return __atomic_load_n(&_M_i, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
                      {
                        memory_order __b = __m & __memory_order_mask;
                	__glibcxx_assert(__b != memory_order_release);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                
                	return __atomic_load_n(&_M_i, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      exchange(__int_type __i,
                	       memory_order __m = memory_order_seq_cst) noexcept
                      {
                	return __atomic_exchange_n(&_M_i, __i, __m);
                      }
                
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      exchange(__int_type __i,
                	       memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                	return __atomic_exchange_n(&_M_i, __i, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_weak(__int_type& __i1, __int_type __i2,
                			    memory_order __m1, memory_order __m2) noexcept
                      {
                       memory_order __b2 = __m2 & __memory_order_mask;
                       memory_order __b1 = __m1 & __memory_order_mask;
                	__glibcxx_assert(__b2 != memory_order_release);
                	__glibcxx_assert(__b2 != memory_order_acq_rel);
                	__glibcxx_assert(__b2 <= __b1);
                
                	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_weak(__int_type& __i1, __int_type __i2,
                			    memory_order __m1,
                			    memory_order __m2) volatile noexcept
                      {
                       memory_order __b2 = __m2 & __memory_order_mask;
                       memory_order __b1 = __m1 & __memory_order_mask;
                	__glibcxx_assert(__b2 != memory_order_release);
                	__glibcxx_assert(__b2 != memory_order_acq_rel);
                	__glibcxx_assert(__b2 <= __b1);
                
                	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_weak(__int_type& __i1, __int_type __i2,
                			    memory_order __m = memory_order_seq_cst) noexcept
                      {
                	return compare_exchange_weak(__i1, __i2, __m,
                				     __cmpexch_failure_order(__m));
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_weak(__int_type& __i1, __int_type __i2,
                		   memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                	return compare_exchange_weak(__i1, __i2, __m,
                				     __cmpexch_failure_order(__m));
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_strong(__int_type& __i1, __int_type __i2,
                			      memory_order __m1, memory_order __m2) noexcept
                      {
                        memory_order __b2 = __m2 & __memory_order_mask;
                        memory_order __b1 = __m1 & __memory_order_mask;
                	__glibcxx_assert(__b2 != memory_order_release);
                	__glibcxx_assert(__b2 != memory_order_acq_rel);
                	__glibcxx_assert(__b2 <= __b1);
                
                	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_strong(__int_type& __i1, __int_type __i2,
                			      memory_order __m1,
                			      memory_order __m2) volatile noexcept
                      {
                        memory_order __b2 = __m2 & __memory_order_mask;
                        memory_order __b1 = __m1 & __memory_order_mask;
                
                	__glibcxx_assert(__b2 != memory_order_release);
                	__glibcxx_assert(__b2 != memory_order_acq_rel);
                	__glibcxx_assert(__b2 <= __b1);
                
                	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_strong(__int_type& __i1, __int_type __i2,
                			      memory_order __m = memory_order_seq_cst) noexcept
                      {
                	return compare_exchange_strong(__i1, __i2, __m,
                				       __cmpexch_failure_order(__m));
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_strong(__int_type& __i1, __int_type __i2,
                		 memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                	return compare_exchange_strong(__i1, __i2, __m,
                				       __cmpexch_failure_order(__m));
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_add(__int_type __i,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return __atomic_fetch_add(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_add(__int_type __i,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return __atomic_fetch_add(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_sub(__int_type __i,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return __atomic_fetch_sub(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_sub(__int_type __i,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return __atomic_fetch_sub(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_and(__int_type __i,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return __atomic_fetch_and(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_and(__int_type __i,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return __atomic_fetch_and(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_or(__int_type __i,
                	       memory_order __m = memory_order_seq_cst) noexcept
                      { return __atomic_fetch_or(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_or(__int_type __i,
                	       memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return __atomic_fetch_or(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_xor(__int_type __i,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return __atomic_fetch_xor(&_M_i, __i, __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __int_type
                      fetch_xor(__int_type __i,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return __atomic_fetch_xor(&_M_i, __i, __m); }
                    };
                
                
                  /// Partial specialization for pointer types.
                  template<typename _PTp>
                    struct __atomic_base<_PTp*>
                    {
                    private:
                      typedef _PTp* 	__pointer_type;
                
                      __pointer_type 	_M_p;
                
                      // Factored out to facilitate explicit specialization.
                      constexpr ptrdiff_t
                      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }
                
                      constexpr ptrdiff_t
                      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }
                
                    public:
                      __atomic_base() noexcept = default;
                      ~__atomic_base() noexcept = default;
                      __atomic_base(const __atomic_base&) = delete;
                      __atomic_base& operator=(const __atomic_base&) = delete;
                      __atomic_base& operator=(const __atomic_base&) volatile = delete;
                
                      // Requires __pointer_type convertible to _M_p.
                      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
                
                      operator __pointer_type() const noexcept
                      { return load(); }
                
                      operator __pointer_type() const volatile noexcept
                      { return load(); }
                
                      __pointer_type
                      operator=(__pointer_type __p) noexcept
                      {
                	store(__p);
                	return __p;
                      }
                
                      __pointer_type
                      operator=(__pointer_type __p) volatile noexcept
                      {
                	store(__p);
                	return __p;
                      }
                
                      __pointer_type
                      operator++(int) noexcept
                      { return fetch_add(1); }
                
                      __pointer_type
                      operator++(int) volatile noexcept
                      { return fetch_add(1); }
                
                      __pointer_type
                      operator--(int) noexcept
                      { return fetch_sub(1); }
                
                      __pointer_type
                      operator--(int) volatile noexcept
                      { return fetch_sub(1); }
                
                      __pointer_type
                      operator++() noexcept
                      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
                				  memory_order_seq_cst); }
                
                      __pointer_type
                      operator++() volatile noexcept
                      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
                				  memory_order_seq_cst); }
                
                      __pointer_type
                      operator--() noexcept
                      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
                				  memory_order_seq_cst); }
                
                      __pointer_type
                      operator--() volatile noexcept
                      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
                				  memory_order_seq_cst); }
                
                      __pointer_type
                      operator+=(ptrdiff_t __d) noexcept
                      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
                				  memory_order_seq_cst); }
                
                      __pointer_type
                      operator+=(ptrdiff_t __d) volatile noexcept
                      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
                				  memory_order_seq_cst); }
                
                      __pointer_type
                      operator-=(ptrdiff_t __d) noexcept
                      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
                				  memory_order_seq_cst); }
                
                      __pointer_type
                      operator-=(ptrdiff_t __d) volatile noexcept
                      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
                				  memory_order_seq_cst); }
                
                      bool
                      is_lock_free() const noexcept
                      {
                	// Produce a fake, minimally aligned pointer.
                	return __atomic_is_lock_free(sizeof(_M_p),
                	    reinterpret_cast<void *>(-__alignof(_M_p)));
                      }
                
                      bool
                      is_lock_free() const volatile noexcept
                      {
                	// Produce a fake, minimally aligned pointer.
                	return __atomic_is_lock_free(sizeof(_M_p),
                	    reinterpret_cast<void *>(-__alignof(_M_p)));
                      }
                
                      _GLIBCXX_ALWAYS_INLINE void
                      store(__pointer_type __p,
                	    memory_order __m = memory_order_seq_cst) noexcept
                      {
                        memory_order __b = __m & __memory_order_mask;
                
                	__glibcxx_assert(__b != memory_order_acquire);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                	__glibcxx_assert(__b != memory_order_consume);
                
                	__atomic_store_n(&_M_p, __p, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE void
                      store(__pointer_type __p,
                	    memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                        memory_order __b = __m & __memory_order_mask;
                	__glibcxx_assert(__b != memory_order_acquire);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                	__glibcxx_assert(__b != memory_order_consume);
                
                	__atomic_store_n(&_M_p, __p, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      load(memory_order __m = memory_order_seq_cst) const noexcept
                      {
                        memory_order __b = __m & __memory_order_mask;
                	__glibcxx_assert(__b != memory_order_release);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                
                	return __atomic_load_n(&_M_p, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
                      {
                        memory_order __b = __m & __memory_order_mask;
                	__glibcxx_assert(__b != memory_order_release);
                	__glibcxx_assert(__b != memory_order_acq_rel);
                
                	return __atomic_load_n(&_M_p, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      exchange(__pointer_type __p,
                	       memory_order __m = memory_order_seq_cst) noexcept
                      {
                	return __atomic_exchange_n(&_M_p, __p, __m);
                      }
                
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      exchange(__pointer_type __p,
                	       memory_order __m = memory_order_seq_cst) volatile noexcept
                      {
                	return __atomic_exchange_n(&_M_p, __p, __m);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
                			      memory_order __m1,
                			      memory_order __m2) noexcept
                      {
                        memory_order __b2 = __m2 & __memory_order_mask;
                        memory_order __b1 = __m1 & __memory_order_mask;
                	__glibcxx_assert(__b2 != memory_order_release);
                	__glibcxx_assert(__b2 != memory_order_acq_rel);
                	__glibcxx_assert(__b2 <= __b1);
                
                	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE bool
                      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
                			      memory_order __m1,
                			      memory_order __m2) volatile noexcept
                      {
                        memory_order __b2 = __m2 & __memory_order_mask;
                        memory_order __b1 = __m1 & __memory_order_mask;
                
                	__glibcxx_assert(__b2 != memory_order_release);
                	__glibcxx_assert(__b2 != memory_order_acq_rel);
                	__glibcxx_assert(__b2 <= __b1);
                
                	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
                      }
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      fetch_add(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      fetch_add(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      fetch_sub(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) noexcept
                      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }
                
                      _GLIBCXX_ALWAYS_INLINE __pointer_type
                      fetch_sub(ptrdiff_t __d,
                		memory_order __m = memory_order_seq_cst) volatile noexcept
                      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }
                    };
                
                  // @} group atomics
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

       81       8806
      295       2975
      303       2916
      258       2092
      256        110
      265          6

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

    16905   Total number of line executions
  2817.50   Average executions per line


*** File /usr/include/c++/5/type_traits:
                // C++11 <type_traits> -*- C++ -*-
                
                // Copyright (C) 2007-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/type_traits
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_TYPE_TRAITS
                #define _GLIBCXX_TYPE_TRAITS 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <bits/c++config.h>
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                # if defined (__UINT_LEAST16_TYPE__) && defined(__UINT_LEAST32_TYPE__)
                namespace std
                {
                  typedef __UINT_LEAST16_TYPE__ uint_least16_t;
                  typedef __UINT_LEAST32_TYPE__ uint_least32_t;
                }
                # else
                #  include <cstdint>
                # endif
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @defgroup metaprogramming Metaprogramming
                   * @ingroup utilities
                   *
                   * Template utilities for compile-time introspection and modification,
                   * including type classification traits, type property inspection traits
                   * and type transformation traits.
                   *
                   * @{
                   */
                
                  /// integral_constant
                  template<typename _Tp, _Tp __v>
                    struct integral_constant
                    {
                      static constexpr _Tp                  value = __v;
                      typedef _Tp                           value_type;
                      typedef integral_constant<_Tp, __v>   type;
                      constexpr operator value_type() const { return value; }
                #if __cplusplus > 201103L
                
                #define __cpp_lib_integral_constant_callable 201304
                
                      constexpr value_type operator()() const { return value; }
                #endif
                    };
                  
                  template<typename _Tp, _Tp __v>
                    constexpr _Tp integral_constant<_Tp, __v>::value;
                
                  /// The type used as a compile-time boolean with true value.
                  typedef integral_constant<bool, true>     true_type;
                
                  /// The type used as a compile-time boolean with false value.
                  typedef integral_constant<bool, false>    false_type;
                
                  template<bool __v>
                    using __bool_constant = integral_constant<bool, __v>;
                
                  // Meta programming helper types.
                
                  template<bool, typename, typename>
                    struct conditional;
                
                  template<typename...>
                    struct __or_;
                
                  template<>
                    struct __or_<>
                    : public false_type
                    { };
                
                  template<typename _B1>
                    struct __or_<_B1>
                    : public _B1
                    { };
                
                  template<typename _B1, typename _B2>
                    struct __or_<_B1, _B2>
                    : public conditional<_B1::value, _B1, _B2>::type
                    { };
                
                  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
                    struct __or_<_B1, _B2, _B3, _Bn...>
                    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
                    { };
                
                  template<typename...>
                    struct __and_;
                
                  template<>
                    struct __and_<>
                    : public true_type
                    { };
                
                  template<typename _B1>
                    struct __and_<_B1>
                    : public _B1
                    { };
                
                  template<typename _B1, typename _B2>
                    struct __and_<_B1, _B2>
                    : public conditional<_B1::value, _B2, _B1>::type
                    { };
                
                  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
                    struct __and_<_B1, _B2, _B3, _Bn...>
                    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
                    { };
                
                  template<typename _Pp>
                    struct __not_
                    : public integral_constant<bool, !_Pp::value>
                    { };
                
                  // For several sfinae-friendly trait implementations we transport both the
                  // result information (as the member type) and the failure information (no
                  // member type). This is very similar to std::enable_if, but we cannot use
                  // them, because we need to derive from them as an implementation detail.
                
                  template<typename _Tp>
                    struct __success_type
                    { typedef _Tp type; };
                
                  struct __failure_type
                  { };
                
                  // Primary type categories.
                
                  template<typename>
                    struct remove_cv;
                
                  template<typename>
                    struct __is_void_helper
                    : public false_type { };
                
                  template<>
                    struct __is_void_helper<void>
                    : public true_type { };
                
                  /// is_void
                  template<typename _Tp>
                    struct is_void
                    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
                    { };
                
                  template<typename>
                    struct __is_integral_helper
                    : public false_type { };
                
                  template<>
                    struct __is_integral_helper<bool>
                    : public true_type { };
                  
                  template<>
                    struct __is_integral_helper<char>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<signed char>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned char>
                    : public true_type { };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    struct __is_integral_helper<wchar_t>
                    : public true_type { };
                #endif
                
                  template<>
                    struct __is_integral_helper<char16_t>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<char32_t>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<short>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned short>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<int>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned int>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<long>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned long>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<long long>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned long long>
                    : public true_type { };
                
                  // Conditionalizing on __STRICT_ANSI__ here will break any port that
                  // uses one of these types for size_t.
                #if defined(__GLIBCXX_TYPE_INT_N_0)
                  template<>
                    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_0>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_0>
                    : public true_type { };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_1)
                  template<>
                    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_1>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_1>
                    : public true_type { };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_2)
                  template<>
                    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_2>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_2>
                    : public true_type { };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_3)
                  template<>
                    struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_3>
                    : public true_type { };
                
                  template<>
                    struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_3>
                    : public true_type { };
                #endif
                
                  /// is_integral
                  template<typename _Tp>
                    struct is_integral
                    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
                    { };
                
                  template<typename>
                    struct __is_floating_point_helper
                    : public false_type { };
                
                  template<>
                    struct __is_floating_point_helper<float>
                    : public true_type { };
                
                  template<>
                    struct __is_floating_point_helper<double>
                    : public true_type { };
                
                  template<>
                    struct __is_floating_point_helper<long double>
                    : public true_type { };
                
                #if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)
                  template<>
                    struct __is_floating_point_helper<__float128>
                    : public true_type { };
                #endif
                
                  /// is_floating_point
                  template<typename _Tp>
                    struct is_floating_point
                    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
                    { };
                
                  /// is_array
                  template<typename>
                    struct is_array
                    : public false_type { };
                
                  template<typename _Tp, std::size_t _Size>
                    struct is_array<_Tp[_Size]>
                    : public true_type { };
                
                  template<typename _Tp>
                    struct is_array<_Tp[]>
                    : public true_type { };
                
                  template<typename>
                    struct __is_pointer_helper
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_pointer_helper<_Tp*>
                    : public true_type { };
                
                  /// is_pointer
                  template<typename _Tp>
                    struct is_pointer
                    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
                    { };
                
                  /// is_lvalue_reference
                  template<typename>
                    struct is_lvalue_reference
                    : public false_type { };
                
                  template<typename _Tp>
                    struct is_lvalue_reference<_Tp&>
                    : public true_type { };
                
                  /// is_rvalue_reference
                  template<typename>
                    struct is_rvalue_reference
                    : public false_type { };
                
                  template<typename _Tp>
                    struct is_rvalue_reference<_Tp&&>
                    : public true_type { };
                
                  template<typename>
                    struct is_function;
                
                  template<typename>
                    struct __is_member_object_pointer_helper
                    : public false_type { };
                
                  template<typename _Tp, typename _Cp>
                    struct __is_member_object_pointer_helper<_Tp _Cp::*>
                    : public integral_constant<bool, !is_function<_Tp>::value> { };
                
                  /// is_member_object_pointer
                  template<typename _Tp>
                    struct is_member_object_pointer
                    : public __is_member_object_pointer_helper<
                				typename remove_cv<_Tp>::type>::type
                    { };
                
                  template<typename>
                    struct __is_member_function_pointer_helper
                    : public false_type { };
                
                  template<typename _Tp, typename _Cp>
                    struct __is_member_function_pointer_helper<_Tp _Cp::*>
                    : public integral_constant<bool, is_function<_Tp>::value> { };
                
                  /// is_member_function_pointer
                  template<typename _Tp>
                    struct is_member_function_pointer
                    : public __is_member_function_pointer_helper<
                				typename remove_cv<_Tp>::type>::type
                    { };
                
                  /// is_enum
                  template<typename _Tp>
                    struct is_enum
                    : public integral_constant<bool, __is_enum(_Tp)>
                    { };
                
                  /// is_union
                  template<typename _Tp>
                    struct is_union
                    : public integral_constant<bool, __is_union(_Tp)>
                    { };
                
                  /// is_class
                  template<typename _Tp>
                    struct is_class
                    : public integral_constant<bool, __is_class(_Tp)>
                    { };
                
                  /// is_function
                  template<typename>
                    struct is_function
                    : public false_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...)>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) &&>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......)>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) &&>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) const>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) const &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) const &&>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) const>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) const &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) const &&>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) volatile>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) volatile &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) volatile &&>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) volatile>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) volatile &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) volatile &&>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) const volatile>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) const volatile &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes...) const volatile &&>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) const volatile>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) const volatile &>
                    : public true_type { };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct is_function<_Res(_ArgTypes......) const volatile &&>
                    : public true_type { };
                
                #define __cpp_lib_is_null_pointer 201309
                
                  template<typename>
                    struct __is_null_pointer_helper
                    : public false_type { };
                
                  template<>
                    struct __is_null_pointer_helper<std::nullptr_t>
                    : public true_type { };
                
                  /// is_null_pointer (LWG 2247).
                  template<typename _Tp>
                    struct is_null_pointer
                    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
                    { };
                
                  /// __is_nullptr_t (extension).
                  template<typename _Tp>
                    struct __is_nullptr_t
                    : public is_null_pointer<_Tp>
                    { };
                
                  // Composite type categories.
                
                  /// is_reference
                  template<typename _Tp>
                    struct is_reference
                    : public __or_<is_lvalue_reference<_Tp>,
                                   is_rvalue_reference<_Tp>>::type
                    { };
                
                  /// is_arithmetic
                  template<typename _Tp>
                    struct is_arithmetic
                    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
                    { };
                
                  /// is_fundamental
                  template<typename _Tp>
                    struct is_fundamental
                    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
                		   is_null_pointer<_Tp>>::type
                    { };
                
                  /// is_object
                  template<typename _Tp>
                    struct is_object
                    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                                          is_void<_Tp>>>::type
                    { };
                
                  template<typename>
                    struct is_member_pointer;
                
                  /// is_scalar
                  template<typename _Tp>
                    struct is_scalar
                    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
                    { };
                
                  /// is_compound
                  template<typename _Tp>
                    struct is_compound
                    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };
                
                  template<typename _Tp>
                    struct __is_member_pointer_helper
                    : public false_type { };
                
                  template<typename _Tp, typename _Cp>
                    struct __is_member_pointer_helper<_Tp _Cp::*>
                    : public true_type { };
                
                  /// is_member_pointer
                  template<typename _Tp>
                    struct is_member_pointer
                    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
                    { };
                
                  // Utility to detect referenceable types ([defns.referenceable]).
                
                  template<typename _Tp>
                    struct __is_referenceable
                    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
                    { };
                
                  template<typename _Res, typename... _Args>
                    struct __is_referenceable<_Res(_Args...)>
                    : public true_type
                    { };
                
                  template<typename _Res, typename... _Args>
                    struct __is_referenceable<_Res(_Args......)>
                    : public true_type
                    { };
                
                  // Type properties.
                
                  /// is_const
                  template<typename>
                    struct is_const
                    : public false_type { };
                
                  template<typename _Tp>
                    struct is_const<_Tp const>
                    : public true_type { };
                  
                  /// is_volatile
                  template<typename>
                    struct is_volatile
                    : public false_type { };
                
                  template<typename _Tp>
                    struct is_volatile<_Tp volatile>
                    : public true_type { };
                
                  /// is_trivial
                  template<typename _Tp>
                    struct is_trivial
                    : public integral_constant<bool, __is_trivial(_Tp)>
                    { };
                
                  // is_trivially_copyable
                  template<typename _Tp>
                    struct is_trivially_copyable
                    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
                    { };
                
                  /// is_standard_layout
                  template<typename _Tp>
                    struct is_standard_layout
                    : public integral_constant<bool, __is_standard_layout(_Tp)>
                    { };
                
                  /// is_pod
                  // Could use is_standard_layout && is_trivial instead of the builtin.
                  template<typename _Tp>
                    struct is_pod
                    : public integral_constant<bool, __is_pod(_Tp)>
                    { };
                
                  /// is_literal_type
                  template<typename _Tp>
                    struct is_literal_type
                    : public integral_constant<bool, __is_literal_type(_Tp)>
                    { };
                
                  /// is_empty
                  template<typename _Tp>
                    struct is_empty
                    : public integral_constant<bool, __is_empty(_Tp)>
                    { };
                
                  /// is_polymorphic
                  template<typename _Tp>
                    struct is_polymorphic
                    : public integral_constant<bool, __is_polymorphic(_Tp)>
                    { };
                
                #if __cplusplus >= 201402L
                #define __cpp_lib_is_final 201402L
                  /// is_final
                  template<typename _Tp>
                    struct is_final
                    : public integral_constant<bool, __is_final(_Tp)>
                    { };
                #endif
                
                  /// is_abstract
                  template<typename _Tp>
                    struct is_abstract
                    : public integral_constant<bool, __is_abstract(_Tp)>
                    { };
                
                  template<typename _Tp,
                	   bool = is_arithmetic<_Tp>::value>
                    struct __is_signed_helper
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_signed_helper<_Tp, true>
                    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
                    { };
                
                  /// is_signed
                  template<typename _Tp>
                    struct is_signed
                    : public __is_signed_helper<_Tp>::type
                    { };
                
                  /// is_unsigned
                  template<typename _Tp>
                    struct is_unsigned
                    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
                    { };
                
                
                  // Destructible and constructible type properties.
                
                  template<typename>
                    struct add_rvalue_reference;
                
                  /**
                   *  @brief  Utility to simplify expressions used in unevaluated operands
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    typename add_rvalue_reference<_Tp>::type declval() noexcept;
                
                  template<typename, unsigned = 0>
                    struct extent;
                
                  template<typename>
                    struct remove_all_extents;
                
                  template<typename _Tp>
                    struct __is_array_known_bounds
                    : public integral_constant<bool, (extent<_Tp>::value > 0)>
                    { };
                
                  template<typename _Tp>
                    struct __is_array_unknown_bounds
                    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
                    { };
                    
                  // In N3290 is_destructible does not say anything about function
                  // types and abstract types, see LWG 2049. This implementation
                  // describes function types as non-destructible and all complete
                  // object types as destructible, iff the explicit destructor
                  // call expression is wellformed.
                  struct __do_is_destructible_impl
                  {
                    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
                      static true_type __test(int);
                
                    template<typename>
                      static false_type __test(...);
                  };
                
                  template<typename _Tp>
                    struct __is_destructible_impl
                    : public __do_is_destructible_impl
                    {
                      typedef decltype(__test<_Tp>(0)) type;
                    };
                
                  template<typename _Tp,
                           bool = __or_<is_void<_Tp>,
                                        __is_array_unknown_bounds<_Tp>,
                                        is_function<_Tp>>::value,
                           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
                    struct __is_destructible_safe;
                
                  template<typename _Tp>
                    struct __is_destructible_safe<_Tp, false, false>
                    : public __is_destructible_impl<typename
                               remove_all_extents<_Tp>::type>::type
                    { };
                
                  template<typename _Tp>
                    struct __is_destructible_safe<_Tp, true, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_destructible_safe<_Tp, false, true>
                    : public true_type { };
                
                  /// is_destructible
                  template<typename _Tp>
                    struct is_destructible
                    : public __is_destructible_safe<_Tp>::type
                    { };
                
                  // is_nothrow_destructible requires that is_destructible is
                  // satisfied as well.  We realize that by mimicing the
                  // implementation of is_destructible but refer to noexcept(expr)
                  // instead of decltype(expr).
                  struct __do_is_nt_destructible_impl
                  {
                    template<typename _Tp>
                      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
                        __test(int);
                
                    template<typename>
                      static false_type __test(...);
                  };
                
                  template<typename _Tp>
                    struct __is_nt_destructible_impl
                    : public __do_is_nt_destructible_impl
                    {
                      typedef decltype(__test<_Tp>(0)) type;
                    };
                
                  template<typename _Tp,
                           bool = __or_<is_void<_Tp>,
                                        __is_array_unknown_bounds<_Tp>,
                                        is_function<_Tp>>::value,
                           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
                    struct __is_nt_destructible_safe;
                
                  template<typename _Tp>
                    struct __is_nt_destructible_safe<_Tp, false, false>
                    : public __is_nt_destructible_impl<typename
                               remove_all_extents<_Tp>::type>::type
                    { };
                
                  template<typename _Tp>
                    struct __is_nt_destructible_safe<_Tp, true, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_nt_destructible_safe<_Tp, false, true>
                    : public true_type { };
                
                  /// is_nothrow_destructible
                  template<typename _Tp>
                    struct is_nothrow_destructible
                    : public __is_nt_destructible_safe<_Tp>::type
                    { };
                
                  struct __do_is_default_constructible_impl
                  {
                    template<typename _Tp, typename = decltype(_Tp())>
                      static true_type __test(int);
                
                    template<typename>
                      static false_type __test(...);
                  };
                
                  template<typename _Tp>
                    struct __is_default_constructible_impl
                    : public __do_is_default_constructible_impl
                    {
                      typedef decltype(__test<_Tp>(0)) type;
                    };
                
                  template<typename _Tp>
                    struct __is_default_constructible_atom
                    : public __and_<__not_<is_void<_Tp>>,
                                    __is_default_constructible_impl<_Tp>>::type
                    { };
                
                  template<typename _Tp, bool = is_array<_Tp>::value>
                    struct __is_default_constructible_safe;
                
                  // The following technique is a workaround for a current core language
                  // restriction, which does not allow for array types to occur in 
                  // functional casts of the form T().  Complete arrays can be default-
                  // constructed, if the element type is default-constructible, but 
                  // arrays with unknown bounds are not.
                  template<typename _Tp>
                    struct __is_default_constructible_safe<_Tp, true>
                    : public __and_<__is_array_known_bounds<_Tp>,
                		    __is_default_constructible_atom<typename
                                      remove_all_extents<_Tp>::type>>::type
                    { };
                
                  template<typename _Tp>
                    struct __is_default_constructible_safe<_Tp, false>
                    : public __is_default_constructible_atom<_Tp>::type
                    { };
                
                  /// is_default_constructible
                  template<typename _Tp>
                    struct is_default_constructible
                    : public __is_default_constructible_safe<_Tp>::type
                    { };
                
                
                  // Implementation of is_constructible.
                
                  // The hardest part of this trait is the binary direct-initialization
                  // case, because we hit into a functional cast of the form T(arg).
                  // This implementation uses different strategies depending on the
                  // target type to reduce the test overhead as much as possible:
                  //
                  // a) For a reference target type, we use a static_cast expression 
                  //    modulo its extra cases.
                  //
                  // b) For a non-reference target type we use a ::new expression.
                  struct __do_is_static_castable_impl
                  {
                    template<typename _From, typename _To, typename
                             = decltype(static_cast<_To>(declval<_From>()))>
                      static true_type __test(int);
                
                    template<typename, typename>
                      static false_type __test(...);
                  };
                
                  template<typename _From, typename _To>
                    struct __is_static_castable_impl
                    : public __do_is_static_castable_impl
                    {
                      typedef decltype(__test<_From, _To>(0)) type;
                    };
                
                  template<typename _From, typename _To>
                    struct __is_static_castable_safe
                    : public __is_static_castable_impl<_From, _To>::type
                    { };
                
                  // __is_static_castable
                  template<typename _From, typename _To>
                    struct __is_static_castable
                    : public integral_constant<bool, (__is_static_castable_safe<
                				      _From, _To>::value)>
                    { };
                
                  // Implementation for non-reference types. To meet the proper
                  // variable definition semantics, we also need to test for
                  // is_destructible in this case.
                  // This form should be simplified by a single expression:
                  // ::delete ::new _Tp(declval<_Arg>()), see c++/51222.
                  struct __do_is_direct_constructible_impl
                  {
                    template<typename _Tp, typename _Arg, typename
                	     = decltype(::new _Tp(declval<_Arg>()))>
                      static true_type __test(int);
                
                    template<typename, typename>
                      static false_type __test(...);
                  };
                
                  template<typename _Tp, typename _Arg>
                    struct __is_direct_constructible_impl
                    : public __do_is_direct_constructible_impl
                    {
                      typedef decltype(__test<_Tp, _Arg>(0)) type;
                    };
                
                  template<typename _Tp, typename _Arg>
                    struct __is_direct_constructible_new_safe
                    : public __and_<is_destructible<_Tp>,
                                    __is_direct_constructible_impl<_Tp, _Arg>>::type
                    { };
                
                  template<typename, typename>
                    struct is_same;
                
                  template<typename, typename>
                    struct is_base_of;
                
                  template<typename>
                    struct remove_reference;
                
                  template<typename _From, typename _To, bool
                           = __not_<__or_<is_void<_From>, 
                                          is_function<_From>>>::value>
                    struct __is_base_to_derived_ref;
                
                  // Detect whether we have a downcast situation during
                  // reference binding.
                  template<typename _From, typename _To>
                    struct __is_base_to_derived_ref<_From, _To, true>
                    {
                      typedef typename remove_cv<typename remove_reference<_From
                        >::type>::type __src_t;
                      typedef typename remove_cv<typename remove_reference<_To
                        >::type>::type __dst_t;
                      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
                		     is_base_of<__src_t, __dst_t>> type;
                      static constexpr bool value = type::value;
                    };
                
                  template<typename _From, typename _To>
                    struct __is_base_to_derived_ref<_From, _To, false>
                    : public false_type
                    { };
                
                  template<typename _From, typename _To, bool
                           = __and_<is_lvalue_reference<_From>,
                                    is_rvalue_reference<_To>>::value>
                    struct __is_lvalue_to_rvalue_ref;
                
                  // Detect whether we have an lvalue of non-function type
                  // bound to a reference-compatible rvalue-reference.
                  template<typename _From, typename _To>
                    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
                    {
                      typedef typename remove_cv<typename remove_reference<
                        _From>::type>::type __src_t;
                      typedef typename remove_cv<typename remove_reference<
                        _To>::type>::type __dst_t;
                      typedef __and_<__not_<is_function<__src_t>>, 
                        __or_<is_same<__src_t, __dst_t>,
                		    is_base_of<__dst_t, __src_t>>> type;
                      static constexpr bool value = type::value;
                    };
                
                  template<typename _From, typename _To>
                    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
                    : public false_type
                    { };
                
                  // Here we handle direct-initialization to a reference type as 
                  // equivalent to a static_cast modulo overshooting conversions.
                  // These are restricted to the following conversions:
                  //    a) A base class value to a derived class reference
                  //    b) An lvalue to an rvalue-reference of reference-compatible 
                  //       types that are not functions
                  template<typename _Tp, typename _Arg>
                    struct __is_direct_constructible_ref_cast
                    : public __and_<__is_static_castable<_Arg, _Tp>,
                                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                                   >>>::type
                    { };
                
                  template<typename _Tp, typename _Arg>
                    struct __is_direct_constructible_new
                    : public conditional<is_reference<_Tp>::value,
                			 __is_direct_constructible_ref_cast<_Tp, _Arg>,
                			 __is_direct_constructible_new_safe<_Tp, _Arg>
                			 >::type
                    { };
                
                  template<typename _Tp, typename _Arg>
                    struct __is_direct_constructible
                    : public __is_direct_constructible_new<_Tp, _Arg>::type
                    { };
                
                  // Since default-construction and binary direct-initialization have
                  // been handled separately, the implementation of the remaining
                  // n-ary construction cases is rather straightforward. We can use
                  // here a functional cast, because array types are excluded anyway
                  // and this form is never interpreted as a C cast.
                  struct __do_is_nary_constructible_impl
                  {
                    template<typename _Tp, typename... _Args, typename
                             = decltype(_Tp(declval<_Args>()...))>
                      static true_type __test(int);
                
                    template<typename, typename...>
                      static false_type __test(...);
                  };
                
                  template<typename _Tp, typename... _Args>
                    struct __is_nary_constructible_impl
                    : public __do_is_nary_constructible_impl
                    {
                      typedef decltype(__test<_Tp, _Args...>(0)) type;
                    };
                
                  template<typename _Tp, typename... _Args>
                    struct __is_nary_constructible
                    : public __is_nary_constructible_impl<_Tp, _Args...>::type
                    {
                      static_assert(sizeof...(_Args) > 1,
                                    "Only useful for > 1 arguments");
                    };
                
                  template<typename _Tp, typename... _Args>
                    struct __is_constructible_impl
                    : public __is_nary_constructible<_Tp, _Args...>
                    { };
                
                  template<typename _Tp, typename _Arg>
                    struct __is_constructible_impl<_Tp, _Arg>
                    : public __is_direct_constructible<_Tp, _Arg>
                    { };
                
                  template<typename _Tp>
                    struct __is_constructible_impl<_Tp>
                    : public is_default_constructible<_Tp>
                    { };
                
                  /// is_constructible
                  template<typename _Tp, typename... _Args>
                    struct is_constructible
                    : public __is_constructible_impl<_Tp, _Args...>::type
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_copy_constructible_impl;
                
                  template<typename _Tp>
                    struct __is_copy_constructible_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_copy_constructible_impl<_Tp, true>
                    : public is_constructible<_Tp, const _Tp&>
                    { };
                
                  /// is_copy_constructible
                  template<typename _Tp>
                    struct is_copy_constructible
                    : public __is_copy_constructible_impl<_Tp>
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_move_constructible_impl;
                
                  template<typename _Tp>
                    struct __is_move_constructible_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_move_constructible_impl<_Tp, true>
                    : public is_constructible<_Tp, _Tp&&>
                    { };
                
                  /// is_move_constructible
                  template<typename _Tp>
                    struct is_move_constructible
                    : public __is_move_constructible_impl<_Tp>
                    { };
                
                  template<typename _Tp>
                    struct __is_nt_default_constructible_atom
                    : public integral_constant<bool, noexcept(_Tp())>
                    { };
                
                  template<typename _Tp, bool = is_array<_Tp>::value>
                    struct __is_nt_default_constructible_impl;
                
                  template<typename _Tp>
                    struct __is_nt_default_constructible_impl<_Tp, true>
                    : public __and_<__is_array_known_bounds<_Tp>,
                		    __is_nt_default_constructible_atom<typename
                                      remove_all_extents<_Tp>::type>>::type
                    { };
                
                  template<typename _Tp>
                    struct __is_nt_default_constructible_impl<_Tp, false>
                    : public __is_nt_default_constructible_atom<_Tp>
                    { };
                
                  /// is_nothrow_default_constructible
                  template<typename _Tp>
                    struct is_nothrow_default_constructible
                    : public __and_<is_default_constructible<_Tp>,
                                    __is_nt_default_constructible_impl<_Tp>>::type
                    { };
                
                  template<typename _Tp, typename... _Args>
                    struct __is_nt_constructible_impl
                    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
                    { };
                
                  template<typename _Tp, typename _Arg>
                    struct __is_nt_constructible_impl<_Tp, _Arg>
                    : public integral_constant<bool,
                                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
                    { };
                
                  template<typename _Tp>
                    struct __is_nt_constructible_impl<_Tp>
                    : public is_nothrow_default_constructible<_Tp>
                    { };
                
                  /// is_nothrow_constructible
                  template<typename _Tp, typename... _Args>
                    struct is_nothrow_constructible
                    : public __and_<is_constructible<_Tp, _Args...>,
                		    __is_nt_constructible_impl<_Tp, _Args...>>::type
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_nothrow_copy_constructible_impl;
                
                  template<typename _Tp>
                    struct __is_nothrow_copy_constructible_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_nothrow_copy_constructible_impl<_Tp, true>
                    : public is_nothrow_constructible<_Tp, const _Tp&>
                    { };
                
                  /// is_nothrow_copy_constructible
                  template<typename _Tp>
                    struct is_nothrow_copy_constructible
                    : public __is_nothrow_copy_constructible_impl<_Tp>
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_nothrow_move_constructible_impl;
                
                  template<typename _Tp>
                    struct __is_nothrow_move_constructible_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_nothrow_move_constructible_impl<_Tp, true>
                    : public is_nothrow_constructible<_Tp, _Tp&&>
                    { };
                
                  /// is_nothrow_move_constructible
                  template<typename _Tp>
                    struct is_nothrow_move_constructible
                    : public __is_nothrow_move_constructible_impl<_Tp>
                    { };
                
                  template<typename _Tp, typename _Up>
                    class __is_assignable_helper
                    {
                      template<typename _Tp1, typename _Up1,
                	       typename = decltype(declval<_Tp1>() = declval<_Up1>())>
                	static true_type
                	__test(int);
                
                      template<typename, typename>
                	static false_type
                	__test(...);
                
                    public:
                      typedef decltype(__test<_Tp, _Up>(0)) type;
                    };
                
                  /// is_assignable
                  template<typename _Tp, typename _Up>
                    struct is_assignable
                      : public __is_assignable_helper<_Tp, _Up>::type
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_copy_assignable_impl;
                
                  template<typename _Tp>
                    struct __is_copy_assignable_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_copy_assignable_impl<_Tp, true>
                    : public is_assignable<_Tp&, const _Tp&>
                    { };
                
                  /// is_copy_assignable
                  template<typename _Tp>
                    struct is_copy_assignable
                    : public __is_copy_assignable_impl<_Tp>
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_move_assignable_impl;
                
                  template<typename _Tp>
                    struct __is_move_assignable_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_move_assignable_impl<_Tp, true>
                    : public is_assignable<_Tp&, _Tp&&>
                    { };
                
                  /// is_move_assignable
                  template<typename _Tp>
                    struct is_move_assignable
                    : public __is_move_assignable_impl<_Tp>
                    { };
                
                  template<typename _Tp, typename _Up>
                    struct __is_nt_assignable_impl
                    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
                    { };
                
                  /// is_nothrow_assignable
                  template<typename _Tp, typename _Up>
                    struct is_nothrow_assignable
                    : public __and_<is_assignable<_Tp, _Up>,
                		    __is_nt_assignable_impl<_Tp, _Up>>::type
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_nt_copy_assignable_impl;
                
                  template<typename _Tp>
                    struct __is_nt_copy_assignable_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_nt_copy_assignable_impl<_Tp, true>
                    : public is_nothrow_assignable<_Tp&, const _Tp&>
                    { };
                
                  /// is_nothrow_copy_assignable
                  template<typename _Tp>
                    struct is_nothrow_copy_assignable
                    : public __is_nt_copy_assignable_impl<_Tp>
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __is_nt_move_assignable_impl;
                
                  template<typename _Tp>
                    struct __is_nt_move_assignable_impl<_Tp, false>
                    : public false_type { };
                
                  template<typename _Tp>
                    struct __is_nt_move_assignable_impl<_Tp, true>
                    : public is_nothrow_assignable<_Tp&, _Tp&&>
                    { };
                
                  /// is_nothrow_move_assignable
                  template<typename _Tp>
                    struct is_nothrow_move_assignable
                    : public __is_nt_move_assignable_impl<_Tp>
                    { };
                
                  /// is_trivially_constructible
                  template<typename _Tp, typename... _Args>
                    struct is_trivially_constructible
                    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
                			__is_trivially_constructible(_Tp, _Args...)>>::type
                    { };
                  
                  /// is_trivially_default_constructible
                  template<typename _Tp>
                    struct is_trivially_default_constructible
                    : public is_trivially_constructible<_Tp>::type
                    { };
                
                  /// is_trivially_copy_constructible
                  template<typename _Tp>
                    struct is_trivially_copy_constructible
                    : public __and_<is_copy_constructible<_Tp>, 
                		    integral_constant<bool,
                			__is_trivially_constructible(_Tp, const _Tp&)>>::type
                    { };
                  
                  /// is_trivially_move_constructible
                  template<typename _Tp>
                    struct is_trivially_move_constructible
                    : public __and_<is_move_constructible<_Tp>, 
                		    integral_constant<bool,
                			__is_trivially_constructible(_Tp, _Tp&&)>>::type
                    { };
                
                  /// is_trivially_assignable
                  template<typename _Tp, typename _Up>
                    struct is_trivially_assignable
                    : public __and_<is_assignable<_Tp, _Up>, 
                		    integral_constant<bool,
                			__is_trivially_assignable(_Tp, _Up)>>::type
                    { };
                
                  /// is_trivially_copy_assignable
                  template<typename _Tp>
                    struct is_trivially_copy_assignable
                    : public __and_<is_copy_assignable<_Tp>, 
                		    integral_constant<bool,
                			__is_trivially_assignable(_Tp&, const _Tp&)>>::type
                    { };
                
                  /// is_trivially_move_assignable
                  template<typename _Tp>
                    struct is_trivially_move_assignable
                    : public __and_<is_move_assignable<_Tp>, 
                		    integral_constant<bool,
                			__is_trivially_assignable(_Tp&, _Tp&&)>>::type
                    { };
                
                  /// is_trivially_destructible
                  template<typename _Tp>
                    struct is_trivially_destructible
                    : public __and_<is_destructible<_Tp>, integral_constant<bool,
                			      __has_trivial_destructor(_Tp)>>::type
                    { };
                
                  /// has_trivial_default_constructor (temporary legacy)
                  template<typename _Tp>
                    struct has_trivial_default_constructor
                    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
                    { } _GLIBCXX_DEPRECATED;
                
                  /// has_trivial_copy_constructor (temporary legacy)
                  template<typename _Tp>
                    struct has_trivial_copy_constructor
                    : public integral_constant<bool, __has_trivial_copy(_Tp)>
                    { } _GLIBCXX_DEPRECATED;
                
                  /// has_trivial_copy_assign (temporary legacy)
                  template<typename _Tp>
                    struct has_trivial_copy_assign
                    : public integral_constant<bool, __has_trivial_assign(_Tp)>
                    { } _GLIBCXX_DEPRECATED;
                
                  /// has_virtual_destructor
                  template<typename _Tp>
                    struct has_virtual_destructor
                    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
                    { };
                
                  
                  // type property queries.
                
                  /// alignment_of
                  template<typename _Tp>
                    struct alignment_of
                    : public integral_constant<std::size_t, __alignof__(_Tp)> { };
                  
                  /// rank
                  template<typename>
                    struct rank
                    : public integral_constant<std::size_t, 0> { };
                   
                  template<typename _Tp, std::size_t _Size>
                    struct rank<_Tp[_Size]>
                    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };
                
                  template<typename _Tp>
                    struct rank<_Tp[]>
                    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };
                
                  /// extent
                  template<typename, unsigned _Uint>
                    struct extent
                    : public integral_constant<std::size_t, 0> { };
                  
                  template<typename _Tp, unsigned _Uint, std::size_t _Size>
                    struct extent<_Tp[_Size], _Uint>
                    : public integral_constant<std::size_t,
                			       _Uint == 0 ? _Size : extent<_Tp,
                							   _Uint - 1>::value>
                    { };
                
                  template<typename _Tp, unsigned _Uint>
                    struct extent<_Tp[], _Uint>
                    : public integral_constant<std::size_t,
                			       _Uint == 0 ? 0 : extent<_Tp,
                						       _Uint - 1>::value>
                    { };
                
                
                  // Type relations.
                
                  /// is_same
                  template<typename, typename>
                    struct is_same
                    : public false_type { };
                
                  template<typename _Tp>
                    struct is_same<_Tp, _Tp>
                    : public true_type { };
                
                  /// is_base_of
                  template<typename _Base, typename _Derived>
                    struct is_base_of
                    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
                    { };
                
                  template<typename _From, typename _To,
                           bool = __or_<is_void<_From>, is_function<_To>,
                                        is_array<_To>>::value>
                    struct __is_convertible_helper
                    { typedef typename is_void<_To>::type type; };
                
                  template<typename _From, typename _To>
                    class __is_convertible_helper<_From, _To, false>
                    {
                       template<typename _To1>
                	static void __test_aux(_To1);
                
                      template<typename _From1, typename _To1,
                	       typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
                	static true_type
                	__test(int);
                
                      template<typename, typename>
                	static false_type
                	__test(...);
                
                    public:
                      typedef decltype(__test<_From, _To>(0)) type;
                    };
                
                
                  /// is_convertible
                  template<typename _From, typename _To>
                    struct is_convertible
                    : public __is_convertible_helper<_From, _To>::type
                    { };
                
                
                  // Const-volatile modifications.
                
                  /// remove_const
                  template<typename _Tp>
                    struct remove_const
                    { typedef _Tp     type; };
                
                  template<typename _Tp>
                    struct remove_const<_Tp const>
                    { typedef _Tp     type; };
                  
                  /// remove_volatile
                  template<typename _Tp>
                    struct remove_volatile
                    { typedef _Tp     type; };
                
                  template<typename _Tp>
                    struct remove_volatile<_Tp volatile>
                    { typedef _Tp     type; };
                  
                  /// remove_cv
                  template<typename _Tp>
                    struct remove_cv
                    {
                      typedef typename
                      remove_const<typename remove_volatile<_Tp>::type>::type     type;
                    };
                  
                  /// add_const
                  template<typename _Tp>
                    struct add_const
                    { typedef _Tp const     type; };
                   
                  /// add_volatile
                  template<typename _Tp>
                    struct add_volatile
                    { typedef _Tp volatile     type; };
                  
                  /// add_cv
                  template<typename _Tp>
                    struct add_cv
                    {
                      typedef typename
                      add_const<typename add_volatile<_Tp>::type>::type     type;
                    };
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_transformation_trait_aliases 201304
                
                  /// Alias template for remove_const
                  template<typename _Tp>
                    using remove_const_t = typename remove_const<_Tp>::type;
                
                  /// Alias template for remove_volatile
                  template<typename _Tp>
                    using remove_volatile_t = typename remove_volatile<_Tp>::type;
                
                  /// Alias template for remove_cv
                  template<typename _Tp>
                    using remove_cv_t = typename remove_cv<_Tp>::type;
                
                  /// Alias template for add_const
                  template<typename _Tp>
                    using add_const_t = typename add_const<_Tp>::type;
                
                  /// Alias template for add_volatile
                  template<typename _Tp>
                    using add_volatile_t = typename add_volatile<_Tp>::type;
                
                  /// Alias template for add_cv
                  template<typename _Tp>
                    using add_cv_t = typename add_cv<_Tp>::type;
                #endif
                
                  // Reference transformations.
                
                  /// remove_reference
                  template<typename _Tp>
                    struct remove_reference
                    { typedef _Tp   type; };
                
                  template<typename _Tp>
                    struct remove_reference<_Tp&>
                    { typedef _Tp   type; };
                
                  template<typename _Tp>
                    struct remove_reference<_Tp&&>
                    { typedef _Tp   type; };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __add_lvalue_reference_helper
                    { typedef _Tp   type; };
                
                  template<typename _Tp>
                    struct __add_lvalue_reference_helper<_Tp, true>
                    { typedef _Tp&   type; };
                
                  /// add_lvalue_reference
                  template<typename _Tp>
                    struct add_lvalue_reference
                    : public __add_lvalue_reference_helper<_Tp>
                    { };
                
                  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
                    struct __add_rvalue_reference_helper
                    { typedef _Tp   type; };
                
                  template<typename _Tp>
                    struct __add_rvalue_reference_helper<_Tp, true>
                    { typedef _Tp&&   type; };
                
                  /// add_rvalue_reference
                  template<typename _Tp>
                    struct add_rvalue_reference
                    : public __add_rvalue_reference_helper<_Tp>
                    { };
                
                #if __cplusplus > 201103L
                  /// Alias template for remove_reference
                  template<typename _Tp>
                    using remove_reference_t = typename remove_reference<_Tp>::type;
                
                  /// Alias template for add_lvalue_reference
                  template<typename _Tp>
                    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
                
                  /// Alias template for add_rvalue_reference
                  template<typename _Tp>
                    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
                #endif
                
                  // Sign modifications.
                
                  // Utility for constructing identically cv-qualified types.
                  template<typename _Unqualified, bool _IsConst, bool _IsVol>
                    struct __cv_selector;
                
                  template<typename _Unqualified>
                    struct __cv_selector<_Unqualified, false, false>
                    { typedef _Unqualified __type; };
                
                  template<typename _Unqualified>
                    struct __cv_selector<_Unqualified, false, true>
                    { typedef volatile _Unqualified __type; };
                
                  template<typename _Unqualified>
                    struct __cv_selector<_Unqualified, true, false>
                    { typedef const _Unqualified __type; };
                
                  template<typename _Unqualified>
                    struct __cv_selector<_Unqualified, true, true>
                    { typedef const volatile _Unqualified __type; };
                
                  template<typename _Qualified, typename _Unqualified,
                	   bool _IsConst = is_const<_Qualified>::value,
                	   bool _IsVol = is_volatile<_Qualified>::value>
                    class __match_cv_qualifiers
                    {
                      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
                
                    public:
                      typedef typename __match::__type __type; 
                    };
                
                  // Utility for finding the unsigned versions of signed integral types.
                  template<typename _Tp>
                    struct __make_unsigned
                    { typedef _Tp __type; };
                
                  template<>
                    struct __make_unsigned<char>
                    { typedef unsigned char __type; };
                
                  template<>
                    struct __make_unsigned<signed char>
                    { typedef unsigned char __type; };
                
                  template<>
                    struct __make_unsigned<short>
                    { typedef unsigned short __type; };
                
                  template<>
                    struct __make_unsigned<int>
                    { typedef unsigned int __type; };
                
                  template<>
                    struct __make_unsigned<long>
                    { typedef unsigned long __type; };
                
                  template<>
                    struct __make_unsigned<long long>
                    { typedef unsigned long long __type; };
                
                #if defined(_GLIBCXX_USE_WCHAR_T) && !defined(__WCHAR_UNSIGNED__)
                  template<>
                    struct __make_unsigned<wchar_t> : __make_unsigned<__WCHAR_TYPE__>
                    { };
                #endif
                
                #if defined(__GLIBCXX_TYPE_INT_N_0)
                  template<>
                    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_0>
                    { typedef unsigned __GLIBCXX_TYPE_INT_N_0 __type; };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_1)
                  template<>
                    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_1>
                    { typedef unsigned __GLIBCXX_TYPE_INT_N_1 __type; };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_2)
                  template<>
                    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_2>
                    { typedef unsigned __GLIBCXX_TYPE_INT_N_2 __type; };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_3)
                  template<>
                    struct __make_unsigned<__GLIBCXX_TYPE_INT_N_3>
                    { typedef unsigned __GLIBCXX_TYPE_INT_N_3 __type; };
                #endif
                
                  // Select between integral and enum: not possible to be both.
                  template<typename _Tp, 
                	   bool _IsInt = is_integral<_Tp>::value,
                	   bool _IsEnum = is_enum<_Tp>::value>
                    class __make_unsigned_selector;
                
                  template<typename _Tp>
                    class __make_unsigned_selector<_Tp, true, false>
                    {
                      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
                      typedef typename __unsignedt::__type __unsigned_type;
                      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;
                
                    public:
                      typedef typename __cv_unsigned::__type __type;
                    };
                
                  template<typename _Tp>
                    class __make_unsigned_selector<_Tp, false, true>
                    {
                      // With -fshort-enums, an enum may be as small as a char.
                      typedef unsigned char __smallest;
                      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
                      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
                      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
                      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
                      typedef typename __cond2::type __cond2_type;
                      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
                      typedef typename __cond1::type __cond1_type;
                
                    public:
                      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
                    };
                
                  // Given an integral/enum type, return the corresponding unsigned
                  // integer type.
                  // Primary template.
                  /// make_unsigned
                  template<typename _Tp>
                    struct make_unsigned 
                    { typedef typename __make_unsigned_selector<_Tp>::__type type; };
                
                  // Integral, but don't define.
                  template<>
                    struct make_unsigned<bool>;
                
                
                  // Utility for finding the signed versions of unsigned integral types.
                  template<typename _Tp>
                    struct __make_signed
                    { typedef _Tp __type; };
                
                  template<>
                    struct __make_signed<char>
                    { typedef signed char __type; };
                
                  template<>
                    struct __make_signed<unsigned char>
                    { typedef signed char __type; };
                
                  template<>
                    struct __make_signed<unsigned short>
                    { typedef signed short __type; };
                
                  template<>
                    struct __make_signed<unsigned int>
                    { typedef signed int __type; };
                
                  template<>
                    struct __make_signed<unsigned long>
                    { typedef signed long __type; };
                
                  template<>
                    struct __make_signed<unsigned long long>
                    { typedef signed long long __type; };
                
                #if defined(_GLIBCXX_USE_WCHAR_T) && defined(__WCHAR_UNSIGNED__)
                  template<>
                    struct __make_signed<wchar_t> : __make_signed<__WCHAR_TYPE__>
                    { };
                #endif
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                  template<>
                    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
                    { };
                  template<>
                    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
                    { };
                #endif
                
                #if defined(__GLIBCXX_TYPE_INT_N_0)
                  template<>
                    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_0>
                    { typedef __GLIBCXX_TYPE_INT_N_0 __type; };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_1)
                  template<>
                    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_1>
                    { typedef __GLIBCXX_TYPE_INT_N_1 __type; };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_2)
                  template<>
                    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_2>
                    { typedef __GLIBCXX_TYPE_INT_N_2 __type; };
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_3)
                  template<>
                    struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_3>
                    { typedef __GLIBCXX_TYPE_INT_N_3 __type; };
                #endif
                
                  // Select between integral and enum: not possible to be both.
                  template<typename _Tp, 
                	   bool _IsInt = is_integral<_Tp>::value,
                	   bool _IsEnum = is_enum<_Tp>::value>
                    class __make_signed_selector;
                
                  template<typename _Tp>
                    class __make_signed_selector<_Tp, true, false>
                    {
                      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
                      typedef typename __signedt::__type __signed_type;
                      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;
                
                    public:
                      typedef typename __cv_signed::__type __type;
                    };
                
                  template<typename _Tp>
                    class __make_signed_selector<_Tp, false, true>
                    {
                      // With -fshort-enums, an enum may be as small as a char.
                      typedef signed char __smallest;
                      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
                      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
                      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
                      typedef conditional<__b2, signed int, signed long> __cond2;
                      typedef typename __cond2::type __cond2_type;
                      typedef conditional<__b1, signed short, __cond2_type> __cond1;
                      typedef typename __cond1::type __cond1_type;
                
                    public:
                      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
                    };
                
                  // Given an integral/enum type, return the corresponding signed
                  // integer type.
                  // Primary template.
                  /// make_signed
                  template<typename _Tp>
                    struct make_signed 
                    { typedef typename __make_signed_selector<_Tp>::__type type; };
                
                  // Integral, but don't define.
                  template<>
                    struct make_signed<bool>;
                
                #if __cplusplus > 201103L
                  /// Alias template for make_signed
                  template<typename _Tp>
                    using make_signed_t = typename make_signed<_Tp>::type;
                
                  /// Alias template for make_unsigned
                  template<typename _Tp>
                    using make_unsigned_t = typename make_unsigned<_Tp>::type;
                #endif
                
                  // Array modifications.
                
                  /// remove_extent
                  template<typename _Tp>
                    struct remove_extent
                    { typedef _Tp     type; };
                
                  template<typename _Tp, std::size_t _Size>
                    struct remove_extent<_Tp[_Size]>
                    { typedef _Tp     type; };
                
                  template<typename _Tp>
                    struct remove_extent<_Tp[]>
                    { typedef _Tp     type; };
                
                  /// remove_all_extents
                  template<typename _Tp>
                    struct remove_all_extents
                    { typedef _Tp     type; };
                
                  template<typename _Tp, std::size_t _Size>
                    struct remove_all_extents<_Tp[_Size]>
                    { typedef typename remove_all_extents<_Tp>::type     type; };
                
                  template<typename _Tp>
                    struct remove_all_extents<_Tp[]>
                    { typedef typename remove_all_extents<_Tp>::type     type; };
                
                #if __cplusplus > 201103L
                  /// Alias template for remove_extent
                  template<typename _Tp>
                    using remove_extent_t = typename remove_extent<_Tp>::type;
                
                  /// Alias template for remove_all_extents
                  template<typename _Tp>
                    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
                #endif
                
                  // Pointer modifications.
                
                  template<typename _Tp, typename>
                    struct __remove_pointer_helper
                    { typedef _Tp     type; };
                
                  template<typename _Tp, typename _Up>
                    struct __remove_pointer_helper<_Tp, _Up*>
                    { typedef _Up     type; };
                
                  /// remove_pointer
                  template<typename _Tp>
                    struct remove_pointer
                    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
                    { };
                
                  /// add_pointer
                  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
                				      is_void<_Tp>>::value>
                    struct __add_pointer_helper
                    { typedef _Tp     type; };
                
                  template<typename _Tp>
                    struct __add_pointer_helper<_Tp, true>
                    { typedef typename remove_reference<_Tp>::type*     type; };
                
                  template<typename _Tp>
                    struct add_pointer 
                    : public __add_pointer_helper<_Tp>
                    { };
                
                #if __cplusplus > 201103L
                  /// Alias template for remove_pointer
                  template<typename _Tp>
                    using remove_pointer_t = typename remove_pointer<_Tp>::type;
                
                  /// Alias template for add_pointer
                  template<typename _Tp>
                    using add_pointer_t = typename add_pointer<_Tp>::type;
                #endif
                
                  template<std::size_t _Len>
                    struct __aligned_storage_msa
                    { 
                      union __type
                      {
                	unsigned char __data[_Len];
                	struct __attribute__((__aligned__)) { } __align; 
                      };
                    };
                
                  /**
                   *  @brief Alignment type.
                   *
                   *  The value of _Align is a default-alignment which shall be the
                   *  most stringent alignment requirement for any C++ object type
                   *  whose size is no greater than _Len (3.9). The member typedef
                   *  type shall be a POD type suitable for use as uninitialized
                   *  storage for any object whose size is at most _Len and whose
                   *  alignment is a divisor of _Align.
                  */
                  template<std::size_t _Len, std::size_t _Align =
                	   __alignof__(typename __aligned_storage_msa<_Len>::__type)>
         392 ->     struct aligned_storage
                    { 
                      union type
                      {
                	unsigned char __data[_Len];
                	struct __attribute__((__aligned__((_Align)))) { } __align; 
                      };
                    };
                
                  template <typename... _Types>
                    struct __strictest_alignment
                    {
                      static const size_t _S_alignment = 0;
                      static const size_t _S_size = 0;
                    };
                
                  template <typename _Tp, typename... _Types>
                    struct __strictest_alignment<_Tp, _Types...>
                    {
                      static const size_t _S_alignment =
                        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
                	? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
                      static const size_t _S_size =
                        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
                	? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
                    };
                
                  /**
                   *  @brief Provide aligned storage for types.
                   *
                   *  [meta.trans.other]
                   *
                   *  Provides aligned storage for any of the provided types of at
                   *  least size _Len.
                   *
                   *  @see aligned_storage
                   */
                  template <size_t _Len, typename... _Types>
                    struct aligned_union
                    {
                    private:
                      static_assert(sizeof...(_Types) != 0, "At least one type is required");
                
                      using __strictest = __strictest_alignment<_Types...>;
                      static const size_t _S_len = _Len > __strictest::_S_size
                	? _Len : __strictest::_S_size;
                    public:
                      /// The value of the strictest alignment of _Types.
                      static const size_t alignment_value = __strictest::_S_alignment;
                      /// The storage.
                      typedef typename aligned_storage<_S_len, alignment_value>::type type;
                    };
                
                  template <size_t _Len, typename... _Types>
                    const size_t aligned_union<_Len, _Types...>::alignment_value;
                
                  // Decay trait for arrays and functions, used for perfect forwarding
                  // in make_pair, make_tuple, etc.
                  template<typename _Up, 
                	   bool _IsArray = is_array<_Up>::value,
                	   bool _IsFunction = is_function<_Up>::value> 
                    struct __decay_selector;
                
                  // NB: DR 705.
                  template<typename _Up> 
                    struct __decay_selector<_Up, false, false>
                    { typedef typename remove_cv<_Up>::type __type; };
                
                  template<typename _Up> 
                    struct __decay_selector<_Up, true, false>
                    { typedef typename remove_extent<_Up>::type* __type; };
                
                  template<typename _Up> 
                    struct __decay_selector<_Up, false, true>
                    { typedef typename add_pointer<_Up>::type __type; };
                
                  /// decay
                  template<typename _Tp> 
                    class decay 
                    { 
                      typedef typename remove_reference<_Tp>::type __remove_type;
                
                    public:
                      typedef typename __decay_selector<__remove_type>::__type type;
                    };
                
                  template<typename _Tp>
                    class reference_wrapper;
                
                  // Helper which adds a reference to a type when given a reference_wrapper
                  template<typename _Tp>
                    struct __strip_reference_wrapper
                    {
                      typedef _Tp __type;
                    };
                
                  template<typename _Tp>
                    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
                    {
                      typedef _Tp& __type;
                    };
                
                  template<typename _Tp>
                    struct __decay_and_strip
                    {
                      typedef typename __strip_reference_wrapper<
                	typename decay<_Tp>::type>::__type __type;
                    };
                
                
                  // Primary template.
                  /// Define a member typedef @c type only if a boolean constant is true.
                  template<bool, typename _Tp = void>
                    struct enable_if 
                    { };
                
                  // Partial specialization for true.
                  template<typename _Tp>
                    struct enable_if<true, _Tp>
                    { typedef _Tp type; };
                
                  template<typename... _Cond>
                    using _Require = typename enable_if<__and_<_Cond...>::value>::type;
                
                  // Primary template.
                  /// Define a member typedef @c type to one of two argument types.
                  template<bool _Cond, typename _Iftrue, typename _Iffalse>
                    struct conditional
                    { typedef _Iftrue type; };
                
                  // Partial specialization for false.
                  template<typename _Iftrue, typename _Iffalse>
                    struct conditional<false, _Iftrue, _Iffalse>
                    { typedef _Iffalse type; };
                
                  /// common_type
                  template<typename... _Tp>
                    struct common_type;
                
                  // Sfinae-friendly common_type implementation:
                
                  struct __do_common_type_impl
                  {
                    template<typename _Tp, typename _Up>
                      static __success_type<typename decay<decltype
                			    (true ? std::declval<_Tp>()
                			     : std::declval<_Up>())>::type> _S_test(int);
                
                    template<typename, typename>
                      static __failure_type _S_test(...);
                  };
                
                  template<typename _Tp, typename _Up>
                    struct __common_type_impl
                    : private __do_common_type_impl
                    {
                      typedef decltype(_S_test<_Tp, _Up>(0)) type;
                    };
                
                  struct __do_member_type_wrapper
                  {
                    template<typename _Tp>
                      static __success_type<typename _Tp::type> _S_test(int);
                
                    template<typename>
                      static __failure_type _S_test(...);
                  };
                
                  template<typename _Tp>
                    struct __member_type_wrapper
                    : private __do_member_type_wrapper
                    {
                      typedef decltype(_S_test<_Tp>(0)) type;
                    };
                
                  template<typename _CTp, typename... _Args>
                    struct __expanded_common_type_wrapper
                    {
                      typedef common_type<typename _CTp::type, _Args...> type;
                    };
                
                  template<typename... _Args>
                    struct __expanded_common_type_wrapper<__failure_type, _Args...>
                    { typedef __failure_type type; };
                
                  template<typename _Tp>
                    struct common_type<_Tp>
                    { typedef typename decay<_Tp>::type type; };
                
                  template<typename _Tp, typename _Up>
                    struct common_type<_Tp, _Up>
                    : public __common_type_impl<_Tp, _Up>::type
                    { };
                
                  template<typename _Tp, typename _Up, typename... _Vp>
                    struct common_type<_Tp, _Up, _Vp...>
                    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
                               common_type<_Tp, _Up>>::type, _Vp...>::type
                    { };
                
                  /// The underlying type of an enum.
                  template<typename _Tp>
                    struct underlying_type
                    {
                      typedef __underlying_type(_Tp) type;
                    };
                
                  template<typename _Tp>
                    struct __declval_protector
                    {
                      static const bool __stop = false;
                      static typename add_rvalue_reference<_Tp>::type __delegate();
                    };
                
                  template<typename _Tp>
                    inline typename add_rvalue_reference<_Tp>::type
                    declval() noexcept
                    {
                      static_assert(__declval_protector<_Tp>::__stop,
                		    "declval() must not be used!");
                      return __declval_protector<_Tp>::__delegate();
                    }
                
                  /// result_of
                  template<typename _Signature>
                    class result_of;
                
                  // Sfinae-friendly result_of implementation:
                
                #define __cpp_lib_result_of_sfinae 201210
                
                  // [func.require] paragraph 1 bullet 1:
                  struct __result_of_memfun_ref_impl
                  {
                    template<typename _Fp, typename _Tp1, typename... _Args>
                      static __success_type<decltype(
                      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
                      )> _S_test(int);
                
                    template<typename...>
                      static __failure_type _S_test(...);
                  };
                
                  template<typename _MemPtr, typename _Arg, typename... _Args>
                    struct __result_of_memfun_ref
                    : private __result_of_memfun_ref_impl
                    {
                      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
                    };
                
                  // [func.require] paragraph 1 bullet 2:
                  struct __result_of_memfun_deref_impl
                  {
                    template<typename _Fp, typename _Tp1, typename... _Args>
                      static __success_type<decltype(
                      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
                      )> _S_test(int);
                
                    template<typename...>
                      static __failure_type _S_test(...);
                  };
                
                  template<typename _MemPtr, typename _Arg, typename... _Args>
                    struct __result_of_memfun_deref
                    : private __result_of_memfun_deref_impl
                    {
                      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
                    };
                
                  // [func.require] paragraph 1 bullet 3:
                  struct __result_of_memobj_ref_impl
                  {
                    template<typename _Fp, typename _Tp1>
                      static __success_type<decltype(
                      std::declval<_Tp1>().*std::declval<_Fp>()
                      )> _S_test(int);
                
                    template<typename, typename>
                      static __failure_type _S_test(...);
                  };
                
                  template<typename _MemPtr, typename _Arg>
                    struct __result_of_memobj_ref
                    : private __result_of_memobj_ref_impl
                    {
                      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
                    };
                
                  // [func.require] paragraph 1 bullet 4:
                  struct __result_of_memobj_deref_impl
                  {
                    template<typename _Fp, typename _Tp1>
                      static __success_type<decltype(
                      (*std::declval<_Tp1>()).*std::declval<_Fp>()
                      )> _S_test(int);
                
                    template<typename, typename>
                      static __failure_type _S_test(...);
                  };
                
                  template<typename _MemPtr, typename _Arg>
                    struct __result_of_memobj_deref
                    : private __result_of_memobj_deref_impl
                    {
                      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
                    };
                
                  template<typename _MemPtr, typename _Arg>
                    struct __result_of_memobj;
                
                  template<typename _Res, typename _Class, typename _Arg>
                    struct __result_of_memobj<_Res _Class::*, _Arg>
                    {
                      typedef typename remove_cv<typename remove_reference<
                        _Arg>::type>::type _Argval;
                      typedef _Res _Class::* _MemPtr;
                      typedef typename conditional<__or_<is_same<_Argval, _Class>,
                        is_base_of<_Class, _Argval>>::value,
                        __result_of_memobj_ref<_MemPtr, _Arg>,
                        __result_of_memobj_deref<_MemPtr, _Arg>
                      >::type::type type;
                    };
                
                  template<typename _MemPtr, typename _Arg, typename... _Args>
                    struct __result_of_memfun;
                
                  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
                    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
                    {
                      typedef typename remove_cv<typename remove_reference<
                        _Arg>::type>::type _Argval;
                      typedef _Res _Class::* _MemPtr;
                      typedef typename conditional<__or_<is_same<_Argval, _Class>,
                        is_base_of<_Class, _Argval>>::value,
                        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
                        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
                      >::type::type type;
                    };
                
                  template<bool, bool, typename _Functor, typename... _ArgTypes>
                    struct __result_of_impl
                    {
                      typedef __failure_type type;
                    };
                
                  template<typename _MemPtr, typename _Arg>
                    struct __result_of_impl<true, false, _MemPtr, _Arg>
                    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
                    { };
                
                  template<typename _MemPtr, typename _Arg, typename... _Args>
                    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
                    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
                    { };
                
                  // [func.require] paragraph 1 bullet 5:
                  struct __result_of_other_impl
                  {
                    template<typename _Fn, typename... _Args>
                      static __success_type<decltype(
                      std::declval<_Fn>()(std::declval<_Args>()...)
                      )> _S_test(int);
                
                    template<typename...>
                      static __failure_type _S_test(...);
                  };
                
                  template<typename _Functor, typename... _ArgTypes>
                    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
                    : private __result_of_other_impl
                    {
                      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
                    };
                
                  template<typename _Functor, typename... _ArgTypes>
                    struct result_of<_Functor(_ArgTypes...)>
                    : public __result_of_impl<
                        is_member_object_pointer<
                          typename remove_reference<_Functor>::type
                        >::value,
                        is_member_function_pointer<
                          typename remove_reference<_Functor>::type
                        >::value,
                	    _Functor, _ArgTypes...
                      >::type
                    { };
                
                #if __cplusplus > 201103L
                  /// Alias template for aligned_storage
                  template<size_t _Len, size_t _Align =
                	    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
                    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
                
                  template <size_t _Len, typename... _Types>
                    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
                
                  /// Alias template for decay
                  template<typename _Tp>
                    using decay_t = typename decay<_Tp>::type;
                
                  /// Alias template for enable_if
                  template<bool _Cond, typename _Tp = void>
                    using enable_if_t = typename enable_if<_Cond, _Tp>::type;
                
                  /// Alias template for conditional
                  template<bool _Cond, typename _Iftrue, typename _Iffalse>
                    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
                
                  /// Alias template for common_type
                  template<typename... _Tp>
                    using common_type_t = typename common_type<_Tp...>::type;
                
                  /// Alias template for underlying_type
                  template<typename _Tp>
                    using underlying_type_t = typename underlying_type<_Tp>::type;
                
                  /// Alias template for result_of
                  template<typename _Tp>
                    using result_of_t = typename result_of<_Tp>::type;
                #endif
                
                  template<typename...> using __void_t = void;
                
                  /// @} group metaprogramming
                
                  /**
                   *  Use SFINAE to determine if the type _Tp has a publicly-accessible
                   *  member type _NTYPE.
                   */
                #define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE)				\
                  template<typename _Tp, typename = __void_t<>>				\
                    struct __has_##_NTYPE						\
                    : false_type							\
                    { };								\
                  template<typename _Tp>						\
                    struct __has_##_NTYPE<_Tp, __void_t<typename _Tp::_NTYPE>>		\
                    : true_type								\
                    { };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif  // C++11
                
                #endif  // _GLIBCXX_TYPE_TRAITS


Top 10 Lines:

     Line      Count

     1986        392

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      392   Total number of line executions
   392.00   Average executions per line


*** File /usr/include/c++/5/ext/aligned_buffer.h:
                // Aligned memory buffer -*- C++ -*-
                
                // Copyright (C) 2013-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/aligned_buffer.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _ALIGNED_BUFFER_H
                #define _ALIGNED_BUFFER_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                # include <type_traits>
                #else
                # include <bits/c++0x_warning.h>
                #endif
                
                namespace __gnu_cxx
                {
                  // A utility type containing a POD object that can hold an object of type
                  // _Tp initialized via placement new or allocator_traits::construct.
                  // Intended for use as a data member subobject, use __aligned_buffer for
                  // complete objects.
                  template<typename _Tp>
                    struct __aligned_membuf
                    {
                      // Target macro ADJUST_FIELD_ALIGN can produce different alignment for
                      // types when used as class members. __aligned_membuf is intended
                      // for use as a class member, so align the buffer as for a class member.
                      struct _Tp2 { _Tp _M_t; };
                
                      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
                
         226 ->       __aligned_membuf() = default;
                
                      // Can be used to avoid value-initialization zeroing _M_storage.
                      __aligned_membuf(std::nullptr_t) { }
                
                      void*
       26962 ->       _M_addr() noexcept
                      { return static_cast<void*>(&_M_storage); }
                
                      const void*
       59408 ->       _M_addr() const noexcept
                      { return static_cast<const void*>(&_M_storage); }
                
                      _Tp*
       26902 ->       _M_ptr() noexcept
                      { return static_cast<_Tp*>(_M_addr()); }
                
                      const _Tp*
       59517 ->       _M_ptr() const noexcept
                      { return static_cast<const _Tp*>(_M_addr()); }
                    };
                
                  // Similar to __aligned_membuf but aligned for complete objects, not members.
                  // This type is used in <forward_list>, <future>, <bits/shared_ptr_base.h>
                  // and <bits/hashtable_policy.h>, but ideally they would use __aligned_membuf
                  // instead, as it has smaller size for some types on some targets.
                  // This type is still used to avoid an ABI change.
                  template<typename _Tp>
                    struct __aligned_buffer
                    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
                    {
                      typename
                	std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
                	_M_storage;
                
         393 ->       __aligned_buffer() = default;
                
                      // Can be used to avoid value-initialization
                      __aligned_buffer(std::nullptr_t) { }
                
                      void*
         909 ->       _M_addr() noexcept
                      {
                        return static_cast<void*>(&_M_storage);
                      }
                
                      const void*
                      _M_addr() const noexcept
                      {
                        return static_cast<const void*>(&_M_storage);
                      }
                
                      _Tp*
         905 ->       _M_ptr() noexcept
                      { return static_cast<_Tp*>(_M_addr()); }
                
                      const _Tp*
                      _M_ptr() const noexcept
                      { return static_cast<const _Tp*>(_M_addr()); }
                    };
                
                } // namespace
                
                #endif /* _ALIGNED_BUFFER_H */


Top 10 Lines:

     Line      Count

       74      59517
       66      59408
       62      26962
       70      26902
       97        909
      109        905
       91        393
       56        226

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

   175222   Total number of line executions
 21902.75   Average executions per line


*** File /usr/include/c++/5/bits/stl_algobase.h:
                // Core algorithmic facilities -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algobase.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGOBASE_H
                #define _STL_ALGOBASE_H 1
                
                #include <bits/c++config.h>
                #include <bits/functexcept.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <ext/numeric_traits.h>
                #include <bits/stl_pair.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/stl_iterator.h>
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For std::swap and _GLIBCXX_MOVE
                #include <bits/predefined_ops.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus < 201103L
                  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                  // nutshell, we are partially implementing the resolution of DR 187,
                  // when it's safe, i.e., the value_types are equal.
                  template<bool _BoolType>
                    struct __iter_swap
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                        static void
                        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                        {
                          typedef typename iterator_traits<_ForwardIterator1>::value_type
                            _ValueType1;
                          _ValueType1 __tmp = _GLIBCXX_MOVE(*__a);
                          *__a = _GLIBCXX_MOVE(*__b);
                          *__b = _GLIBCXX_MOVE(__tmp);
                	}
                    };
                
                  template<>
                    struct __iter_swap<true>
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                        static void 
                        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                        {
                          swap(*__a, *__b);
                        }
                    };
                #endif
                
                  /**
                   *  @brief Swaps the contents of two iterators.
                   *  @ingroup mutating_algorithms
                   *  @param  __a  An iterator.
                   *  @param  __b  Another iterator.
                   *  @return   Nothing.
                   *
                   *  This function swaps the values pointed to by two iterators, not the
                   *  iterators themselves.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline void
                    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                
                #if __cplusplus < 201103L
                      typedef typename iterator_traits<_ForwardIterator1>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator2>::value_type
                	_ValueType2;
                
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                				  _ValueType2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                				  _ValueType1>)
                
                      typedef typename iterator_traits<_ForwardIterator1>::reference
                	_ReferenceType1;
                      typedef typename iterator_traits<_ForwardIterator2>::reference
                	_ReferenceType2;
                      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
                	&& __are_same<_ValueType1&, _ReferenceType1>::__value
                	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
                	iter_swap(__a, __b);
                #else
                      swap(*__a, *__b);
                #endif
                    }
                
                  /**
                   *  @brief Swap the elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @return   An iterator equal to @p first2+(last1-first1).
                   *
                   *  Swaps each element in the range @p [first1,last1) with the
                   *  corresponding element in the range @p [first2,(last1-first1)).
                   *  The ranges must not overlap.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _ForwardIterator2
                    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		_ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	std::iter_swap(__first1, __first2);
                      return __first2;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The lesser of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
       ##### ->     min(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return __b < __a ? __b : __a;
                      if (__b < __a)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The greater of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
        6311 ->     max(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return  __a < __b ? __b : __a;
                      if (__a < __b)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The lesser of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__b, __a) ? __b : __a;
                      if (__comp(__b, __a))
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The greater of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__a, __b) ? __b : __a;
                      if (__comp(__a, __b))
                	return __b;
                      return __a;
                    }
                
                  // If _Iterator is a __normal_iterator return its base (a plain pointer,
                  // normally) otherwise return it untouched.  See copy, fill, ... 
                  template<typename _Iterator>
                    struct _Niter_base
                    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
                    { };
                
                  template<typename _Iterator>
                    inline typename _Niter_base<_Iterator>::iterator_type
         310 ->     __niter_base(_Iterator __it)
                    { return std::_Niter_base<_Iterator>::_S_base(__it); }
                
                  // Likewise, for move_iterator.
                  template<typename _Iterator>
                    struct _Miter_base
                    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
                    { };
                
                  template<typename _Iterator>
                    inline typename _Miter_base<_Iterator>::iterator_type
         217 ->     __miter_base(_Iterator __it)
                    { return std::_Miter_base<_Iterator>::_S_base(__it); }
                
                  // All of these auxiliary structs serve two purposes.  (1) Replace
                  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                  // because the input and output ranges are permitted to overlap.)
                  // (2) If we're using random access iterators, then write the loop as
                  // a for loop with an explicit count.
                
                  template<bool, bool, typename>
                    struct __copy_move
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        __copy_m(_II __first, _II __last, _OI __result)
                        {
                	  for (; __first != __last; ++__result, ++__first)
                	    *__result = *__first;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move<true, false, _Category>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        __copy_m(_II __first, _II __last, _OI __result)
                        {
                	  for (; __first != __last; ++__result, ++__first)
                	    *__result = std::move(*__first);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move<false, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                        static _OI
       ##### ->         __copy_m(_II __first, _II __last, _OI __result)
                        { 
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = *__first;
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move<true, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        __copy_m(_II __first, _II __last, _OI __result)
                        { 
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = std::move(*__first);
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                        static _Tp*
         108 ->         __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
                        {
                #if __cplusplus >= 201103L
                	  // trivial types can have deleted assignment
                	  static_assert( is_copy_assignable<_Tp>::value,
                	                 "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
                	  return __result + _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
          98 ->     __copy_move_a(_II __first, _II __last, _OI __result)
                    {
                      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
                      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
                      typedef typename iterator_traits<_II>::iterator_category _Category;
                      const bool __simple = (__is_trivial(_ValueTypeI)
                	                     && __is_pointer<_II>::__value
                	                     && __is_pointer<_OI>::__value
                			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);
                
                      return std::__copy_move<_IsMove, __simple,
                	                      _Category>::__copy_m(__first, __last, __result);
                    }
                
                  // Helpers for streambuf iterators (either istream or ostream).
                  // NB: avoid including <iosfwd>, relatively large.
                  template<typename _CharT>
                    struct char_traits;
                
                  template<typename _CharT, typename _Traits>
                    class istreambuf_iterator;
                
                  template<typename _CharT, typename _Traits>
                    class ostreambuf_iterator;
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(_CharT*, _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(const _CharT*, const _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                				    _CharT*>::__type
                    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
          96 ->     __copy_move_a2(_II __first, _II __last, _OI __result)
                    {
                      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
                					     std::__niter_base(__last),
                					     std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (first - last)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the copy_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
         107 ->     copy(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
                	      (std::__miter_base(__first), std::__miter_base(__last),
                	       __result));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (first - last)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the move_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
                    move(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__copy_move_a2<true>(std::__miter_base(__first),
                				       std::__miter_base(__last), __result);
                    }
                
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
                #endif
                
                  template<bool, bool, typename>
                    struct __copy_move_backward
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  while (__first != __last)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move_backward<true, false, _Category>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  while (__first != __last)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move_backward<false, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move_backward<true, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        {
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                        static _Tp*
       ##### ->         __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                        {
                #if __cplusplus >= 201103L
                	  // trivial types can have deleted assignment
                	  static_assert( is_copy_assignable<_Tp>::value,
                	                 "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                	  return __result - _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
                      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
                      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                      const bool __simple = (__is_trivial(_ValueType1)
                	                     && __is_pointer<_BI1>::__value
                	                     && __is_pointer<_BI2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__copy_move_backward<_IsMove, __simple,
                	                               _Category>::__copy_move_b(__first,
                								 __last,
                								 __result);
                    }
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      return _BI2(std::__copy_move_backward_a<_IsMove>
                		  (std::__niter_base(__first), std::__niter_base(__last),
                		   std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (first - last)
                   *
                   *  The function has the same effect as copy, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use copy instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
                	      (std::__miter_base(__first), std::__miter_base(__last),
                	       __result));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (first - last)
                   *
                   *  The function has the same effect as move, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use move instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
                    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
                						std::__miter_base(__last),
                						__result);
                    }
                
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
                #endif
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
                    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                 	     const _Tp& __value)
                    {
                      for (; __first != __last; ++__first)
                	*__first = __value;
                    }
                    
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
                    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                	     const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __first != __last; ++__first)
                	*__first = __tmp;
                    }
                
                  // Specialization: for char types we can use memset.
                  template<typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
                    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
                    {
                      const _Tp __tmp = __c;
                      if (const size_t __len = __last - __first)
                	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
                    }
                
                  /**
                   *  @brief Fills the range [first,last) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
                		    __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, ++__first)
                	*__first = __value;
                      return __first;
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, ++__first)
                	*__first = __tmp;
                      return __first;
                    }
                
                  template<typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
                    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
                    {
                      std::__fill_a(__first, __first + __n, __c);
                      return __first + __n;
                    }
                
                  /**
                   *  @brief Fills the range [first,first+n) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An output iterator.
                   *  @param  __n      The count of copies to perform.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   The iterator at first+n.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @ wmemset.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 865. More algorithms that throw away information
                  */
                  template<typename _OI, typename _Size, typename _Tp>
                    inline _OI
                    fill_n(_OI __first, _Size __n, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
                
                      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
                    }
                
                  template<bool _BoolType>
                    struct __equal
                    {
                      template<typename _II1, typename _II2>
                        static bool
                        equal(_II1 __first1, _II1 __last1, _II2 __first2)
                        {
                	  for (; __first1 != __last1; ++__first1, ++__first2)
                	    if (!(*__first1 == *__first2))
                	      return false;
                	  return true;
                	}
                    };
                
                  template<>
                    struct __equal<true>
                    {
                      template<typename _Tp>
                        static bool
                        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
                        {
                	  if (const size_t __len = (__last1 - __first1))
                	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
                	  return true;
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple = ((__is_integer<_ValueType1>::__value
                			      || __is_pointer<_ValueType1>::__value)
                	                     && __is_pointer<_II1>::__value
                	                     && __is_pointer<_II2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__equal<__simple>::equal(__first1, __last1, __first2);
                    }
                
                  template<typename, typename>
                    struct __lc_rai
                    {
                      template<typename _II1, typename _II2>
                        static _II1
                        __newlast1(_II1, _II1 __last1, _II2, _II2)
                        { return __last1; }
                
                      template<typename _II>
                        static bool
                        __cnd2(_II __first, _II __last)
                        { return __first != __last; }
                    };
                
                  template<>
                    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
                    {
                      template<typename _RAI1, typename _RAI2>
                        static _RAI1
                        __newlast1(_RAI1 __first1, _RAI1 __last1,
                		   _RAI2 __first2, _RAI2 __last2)
                        {
                	  const typename iterator_traits<_RAI1>::difference_type
                	    __diff1 = __last1 - __first1;
                	  const typename iterator_traits<_RAI2>::difference_type
                	    __diff2 = __last2 - __first2;
                	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
                	}
                
                      template<typename _RAI>
                        static bool
                        __cnd2(_RAI, _RAI)
                        { return true; }
                    };
                
                  template<typename _II1, typename _II2, typename _Compare>
                    bool
                    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
                				   _II2 __first2, _II2 __last2,
                				   _Compare __comp)
                    {
                      typedef typename iterator_traits<_II1>::iterator_category _Category1;
                      typedef typename iterator_traits<_II2>::iterator_category _Category2;
                      typedef std::__lc_rai<_Category1, _Category2> __rai_type;
                
                      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
                      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                	   ++__first1, ++__first2)
                	{
                	  if (__comp(__first1, __first2))
                	    return true;
                	  if (__comp(__first2, __first1))
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  template<bool _BoolType>
                    struct __lexicographical_compare
                    {
                      template<typename _II1, typename _II2>
                        static bool __lc(_II1, _II1, _II2, _II2);
                    };
                
                  template<bool _BoolType>
                    template<typename _II1, typename _II2>
                      bool
                      __lexicographical_compare<_BoolType>::
                      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                      {
                	return std::__lexicographical_compare_impl(__first1, __last1,
                						   __first2, __last2,
                					__gnu_cxx::__ops::__iter_less_iter());
                      }
                
                  template<>
                    struct __lexicographical_compare<true>
                    {
                      template<typename _Tp, typename _Up>
                        static bool
                        __lc(const _Tp* __first1, const _Tp* __last1,
                	     const _Up* __first2, const _Up* __last2)
                	{
                	  const size_t __len1 = __last1 - __first1;
                	  const size_t __len2 = __last2 - __first2;
                	  if (const size_t __len = std::min(__len1, __len2))
                	    if (int __result = __builtin_memcmp(__first1, __first2, __len))
                	      return __result < 0;
                	  return __len1 < __len2;
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
                				  _II2 __first2, _II2 __last2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple =
                	(__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
                	 && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
                	 && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
                	 && __is_pointer<_II1>::__value
                	 && __is_pointer<_II2>::__value);
                
                      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                							    __first2, __last2);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _ForwardIterator
                    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the first position in which @a val could be inserted
                   *         without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return         An iterator pointing to the first element <em>not less
                   *                  than</em> @a val, or end() if every element is less than 
                   *                  @a val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val());
                    }
                
                  /// This is a helper function for the sort routines and for random.tcc.
                  //  Precondition: __n > 0.
                  inline _GLIBCXX_CONSTEXPR int
                  __lg(int __n)
                  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __lg(unsigned __n)
                  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long
                  __lg(long __n)
                  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long
                  __lg(unsigned long __n)
                  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __lg(long long __n)
                  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __lg(unsigned long long __n)
                  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__equal_aux(std::__niter_base(__first1),
                			      std::__niter_base(__last1),
                			      std::__niter_base(__first2));
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return true;
                    }
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_robust_nonmodifying_seq_ops 201304
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
                	if (!(*__first1 == *__first2))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,
                				       __binary_pred);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                #endif
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  <em>Returns true if the sequence of elements defined by the range
                   *  [first1,last1) is lexicographically less than the sequence of elements
                   *  defined by the range [first2,last2).  Returns false otherwise.</em>
                   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                   *  then this is an inline call to @c memcmp.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // concept requirements
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                #endif
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
                						std::__niter_base(__last1),
                						std::__niter_base(__first2),
                						std::__niter_base(__last2));
                    }
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  The same as the four-parameter @c lexicographical_compare, but uses the
                   *  comp parameter instead of @c <.
                  */
                  template<typename _II1, typename _II2, typename _Compare>
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_impl
                	(__first1, __last1, __first2, __last2,
                	 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __binary_pred(__first1, __first2))
                        {
                	  ++__first1;
                	  ++__first2;
                        }
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                	__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                #if __cplusplus > 201103L
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __first2 != __last2
                	     && __binary_pred(__first1, __first2))
                        {
                	  ++__first1;
                	  ++__first2;
                        }
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_ALGO
                } // namespace std
                
                // NB: This file is included within many other C++ includes, as a way
                // of getting the base algorithms. So, make sure that parallel bits
                // come in too if requested. 
                #ifdef _GLIBCXX_PARALLEL
                # include <parallel/algobase.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      219       6311
      282        310
      293        217
      373        108
      460        107
      389         98
      434         96

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

     7247   Total number of line executions
   557.46   Average executions per line


*** File /usr/include/c++/5/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<bool _TrivialValueTypes>
                    struct __uninitialized_copy
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
          94 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        {
                	  _ForwardIterator __cur = __result;
                	  __try
                	    {
                	      for (; __first != __last; ++__first, ++__cur)
                		std::_Construct(std::__addressof(*__cur), *__first);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__result, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_copy<true>
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
          54 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        { return std::copy(__first, __last, __result); }
                    };
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
         149 ->     uninitialized_copy(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // trivial types can have deleted assignment
                      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
                      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
                      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
                #endif
                
                      return std::__uninitialized_copy<__is_trivial(_ValueType1)
                				       && __is_trivial(_ValueType2)
                				       && __assignable>::
                	__uninit_copy(__first, __last, __result);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        { std::fill(__first, __last, __x); }
                    };
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                
                      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill(__first, __last, __x);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill_n
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill_n<true>
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        { return std::fill_n(__first, __n, __x); }
                    };
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 1339. uninitialized_fill_n should return the end of its range
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of copies to make.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
                    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill_n(__first, __n, __x);
                    }
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __first != __last; ++__first, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
         143 ->     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, allocator<_Tp>&)
                    { return std::uninitialized_copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                					 __result, __alloc);
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
         129 ->     __uninitialized_move_if_noexcept_a(_InputIterator __first,
                				       _InputIterator __last,
                				       _ForwardIterator __result,
                				       _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a
                	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    inline _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, allocator<_Tp2>&)
                    { return std::uninitialized_fill_n(__first, __n, __x); }
                
                
                  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                  // __uninitialized_fill_move, __uninitialized_move_fill.
                  // All of these algorithms take a user-supplied allocator, which is used
                  // for construction and destruction.
                
                  // __uninitialized_copy_move
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  move [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_move(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_copy
                  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                  
                  // __uninitialized_fill_move
                  // Fills [result, mid) with x, and moves [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last, _Allocator& __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_fill
                  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      __try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  // Extensions: __uninitialized_default, __uninitialized_default_n,
                  // __uninitialized_default_a, __uninitialized_default_n_a.
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_1
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  std::fill(__first, __last, _ValueType());
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  return std::fill_n(__first, __n, _ValueType());
                	}
                    };
                
                  // __uninitialized_default
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s).
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default(_ForwardIterator __first,
                			    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      std::__uninitialized_default_1<__is_trivial(_ValueType)
                				     && __assignable>::
                	__uninit_default(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with n default constructed value_type(s).
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      return __uninitialized_default_n_1<__is_trivial(_ValueType)
                				       && __assignable>::
                	__uninit_default_n(__first, __n);
                    }
                
                
                  // __uninitialized_default_a
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s), constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      allocator<_Tp>&)
                    { std::__uninitialized_default(__first, __last); }
                
                
                  // __uninitialized_default_n_a
                  // Fills [first, first + n) with n default constructed value_types(s),
                  // constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                    _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				_Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				allocator<_Tp>&)
                    { return std::__uninitialized_default_n(__first, __n); }
                
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    _ForwardIterator
                    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    { return std::uninitialized_copy(__first, __first + __n, __result); }
                
                  /**
                   *  @brief Copies the range [first,first+n) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  __result + __n
                   *
                   *  Like copy_n(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy_n(_InputIterator __first, _Size __n,
                			 _ForwardIterator __result)
                    { return std::__uninitialized_copy_n(__first, __n, __result,
                					 std::__iterator_category(__first)); }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

      107        149
      279        143
      297        129
       68         94
       91         54

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

      569   Total number of line executions
   113.80   Average executions per line


*** File /home/sbillah/dmclock/sim/sim_client.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                
                #include <atomic>
                #include <mutex>
                #include <condition_variable>
                #include <thread>
                #include <chrono>
                #include <vector>
                #include <deque>
                #include <iostream>
                
                #include "sim_recs.h"
                
                
                namespace crimson {
                  namespace qos_simulation {
                
                    struct req_op_t {};
                    struct wait_op_t {};
                    constexpr struct req_op_t req_op {};
                    constexpr struct wait_op_t wait_op {};
                
                
                    enum class CliOp { req, wait };
                    struct CliInst {
                      CliOp op;
           3 ->       union {
                	std::chrono::milliseconds wait_time;
                	struct {
                	  uint16_t count;
                	  std::chrono::microseconds time_bw_reqs;
                	  uint16_t max_outstanding;
                	} req_params;
                      } args;
                
                      // D is a duration type
                      template<typename D>
           1 ->       CliInst(wait_op_t, D duration) :
                	op(CliOp::wait)
                      {
                	args.wait_time =
                	  std::chrono::duration_cast<std::chrono::milliseconds>(duration);
                      }
                
           2 ->       CliInst(req_op_t,
                	      uint16_t count, double ops_per_sec, uint16_t max_outstanding) :
                	op(CliOp::req)
                      {
                	args.req_params.count = count;
                	args.req_params.max_outstanding = max_outstanding;
                	uint32_t us = uint32_t(0.5 + 1.0 / ops_per_sec * 1000000);
                	args.req_params.time_bw_reqs = std::chrono::microseconds(us);
                      }
                    };
                
                
                    using ServerSelectFunc = std::function<const ServerId&(uint64_t seed)>;
                
                
                    template<typename SvcTrk, typename ReqPm, typename RespPm, typename Accum>
                    class SimulatedClient {
                    public:
                
                      struct InternalStats {
                	std::mutex mtx;
                	std::chrono::nanoseconds track_resp_time;
                	std::chrono::nanoseconds get_req_params_time;
                	uint32_t track_resp_count;
                	uint32_t get_req_params_count;
                
           7 -> 	InternalStats() :
                	  track_resp_time(0),
                	  get_req_params_time(0),
                	  track_resp_count(0),
                	  get_req_params_count(0)
                	{
                	  // empty
                	}
                      };
                
                      using SubmitFunc =
                	std::function<void(const ServerId&,
                			   const TestRequest&,
                			   const ClientId&,
                			   const ReqPm&)>;
                
                      using ClientAccumFunc = std::function<void(Accum&,const RespPm&)>;
                
                      typedef std::chrono::time_point<std::chrono::steady_clock> TimePoint;
                
        2343 ->       static TimePoint now() { return std::chrono::steady_clock::now(); }
                
                    protected:
                
        5232 ->       struct RespQueueItem {
                	TestResponse response;
                	ServerId     server_id;
                	RespPm       resp_params;
                      };
                
                      const ClientId id;
                      const SubmitFunc submit_f;
                      const ServerSelectFunc server_select_f;
                      const ClientAccumFunc accum_f;
                
                      std::vector<CliInst> instructions;
                
                      SvcTrk service_tracker;
                
                      // TODO: use lock rather than atomic???
                      std::atomic_ulong        outstanding_ops;
                      std::atomic_bool         requests_complete;
                
                      std::deque<RespQueueItem> resp_queue;
                
                      std::mutex               mtx_req;
                      std::condition_variable  cv_req;
                
                      std::mutex               mtx_resp;
                      std::condition_variable  cv_resp;
                
                      using RespGuard = std::lock_guard<decltype(mtx_resp)>;
                      using Lock = std::unique_lock<std::mutex>;
                
                      // data collection
                
                      std::vector<TimePoint>   op_times;
                      Accum                    accumulator;
                      InternalStats            internal_stats;
                
                      std::thread              thd_req;
                      std::thread              thd_resp;
                
                    public:
                
           4 ->       SimulatedClient(ClientId _id,
                		      const SubmitFunc& _submit_f,
                		      const ServerSelectFunc& _server_select_f,
                		      const ClientAccumFunc& _accum_f,
                		      const std::vector<CliInst>& _instrs) :
                	id(_id),
                	submit_f(_submit_f),
                	server_select_f(_server_select_f),
                	accum_f(_accum_f),
                	instructions(_instrs),
                	service_tracker(),
                	outstanding_ops(0),
                	requests_complete(false)
                      {
                	size_t op_count = 0;
                	for (auto i : instructions) {
                	  if (CliOp::req == i.op) {
                	    op_count += i.args.req_params.count;
                	  }
                	}
                	op_times.reserve(op_count);
                
                	thd_resp = std::thread(&SimulatedClient::run_resp, this);
                	thd_req = std::thread(&SimulatedClient::run_req, this);
                      }
                
                
                      SimulatedClient(ClientId _id,
                		      const SubmitFunc& _submit_f,
                		      const ServerSelectFunc& _server_select_f,
                		      const ClientAccumFunc& _accum_f,
                		      uint16_t _ops_to_run,
                		      double _iops_goal,
                		      uint16_t _outstanding_ops_allowed) :
                	SimulatedClient(_id,
                			_submit_f, _server_select_f, _accum_f,
                			{{req_op, _ops_to_run, _iops_goal, _outstanding_ops_allowed}})
                      {
                	// empty
                      }
                
                
                      SimulatedClient(const SimulatedClient&) = delete;
                      SimulatedClient(SimulatedClient&&) = delete;
                      SimulatedClient& operator=(const SimulatedClient&) = delete;
                      SimulatedClient& operator=(SimulatedClient&&) = delete;
                
          20 ->       virtual ~SimulatedClient() {
                	wait_until_done();
                      }
                
        3035 ->       void receive_response(const TestResponse& resp,
                			    const ServerId& server_id,
                			    const RespPm& resp_params) {
                	RespGuard g(mtx_resp);
                	resp_queue.push_back(RespQueueItem{resp, server_id, resp_params});
                	cv_resp.notify_one();
                      }
                
          40 ->       const std::vector<TimePoint>& get_op_times() const { return op_times; }
                
          20 ->       void wait_until_done() {
                	if (thd_req.joinable()) thd_req.join();
                	if (thd_resp.joinable()) thd_resp.join();
                      }
                
          20 ->       const Accum& get_accumulator() const { return accumulator; }
                
          10 ->       const InternalStats& get_internal_stats() const { return internal_stats; }
                
                    protected:
                
           6 ->       void run_req() {
                	size_t ops_count = 0;
                	for (auto i : instructions) {
                	  if (CliOp::wait == i.op) {
                	    std::this_thread::sleep_for(i.args.wait_time);
                	  } else if (CliOp::req == i.op) {
                	    Lock l(mtx_req);
                	    for (uint64_t o = 0; o < i.args.req_params.count; ++o) {
                	      while (outstanding_ops >= i.args.req_params.max_outstanding) {
                		cv_req.wait(l);
                	      }
                
                	      l.unlock();
                	      auto now = std::chrono::steady_clock::now();
                	      const ServerId& server = server_select_f(o);
                
                	      ReqPm rp =
                		time_stats_w_return<decltype(internal_stats.get_req_params_time),
                				    ReqPm>(internal_stats.mtx,
                					   internal_stats.get_req_params_time,
        1819 -> 					   [&]() -> ReqPm {
                					     return service_tracker.get_req_params(server);
                					   });
                	      count_stats(internal_stats.mtx,
                			  internal_stats.get_req_params_count);
                
                	      TestRequest req(server, o, 12);
                	      submit_f(server, req, id, rp);
                	      ++outstanding_ops;
                	      l.lock(); // lock for return to top of loop
                
                	      auto delay_time = now + i.args.req_params.time_bw_reqs;
                	      while (std::chrono::steady_clock::now() < delay_time) {
                		cv_req.wait_until(l, delay_time);
                	      } // while
                	    } // for
                	    ops_count += i.args.req_params.count;
                	  } else {
                	    assert(false);
                	  }
                	} // for loop
                
                	requests_complete = true;
                
                	// all requests made, thread ends
                      }
                
                
           7 ->       void run_resp() {
                	std::chrono::milliseconds delay(1000);
                	int op = 0;
                
                	Lock l(mtx_resp);
                
                	// since the following code would otherwise be repeated (except for
                	// the call to notify_one) in the two loops below; let's avoid
                	// repetition and define it once.
        2199 -> 	const auto proc_resp = [this, &op, &l](const bool notify_req_cv) {
                	  if (!resp_queue.empty()) {
                	    RespQueueItem item = resp_queue.front();
                	    resp_queue.pop_front();
                
                	    l.unlock();
                
                	    // data collection
                
                	    op_times.push_back(now());
                	    accum_f(accumulator, item.resp_params);
                
                	    // processing
                
                #if 0 // not needed
                	    TestResponse& resp = item.response;
                #endif
                
                	    time_stats(internal_stats.mtx,
                		       internal_stats.track_resp_time,
        2282 -> 		       [&](){
                			 service_tracker.track_resp(item.server_id, item.resp_params);
                		       });
                	    count_stats(internal_stats.mtx,
                			internal_stats.track_resp_count);
                
                	    --outstanding_ops;
                	    if (notify_req_cv) {
                	      cv_req.notify_one();
                	    }
                
                	    l.lock();
                	  }
                	};
                
                	while(!requests_complete.load()) {
                	  while(resp_queue.empty() && !requests_complete.load()) {
                	    cv_resp.wait_for(l, delay);
                	  }
                	  proc_resp(true);
                	}
                
                	while(outstanding_ops.load() > 0) {
                	  while(resp_queue.empty() && outstanding_ops.load() > 0) {
                	    cv_resp.wait_for(l, delay);
                	  }
                	  proc_resp(false); // don't call notify_one as all requests are complete
                	}
                
                	// all responses received, thread ends
                      }
                    }; // class SimulatedClient
                
                
                  }; // namespace qos_simulation
                }; // namespace crimson


Top 10 Lines:

     Line      Count

      104       5232
      196       3035
      100       2343
      294       2282
      274       2199
      237       1819
      204         40
      192         20
      206         20
      211         20

Execution Summary:

       18   Executable lines in this file
       18   Lines executed
   100.00   Percent of the file executed

    17050   Total number of line executions
   947.22   Average executions per line


*** File /home/sbillah/dmclock/sim/simulate.h:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #pragma once
                
                
                #include <assert.h>
                
                #include <memory>
                #include <chrono>
                #include <map>
                #include <random>
                #include <iostream>
                #include <iomanip>
                #include <string>
                
                
                namespace crimson {
                  namespace qos_simulation {
                
                    template<typename ServerId, typename ClientId, typename TS, typename TC>
                    class Simulation {
                  
                    public:
                
                      using TimePoint = std::chrono::time_point<std::chrono::steady_clock>;
                
                    protected:
                
                      using ClientMap = std::map<ClientId,TC*>;
                      using ServerMap = std::map<ServerId,TS*>;
                
                      uint server_count = 0;
                      uint client_count = 0;
                
                      ServerMap servers;
                      ClientMap clients;
                      std::vector<ServerId> server_ids;
                
                      TimePoint early_time;
                      TimePoint servers_created_time;
                      TimePoint clients_created_time;
                      TimePoint clients_finished_time;
                      TimePoint late_time;
                
                      std::default_random_engine prng;
                
                      bool has_run = false;
                
                
                    public:
                
                      double fmt_tp(const TimePoint& t) {
                	auto c = t.time_since_epoch().count();
                	return uint64_t(c / 1000000.0 + 0.5) % 100000 / 1000.0;
                      }
                
           4 ->       TimePoint now() {
                	return std::chrono::steady_clock::now();
                      }
                
                      using ClientBasedServerSelectFunc =
                	std::function<const ServerId&(uint64_t, uint16_t)>;
                
                      using ClientFilter = std::function<bool(const ClientId&)>;
                
                      using ServerFilter = std::function<bool(const ServerId&)>;
                
                      using ServerDataOutF =
                	std::function<void(std::ostream& out,
                			   Simulation* sim, ServerFilter,
                			   int header_w, int data_w, int data_prec)>;
                
                      using ClientDataOutF =
                	std::function<void(std::ostream& out,
                			   Simulation* sim, ClientFilter,
                			   int header_w, int data_w, int data_prec)>;
                
           1 ->       Simulation() :
                	early_time(now()),
                	prng(std::chrono::system_clock::now().time_since_epoch().count())
                      {
                	// empty
                      }
                
          33 ->       uint get_client_count() const { return client_count; }
         303 ->       uint get_server_count() const { return server_count; }
        3207 ->       TC& get_client(ClientId id) { return *clients[id]; }
        2030 ->       TS& get_server(ServerId id) { return *servers[id]; }
                      const ServerId& get_server_id(uint index) const {
                	return server_ids[index];
                      }
                
                
           1 ->       void add_servers(uint count,
                		       std::function<TS*(ServerId)> create_server_f) {
                	uint i = server_count;
                
                	// increment server_count before creating servers since they
                	// will start running immediately and may use the server_count
                	// value; NB: this could still be an issue if servers are
                	// added with multiple add_servers calls; consider using a
                	// separate start function after all servers (and clients?)
                	// have been added
                	server_count += count;
                
                	for (; i < server_count; ++i) {
                	  server_ids.push_back(i);
                	  servers[i] = create_server_f(i);
                	}
                
                	servers_created_time = now();
                      }
                
                
           1 ->       void add_clients(uint count,
                		       std::function<TC*(ClientId)> create_client_f) {
                	uint i = client_count;
                
                	// increment client_count before creating clients since they
                	// will start running immediately and may use the client_count
                	// value (e.g., in the server selection function); NB: this could
                	// still be an issue if clients are added with multiple
                	// add_clients calls; consider using a separate start function
                	// after all clients have been added
                	client_count += count;
                
                	for (; i < client_count; ++i) {
                	  clients[i] = create_client_f(i);
                	}
                
                	clients_created_time = now();
                      }
                
                
           1 ->       void run() {
                	assert(server_count > 0);
                	assert(client_count > 0);
                
                	std::cout << "simulation started" << std::endl;
                
                	// clients are now running; wait for all to finish
                
                	for (auto const &i : clients) {
                	  i.second->wait_until_done();
                	}
                
                	late_time = clients_finished_time = now();
                
                	std::cout << "simulation completed in " <<
                	  std::chrono::duration_cast<std::chrono::milliseconds>(clients_finished_time - servers_created_time).count() <<
                	  " millisecs" << std::endl;
                
                	has_run = true;
                      } // run
                
                
           1 ->       void display_stats(std::ostream& out,
                			 ServerDataOutF server_out_f, ClientDataOutF client_out_f,
                			 ServerFilter server_filter =
                			 [] (const ServerId&) { return true; },
                			 ClientFilter client_filter =
                			 [] (const ClientId&) { return true; },
                			 int head_w = 12, int data_w = 8, int data_prec = 2) {
                	assert(has_run);
                
                	// skip first 2 secondsd of data
                	const std::chrono::seconds skip_amount(0);
                	// calculate in groups of 5 seconds
                	const std::chrono::seconds measure_unit(2);
                	// unit to output reports in
                	const std::chrono::seconds report_unit(1);
                
                	// compute and display stats
                
                	TimePoint earliest_start = late_time;
                	TimePoint latest_start = early_time;
                	TimePoint earliest_finish = late_time;
                	TimePoint latest_finish = early_time;
                
                	for (auto const &c : clients) {
                	  auto start = c.second->get_op_times().front();
                	  auto end = c.second->get_op_times().back();
                
                	  if (start < earliest_start) { earliest_start = start; }
                	  if (start > latest_start) { latest_start = start; }
                	  if (end < earliest_finish) { earliest_finish = end; }
                	  if (end > latest_finish) { latest_finish = end; }
                	}
                
                	double ops_factor =
                	  std::chrono::duration_cast<std::chrono::duration<double>>(measure_unit) /
                	  std::chrono::duration_cast<std::chrono::duration<double>>(report_unit);
                
                	const auto start_edge = clients_created_time + skip_amount;
                
                	std::map<ClientId,std::vector<double>> ops_data;
                
                	for (auto const &c : clients) {
                	  auto it = c.second->get_op_times().begin();
                	  const auto end = c.second->get_op_times().end();
                	  while (it != end && *it < start_edge) { ++it; }
                
                	  for (auto time_edge = start_edge + measure_unit;
                	       time_edge < latest_finish;
                	       time_edge += measure_unit) {
                	    int count = 0;
                	    for (; it != end && *it < time_edge; ++count, ++it) { /* empty */ }
                	    double ops_per_second = double(count) / ops_factor;
                	    ops_data[c.first].push_back(ops_per_second);
                	  }
                	}
                
                	out << "==== Client Data ====" << std::endl;
                
                	out << std::setw(head_w) << "client:";
                	for (auto const &c : clients) {
                	  if (!client_filter(c.first)) continue;
                	  out << std::setw(data_w) << c.first;
                	}
                	out << std::setw(data_w) << "total" << std::endl;
                
                	{
                	  bool has_data;
                	  size_t i = 0;
                	  do {
                	    std::string line_header = "t_" + std::to_string(i) + ":";
                	    out << std::setw(head_w) << line_header;
                	    has_data = false;
                	    double total = 0.0;
                	    for (auto const &c : clients) {
                	      double data = 0.0;
                	      if (i < ops_data[c.first].size()) {
                		data = ops_data[c.first][i];
                		has_data = true;
                	      }
                	      total += data;
                
                	      if (!client_filter(c.first)) continue;
                
                	      out << std::setw(data_w) << std::setprecision(data_prec) <<
                		std::fixed << data;
                	    }
                	    out << std::setw(data_w) << std::setprecision(data_prec) <<
                	      std::fixed << total << std::endl;
                	    ++i;
                	  } while(has_data);
                	}
                
                	client_out_f(out, this, client_filter, head_w, data_w, data_prec);
                
                	display_client_internal_stats<std::chrono::nanoseconds>(out,
                								"nanoseconds");
                
                	out << std::endl << "==== Server Data ====" << std::endl;
                
                	out << std::setw(head_w) << "server:";
                	for (auto const &s : servers) {
                	  if (!server_filter(s.first)) continue;
                	  out << std::setw(data_w) << s.first;
                	}
                	out << std::setw(data_w) << "total" << std::endl;
                
                	server_out_f(out, this, server_filter, head_w, data_w, data_prec);
                
                	display_server_internal_stats<std::chrono::nanoseconds>(out,
                								"nanoseconds");
                
                	// clean up clients then servers
                
                	for (auto i = clients.begin(); i != clients.end(); ++i) {
                	  delete i->second;
                	  i->second = nullptr;
                	}
                
                	for (auto i = servers.begin(); i != servers.end(); ++i) {
                	  delete i->second;
                	  i->second = nullptr;
                	}
                      } // display_stats
                
                
                      template<typename T>
           1 ->       void display_server_internal_stats(std::ostream& out,
                					 std::string time_unit) {
                	T add_request_time(0);
                	T request_complete_time(0);
                	uint32_t add_request_count = 0;
                	uint32_t request_complete_count = 0;
                
                	for (uint i = 0; i < get_server_count(); ++i) {
                	  const auto& server = get_server(i);
                	  const auto& is = server.get_internal_stats();
                	  add_request_time +=
                	    std::chrono::duration_cast<T>(is.add_request_time);
                	  request_complete_time +=
                	    std::chrono::duration_cast<T>(is.request_complete_time);
                	  add_request_count += is.add_request_count;
                	  request_complete_count += is.request_complete_count;
                	}
                
                	double add_request_time_per_unit =
                	  double(add_request_time.count()) / add_request_count ;
                	out << "total time to add requests: " <<
                	  std::fixed << add_request_time.count() << " " << time_unit <<
                	  ";" << std::endl <<
                	  "    count: " << add_request_count << ";" << std::endl <<
                	  "    average: " << add_request_time_per_unit <<
                	  " " << time_unit << " per request/response" << std::endl;
                
                	double request_complete_time_unit =
                	  double(request_complete_time.count()) / request_complete_count ;
                	out << "total time to note requests complete: " << std::fixed <<
                	  request_complete_time.count() << " " << time_unit << ";" <<
                	  std::endl << 
                	  "    count: " << request_complete_count << ";" << std::endl <<
                	  "    average: " << request_complete_time_unit <<
                	  " " << time_unit << " per request/response" << std::endl;
                
                	out << std::endl;
                
                	assert(add_request_count == request_complete_count);
                	out << "server timing for QOS algorithm: " <<
                	  add_request_time_per_unit + request_complete_time_unit <<
                	  " " << time_unit << " per request/response" << std::endl;
                      }
                
                
                      template<typename T>
           1 ->       void display_client_internal_stats(std::ostream& out,
                					 std::string time_unit) {
                	T track_resp_time(0);
                	T get_req_params_time(0);
                	uint32_t track_resp_count = 0;
                	uint32_t get_req_params_count = 0;
                
                	for (uint i = 0; i < get_client_count(); ++i) {
                	  const auto& client = get_client(i);
                	  const auto& is = client.get_internal_stats();
                	  track_resp_time +=
                	    std::chrono::duration_cast<T>(is.track_resp_time);
                	  get_req_params_time +=
                	    std::chrono::duration_cast<T>(is.get_req_params_time);
                	  track_resp_count += is.track_resp_count;
                	  get_req_params_count += is.get_req_params_count;
                	}
                
                	double track_resp_time_unit =
                	  double(track_resp_time.count()) / track_resp_count;
                	out << "total time to track responses: " <<
                	  std::fixed << track_resp_time.count() << " " << time_unit << ";" <<
                	  std::endl <<
                	  "    count: " << track_resp_count << ";" << std::endl <<
                	  "    average: " << track_resp_time_unit << " " << time_unit <<
                	  " per request/response" << std::endl;
                
                	double get_req_params_time_unit =
                	  double(get_req_params_time.count()) / get_req_params_count;
                	out << "total time to get request parameters: " <<
                	  std::fixed << get_req_params_time.count() << " " << time_unit <<
                	  ";" << std::endl <<
                	  "    count: " << get_req_params_count << ";" << std::endl <<
                	  "    average: " << get_req_params_time_unit << " " << time_unit <<
                	  " per request/response" << std::endl;
                
                	out << std::endl;
                
                	assert(track_resp_count == get_req_params_count);
                	out << "client timing for QOS algorithm: " <<
                	  track_resp_time_unit + get_req_params_time_unit << " " <<
                	  time_unit << " per request/response" << std::endl;
                      }
                
                
                      // **** server selection functions ****
                
                
                      const ServerId& server_select_alternate(uint64_t seed,
                					      uint16_t client_idx) {
                	uint index = (client_idx + seed) % server_count;
                	return server_ids[index];
                      }
                
                
                      // returns a lambda using the range specified as servers_per (client)
                      ClientBasedServerSelectFunc
           1 ->       make_server_select_alt_range(uint16_t servers_per) {
                	return [servers_per,this](uint64_t seed, uint16_t client_idx)
        1772 -> 	  -> const ServerId& {
                	  double factor = double(server_count) / client_count;
                	  uint offset = seed % servers_per;
                	  uint index = (uint(0.5 + client_idx * factor) + offset) % server_count;
                	  return server_ids[index];
                	};
                      }
                
                
                      // function to choose a server randomly
                      const ServerId& server_select_random(uint64_t seed, uint16_t client_idx) {
                	uint index = prng() % server_count;
                	return server_ids[index];
                      }
                
                  
                      // function to choose a server randomly
                      ClientBasedServerSelectFunc
                      make_server_select_ran_range(uint16_t servers_per) {
                	return [servers_per,this](uint64_t seed, uint16_t client_idx)
                	  -> const ServerId& {
                	  double factor = double(server_count) / client_count;
                	  uint offset = prng() % servers_per;
                	  uint index = (uint(0.5 + client_idx * factor) + offset) % server_count;
                	  return server_ids[index];
                	};
                      }
                
                
                      // function to always choose the first server
                      const ServerId& server_select_0(uint64_t seed, uint16_t client_idx) {
                	return server_ids[0];
                      }
                    }; // class Simulation
                
                  }; // namespace qos_simulation
                }; // namespace crimson


Top 10 Lines:

     Line      Count

       93       3207
       94       2030
      394       1772
       92        303
       91         33
       63          4
       84          1
      100          1
      121          1
      141          1

Execution Summary:

       14   Executable lines in this file
       14   Lines executed
   100.00   Percent of the file executed

     7357   Total number of line executions
   525.50   Average executions per line


*** File /usr/include/c++/5/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                #include <bits/c++allocator.h> // Define the base class to std::allocator.
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup allocators
                   *  @{
                   */
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                      typedef void        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                #endif
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per [20.4].
                   *
                   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
                   *  for further details.
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class allocator: public __allocator_base<_Tp>
                    {
                   public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                #endif
                
        1196 ->       allocator() throw() { }
                
        1188 ->       allocator(const allocator& __a) throw()
                      : __allocator_base<_Tp>(__a) { }
                
                      template<typename _Tp1>
         916 ->         allocator(const allocator<_Tp1>&) throw() { }
                
        2395 ->       ~allocator() throw() { }
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_USE_NOEXCEPT
                    { return true; }
                
                  template<typename _Tp>
                    inline bool
                    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
                    _GLIBCXX_USE_NOEXCEPT
                    { return true; }
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_USE_NOEXCEPT
                    { return false; }
                
                  template<typename _Tp>
                    inline bool
       ##### ->     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
                    _GLIBCXX_USE_NOEXCEPT
                    { return false; }
                
                  /// @} group allocator
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __allocator_base
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) _GLIBCXX_NOEXCEPT { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two) _GLIBCXX_NOEXCEPT
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, bool
                    = __or_<is_copy_constructible<typename _Tp::value_type>,
                            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
                    struct __shrink_to_fit_aux
                    { static bool _S_do_it(_Tp&) noexcept { return false; } };
                
                  template<typename _Tp>
                    struct __shrink_to_fit_aux<_Tp, true>
                    {
                      static bool
                      _S_do_it(_Tp& __c) noexcept
                      {
                #if __cpp_exceptions
                	try
                	  {
                	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
                		__make_move_if_noexcept_iterator(__c.end()),
                		__c.get_allocator()).swap(__c);
                	    return true;
                	  }
                	catch(...)
                	  { return false; }
                #else
                	return false;
                #endif
                      }
                    };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      121       2395
      113       1196
      115       1188
      119        916

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

     5695   Total number of line executions
  1139.00   Average executions per line


*** File /usr/include/c++/5/bits/deque.tcc:
                // Deque implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/deque.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{deque}
                 */
                
                #ifndef _DEQUE_TCC
                #define _DEQUE_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                #if __cplusplus >= 201103L
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_default_initialize()
                    {
                      _Map_pointer __cur;
                      __try
                        {
                          for (__cur = this->_M_impl._M_start._M_node;
                	       __cur < this->_M_impl._M_finish._M_node;
                	       ++__cur)
                            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
                					   _M_get_Tp_allocator());
                          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
                					 this->_M_impl._M_finish._M_cur,
                					 _M_get_Tp_allocator());
                        }
                      __catch(...)
                        {
                          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
                			_M_get_Tp_allocator());
                          __throw_exception_again;
                        }
                    }
                #endif
                
                  template <typename _Tp, typename _Alloc>
                    deque<_Tp, _Alloc>&
                    deque<_Tp, _Alloc>::
                    operator=(const deque& __x)
                    {
                      if (&__x != this)
                	{
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // Replacement allocator cannot free existing storage,
                		  // so deallocate everything and take copy of __x's data.
                		  _M_replace_map(__x, __x.get_allocator());
                		  std::__alloc_on_copy(_M_get_Tp_allocator(),
                				       __x._M_get_Tp_allocator());
                		  return *this;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __len = size();
                	  if (__len >= __x.size())
                	    _M_erase_at_end(std::copy(__x.begin(), __x.end(),
                				      this->_M_impl._M_start));
                	  else
                	    {
                	      const_iterator __mid = __x.begin() + difference_type(__len);
                	      std::copy(__x.begin(), __mid, this->_M_impl._M_start);
                	      insert(this->_M_impl._M_finish, __mid, __x.end());
                	    }
                	}
                      return *this;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
                      deque<_Tp, _Alloc>::
                      emplace_front(_Args&&... __args)
                      {
                	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
                	  {
                	    _Alloc_traits::construct(this->_M_impl,
                	                             this->_M_impl._M_start._M_cur - 1,
                			             std::forward<_Args>(__args)...);
                	    --this->_M_impl._M_start._M_cur;
                	  }
                	else
                	  _M_push_front_aux(std::forward<_Args>(__args)...);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
        7680 ->       deque<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish._M_cur
                	    != this->_M_impl._M_finish._M_last - 1)
                	  {
                	    _Alloc_traits::construct(this->_M_impl,
                	                             this->_M_impl._M_finish._M_cur,
                			             std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish._M_cur;
                	  }
                	else
                	  _M_push_back_aux(std::forward<_Args>(__args)...);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      typename deque<_Tp, _Alloc>::iterator
                      deque<_Tp, _Alloc>::
                      emplace(const_iterator __position, _Args&&... __args)
                      {
                	if (__position._M_cur == this->_M_impl._M_start._M_cur)
                	  {
                	    emplace_front(std::forward<_Args>(__args)...);
                	    return this->_M_impl._M_start;
                	  }
                	else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
                	  {
                	    emplace_back(std::forward<_Args>(__args)...);
                	    iterator __tmp = this->_M_impl._M_finish;
                	    --__tmp;
                	    return __tmp;
                	  }
                	else
                	  return _M_insert_aux(__position._M_const_cast(),
                			       std::forward<_Args>(__args)...);
                      }
                #endif
                
                  template <typename _Tp, typename _Alloc>
                    typename deque<_Tp, _Alloc>::iterator
                    deque<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      if (__position._M_cur == this->_M_impl._M_start._M_cur)
                	{
                	  push_front(__x);
                	  return this->_M_impl._M_start;
                	}
                      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
                	{
                	  push_back(__x);
                	  iterator __tmp = this->_M_impl._M_finish;
                	  --__tmp;
                	  return __tmp;
                	}
                      else
                	return _M_insert_aux(__position._M_const_cast(), __x);
                   }
                
                  template <typename _Tp, typename _Alloc>
                    typename deque<_Tp, _Alloc>::iterator
                    deque<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      iterator __next = __position;
                      ++__next;
                      const difference_type __index = __position - begin();
                      if (static_cast<size_type>(__index) < (size() >> 1))
                	{
                	  if (__position != begin())
                	    _GLIBCXX_MOVE_BACKWARD3(begin(), __position, __next);
                	  pop_front();
                	}
                      else
                	{
                	  if (__next != end())
                	    _GLIBCXX_MOVE3(__next, end(), __position);
                	  pop_back();
                	}
                      return begin() + __index;
                    }
                
                  template <typename _Tp, typename _Alloc>
                    typename deque<_Tp, _Alloc>::iterator
                    deque<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first == __last)
                	return __first;
                      else if (__first == begin() && __last == end())
                	{
                	  clear();
                	  return end();
                	}
                      else
                	{
                	  const difference_type __n = __last - __first;
                	  const difference_type __elems_before = __first - begin();
                	  if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
                	    {
                	      if (__first != begin())
                		_GLIBCXX_MOVE_BACKWARD3(begin(), __first, __last);
                	      _M_erase_at_begin(begin() + __n);
                	    }
                	  else
                	    {
                	      if (__last != end())
                		_GLIBCXX_MOVE3(__last, end(), __first);
                	      _M_erase_at_end(end() - __n);
                	    }
                	  return begin() + __elems_before;
                	}
                    }
                
                  template <typename _Tp, class _Alloc>
                    template <typename _InputIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                        iterator __cur = begin();
                        for (; __first != __last && __cur != end(); ++__cur, ++__first)
                          *__cur = *__first;
                        if (__first == __last)
                          _M_erase_at_end(__cur);
                        else
                          insert(end(), __first, __last);
                      }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
                    {
                      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
                	{
                	  iterator __new_start = _M_reserve_elements_at_front(__n);
                	  __try
                	    {
                	      std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
                					  __x, _M_get_Tp_allocator());
                	      this->_M_impl._M_start = __new_start;
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(__new_start._M_node,
                			       this->_M_impl._M_start._M_node);
                	      __throw_exception_again;
                	    }
                	}
                      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
                	{
                	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                	  __try
                	    {
                	      std::__uninitialized_fill_a(this->_M_impl._M_finish,
                					  __new_finish, __x,
                					  _M_get_Tp_allocator());
                	      this->_M_impl._M_finish = __new_finish;
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                	      __throw_exception_again;
                	    }
                	}
                      else
                        _M_insert_aux(__pos, __n, __x);
                    }
                
                #if __cplusplus >= 201103L
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n)
                	{
                	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                	  __try
                	    {
                	      std::__uninitialized_default_a(this->_M_impl._M_finish,
                					     __new_finish,
                					     _M_get_Tp_allocator());
                	      this->_M_impl._M_finish = __new_finish;
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                	      __throw_exception_again;
                	    }
                	}
                    }
                
                  template <typename _Tp, typename _Alloc>
                    bool
                    deque<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      const difference_type __front_capacity
                	= (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
                      if (__front_capacity == 0)
                	return false;
                
                      const difference_type __back_capacity
                	= (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
                      if (__front_capacity + __back_capacity < _S_buffer_size())
                	return false;
                
                      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
                    }
                #endif
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_fill_initialize(const value_type& __value)
                    {
                      _Map_pointer __cur;
                      __try
                        {
                          for (__cur = this->_M_impl._M_start._M_node;
                	       __cur < this->_M_impl._M_finish._M_node;
                	       ++__cur)
                            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
                					__value, _M_get_Tp_allocator());
                          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
                				      this->_M_impl._M_finish._M_cur,
                				      __value, _M_get_Tp_allocator());
                        }
                      __catch(...)
                        {
                          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
                			_M_get_Tp_allocator());
                          __throw_exception_again;
                        }
                    }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _InputIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                                          std::input_iterator_tag)
                      {
                        this->_M_initialize_map(0);
                        __try
                          {
                            for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	      emplace_back(*__first);
                #else
                              push_back(*__first);
                #endif
                          }
                        __catch(...)
                          {
                            clear();
                            __throw_exception_again;
                          }
                      }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _ForwardIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                                          std::forward_iterator_tag)
                      {
                        const size_type __n = std::distance(__first, __last);
                        this->_M_initialize_map(__n);
                
                        _Map_pointer __cur_node;
                        __try
                          {
                            for (__cur_node = this->_M_impl._M_start._M_node;
                                 __cur_node < this->_M_impl._M_finish._M_node;
                                 ++__cur_node)
                	      {
                		_ForwardIterator __mid = __first;
                		std::advance(__mid, _S_buffer_size());
                		std::__uninitialized_copy_a(__first, __mid, *__cur_node,
                					    _M_get_Tp_allocator());
                		__first = __mid;
                	      }
                            std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_finish._M_first,
                					_M_get_Tp_allocator());
                          }
                        __catch(...)
                          {
                            std::_Destroy(this->_M_impl._M_start,
                			  iterator(*__cur_node, __cur_node),
                			  _M_get_Tp_allocator());
                            __throw_exception_again;
                          }
                      }
                
                  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.
                  template<typename _Tp, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename... _Args>
                      void
         374 ->       deque<_Tp, _Alloc>::
                      _M_push_back_aux(_Args&&... __args)
                #else
                      void
                      deque<_Tp, _Alloc>::
                      _M_push_back_aux(const value_type& __t)
                #endif
                      {
                	_M_reserve_map_at_back();
                	*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
                	__try
                	  {
                #if __cplusplus >= 201103L
                	    _Alloc_traits::construct(this->_M_impl,
                	                             this->_M_impl._M_finish._M_cur,
                			             std::forward<_Args>(__args)...);
                #else
                	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
                #endif
                	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
                						+ 1);
                	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
                	  }
                	__catch(...)
                	  {
                	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
                	    __throw_exception_again;
                	  }
                      }
                
                  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_first.
                  template<typename _Tp, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename... _Args>
                      void
                      deque<_Tp, _Alloc>::
                      _M_push_front_aux(_Args&&... __args)
                #else
                      void
                      deque<_Tp, _Alloc>::
                      _M_push_front_aux(const value_type& __t)
                #endif
                      {
                	_M_reserve_map_at_front();
                	*(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
                	__try
                	  {
                	    this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
                					       - 1);
                	    this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
                #if __cplusplus >= 201103L
                	    _Alloc_traits::construct(this->_M_impl,
                	                             this->_M_impl._M_start._M_cur,
                			             std::forward<_Args>(__args)...);
                #else
                	    this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);
                #endif
                	  }
                	__catch(...)
                	  {
                	    ++this->_M_impl._M_start;
                	    _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
                	    __throw_exception_again;
                	  }
                      }
                
                  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_first.
                  template <typename _Tp, typename _Alloc>
                    void deque<_Tp, _Alloc>::
                    _M_pop_back_aux()
                    {
                      _M_deallocate_node(this->_M_impl._M_finish._M_first);
                      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
                      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
                      _Alloc_traits::destroy(_M_get_Tp_allocator(),
                			     this->_M_impl._M_finish._M_cur);
                    }
                
                  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.
                  // Note that if the deque has at least one element (a precondition for this
                  // member function), and if
                  //   _M_impl._M_start._M_cur == _M_impl._M_start._M_last,
                  // then the deque must have at least two nodes.
                  template <typename _Tp, typename _Alloc>
         353 ->     void deque<_Tp, _Alloc>::
                    _M_pop_front_aux()
                    {
                      _Alloc_traits::destroy(_M_get_Tp_allocator(),
                			     this->_M_impl._M_start._M_cur);
                      _M_deallocate_node(this->_M_impl._M_start._M_first);
                      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
                      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
                    }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _InputIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_insert_aux(iterator __pos,
                                          _InputIterator __first, _InputIterator __last,
                                          std::input_iterator_tag)
                      { std::copy(__first, __last, std::inserter(*this, __pos)); }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _ForwardIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_range_insert_aux(iterator __pos,
                                          _ForwardIterator __first, _ForwardIterator __last,
                                          std::forward_iterator_tag)
                      {
                        const size_type __n = std::distance(__first, __last);
                        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
                	  {
                	    iterator __new_start = _M_reserve_elements_at_front(__n);
                	    __try
                	      {
                		std::__uninitialized_copy_a(__first, __last, __new_start,
                					    _M_get_Tp_allocator());
                		this->_M_impl._M_start = __new_start;
                	      }
                	    __catch(...)
                	      {
                		_M_destroy_nodes(__new_start._M_node,
                				 this->_M_impl._M_start._M_node);
                		__throw_exception_again;
                	      }
                	  }
                        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
                	  {
                	    iterator __new_finish = _M_reserve_elements_at_back(__n);
                	    __try
                	      {
                		std::__uninitialized_copy_a(__first, __last,
                					    this->_M_impl._M_finish,
                					    _M_get_Tp_allocator());
                		this->_M_impl._M_finish = __new_finish;
                	      }
                	    __catch(...)
                	      {
                		_M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                				 __new_finish._M_node + 1);
                		__throw_exception_again;
                	      }
                	  }
                        else
                          _M_insert_aux(__pos, __first, __last, __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename... _Args>
                      typename deque<_Tp, _Alloc>::iterator
                      deque<_Tp, _Alloc>::
                      _M_insert_aux(iterator __pos, _Args&&... __args)
                      {
                	value_type __x_copy(std::forward<_Args>(__args)...); // XXX copy
                #else
                    typename deque<_Tp, _Alloc>::iterator
                      deque<_Tp, _Alloc>::
                      _M_insert_aux(iterator __pos, const value_type& __x)
                      {
                	value_type __x_copy = __x; // XXX copy
                #endif
                	difference_type __index = __pos - this->_M_impl._M_start;
                	if (static_cast<size_type>(__index) < size() / 2)
                	  {
                	    push_front(_GLIBCXX_MOVE(front()));
                	    iterator __front1 = this->_M_impl._M_start;
                	    ++__front1;
                	    iterator __front2 = __front1;
                	    ++__front2;
                	    __pos = this->_M_impl._M_start + __index;
                	    iterator __pos1 = __pos;
                	    ++__pos1;
                	    _GLIBCXX_MOVE3(__front2, __pos1, __front1);
                	  }
                	else
                	  {
                	    push_back(_GLIBCXX_MOVE(back()));
                	    iterator __back1 = this->_M_impl._M_finish;
                	    --__back1;
                	    iterator __back2 = __back1;
                	    --__back2;
                	    __pos = this->_M_impl._M_start + __index;
                	    _GLIBCXX_MOVE_BACKWARD3(__pos, __back2, __back1);
                	  }
                	*__pos = _GLIBCXX_MOVE(__x_copy);
                	return __pos;
                      }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
                    {
                      const difference_type __elems_before = __pos - this->_M_impl._M_start;
                      const size_type __length = this->size();
                      value_type __x_copy = __x;
                      if (__elems_before < difference_type(__length / 2))
                	{
                	  iterator __new_start = _M_reserve_elements_at_front(__n);
                	  iterator __old_start = this->_M_impl._M_start;
                	  __pos = this->_M_impl._M_start + __elems_before;
                	  __try
                	    {
                	      if (__elems_before >= difference_type(__n))
                		{
                		  iterator __start_n = (this->_M_impl._M_start
                					+ difference_type(__n));
                		  std::__uninitialized_move_a(this->_M_impl._M_start,
                					      __start_n, __new_start,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_start = __new_start;
                		  _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
                		  std::fill(__pos - difference_type(__n), __pos, __x_copy);
                		}
                	      else
                		{
                		  std::__uninitialized_move_fill(this->_M_impl._M_start,
                						 __pos, __new_start,
                						 this->_M_impl._M_start,
                						 __x_copy,
                						 _M_get_Tp_allocator());
                		  this->_M_impl._M_start = __new_start;
                		  std::fill(__old_start, __pos, __x_copy);
                		}
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(__new_start._M_node,
                			       this->_M_impl._M_start._M_node);
                	      __throw_exception_again;
                	    }
                	}
                      else
                	{
                	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                	  iterator __old_finish = this->_M_impl._M_finish;
                	  const difference_type __elems_after =
                	    difference_type(__length) - __elems_before;
                	  __pos = this->_M_impl._M_finish - __elems_after;
                	  __try
                	    {
                	      if (__elems_after > difference_type(__n))
                		{
                		  iterator __finish_n = (this->_M_impl._M_finish
                					 - difference_type(__n));
                		  std::__uninitialized_move_a(__finish_n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
                		  std::fill(__pos, __pos + difference_type(__n), __x_copy);
                		}
                	      else
                		{
                		  std::__uninitialized_fill_move(this->_M_impl._M_finish,
                						 __pos + difference_type(__n),
                						 __x_copy, __pos,
                						 this->_M_impl._M_finish,
                						 _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  std::fill(__pos, __old_finish, __x_copy);
                		}
                	    }
                	  __catch(...)
                	    {
                	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                	      __throw_exception_again;
                	    }
                	}
                    }
                
                  template <typename _Tp, typename _Alloc>
                    template <typename _ForwardIterator>
                      void
                      deque<_Tp, _Alloc>::
                      _M_insert_aux(iterator __pos,
                                    _ForwardIterator __first, _ForwardIterator __last,
                                    size_type __n)
                      {
                        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
                        const size_type __length = size();
                        if (static_cast<size_type>(__elemsbefore) < __length / 2)
                	  {
                	    iterator __new_start = _M_reserve_elements_at_front(__n);
                	    iterator __old_start = this->_M_impl._M_start;
                	    __pos = this->_M_impl._M_start + __elemsbefore;
                	    __try
                	      {
                		if (__elemsbefore >= difference_type(__n))
                		  {
                		    iterator __start_n = (this->_M_impl._M_start
                					  + difference_type(__n));
                		    std::__uninitialized_move_a(this->_M_impl._M_start,
                						__start_n, __new_start,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_start = __new_start;
                		    _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
                		    std::copy(__first, __last, __pos - difference_type(__n));
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, difference_type(__n) - __elemsbefore);
                		    std::__uninitialized_move_copy(this->_M_impl._M_start,
                						   __pos, __first, __mid,
                						   __new_start,
                						   _M_get_Tp_allocator());
                		    this->_M_impl._M_start = __new_start;
                		    std::copy(__mid, __last, __old_start);
                		  }
                	      }
                	    __catch(...)
                	      {
                		_M_destroy_nodes(__new_start._M_node,
                				 this->_M_impl._M_start._M_node);
                		__throw_exception_again;
                	      }
                	  }
                        else
                        {
                          iterator __new_finish = _M_reserve_elements_at_back(__n);
                          iterator __old_finish = this->_M_impl._M_finish;
                          const difference_type __elemsafter =
                            difference_type(__length) - __elemsbefore;
                          __pos = this->_M_impl._M_finish - __elemsafter;
                          __try
                            {
                              if (__elemsafter > difference_type(__n))
                		{
                		  iterator __finish_n = (this->_M_impl._M_finish
                					 - difference_type(__n));
                		  std::__uninitialized_move_a(__finish_n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
                		  std::copy(__first, __last, __pos);
                		}
                              else
                		{
                		  _ForwardIterator __mid = __first;
                		  std::advance(__mid, __elemsafter);
                		  std::__uninitialized_copy_move(__mid, __last, __pos,
                						 this->_M_impl._M_finish,
                						 this->_M_impl._M_finish,
                						 _M_get_Tp_allocator());
                		  this->_M_impl._M_finish = __new_finish;
                		  std::copy(__first, __mid, __pos);
                		}
                            }
                          __catch(...)
                            {
                              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                			       __new_finish._M_node + 1);
                              __throw_exception_again;
                            }
                        }
                      }
                
                   template<typename _Tp, typename _Alloc>
                     void
         100 ->      deque<_Tp, _Alloc>::
                     _M_destroy_data_aux(iterator __first, iterator __last)
                     {
                       for (_Map_pointer __node = __first._M_node + 1;
                	    __node < __last._M_node; ++__node)
                	 std::_Destroy(*__node, *__node + _S_buffer_size(),
                		       _M_get_Tp_allocator());
                
                       if (__first._M_node != __last._M_node)
                	 {
                	   std::_Destroy(__first._M_cur, __first._M_last,
                			 _M_get_Tp_allocator());
                	   std::_Destroy(__last._M_first, __last._M_cur,
                			 _M_get_Tp_allocator());
                	 }
                       else
                	 std::_Destroy(__first._M_cur, __last._M_cur,
                		       _M_get_Tp_allocator());
                     }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_new_elements_at_front(size_type __new_elems)
                    {
                      if (this->max_size() - this->size() < __new_elems)
                	__throw_length_error(__N("deque::_M_new_elements_at_front"));
                
                      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
                				     / _S_buffer_size());
                      _M_reserve_map_at_front(__new_nodes);
                      size_type __i;
                      __try
                        {
                          for (__i = 1; __i <= __new_nodes; ++__i)
                            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
                        }
                      __catch(...)
                        {
                          for (size_type __j = 1; __j < __i; ++__j)
                            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
                          __throw_exception_again;
                        }
                    }
                
                  template <typename _Tp, typename _Alloc>
                    void
                    deque<_Tp, _Alloc>::
                    _M_new_elements_at_back(size_type __new_elems)
                    {
                      if (this->max_size() - this->size() < __new_elems)
                	__throw_length_error(__N("deque::_M_new_elements_at_back"));
                
                      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
                				     / _S_buffer_size());
                      _M_reserve_map_at_back(__new_nodes);
                      size_type __i;
                      __try
                        {
                          for (__i = 1; __i <= __new_nodes; ++__i)
                            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
                        }
                      __catch(...)
                        {
                          for (size_type __j = 1; __j < __i; ++__j)
                            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
                          __throw_exception_again;
                        }
                    }
                
                  template <typename _Tp, typename _Alloc>
                    void
          52 ->     deque<_Tp, _Alloc>::
                    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
                    {
                      const size_type __old_num_nodes
                	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
                      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
                
                      _Map_pointer __new_nstart;
                      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
                	{
                	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
                					 - __new_num_nodes) / 2
                	                 + (__add_at_front ? __nodes_to_add : 0);
                	  if (__new_nstart < this->_M_impl._M_start._M_node)
                	    std::copy(this->_M_impl._M_start._M_node,
                		      this->_M_impl._M_finish._M_node + 1,
                		      __new_nstart);
                	  else
                	    std::copy_backward(this->_M_impl._M_start._M_node,
                			       this->_M_impl._M_finish._M_node + 1,
                			       __new_nstart + __old_num_nodes);
                	}
                      else
                	{
                	  size_type __new_map_size = this->_M_impl._M_map_size
                	                             + std::max(this->_M_impl._M_map_size,
                						__nodes_to_add) + 2;
                
                	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
                	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                	                 + (__add_at_front ? __nodes_to_add : 0);
                	  std::copy(this->_M_impl._M_start._M_node,
                		    this->_M_impl._M_finish._M_node + 1,
                		    __new_nstart);
                	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                
                	  this->_M_impl._M_map = __new_map;
                	  this->_M_impl._M_map_size = __new_map_size;
                	}
                
                      this->_M_impl._M_start._M_set_node(__new_nstart);
                      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
                    }
                
                  // Overload for deque::iterators, exploiting the "segmented-iterator
                  // optimization".
                  template<typename _Tp>
                    void
                    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
                	 const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                
                      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
                           __node < __last._M_node; ++__node)
                	std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);
                
                      if (__first._M_node != __last._M_node)
                	{
                	  std::fill(__first._M_cur, __first._M_last, __value);
                	  std::fill(__last._M_first, __last._M_cur, __value);
                	}
                      else
                	std::fill(__first._M_cur, __last._M_cur, __value);
                    }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  const difference_type __clen
                	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
                				       __result._M_last - __result._M_cur));
                	  std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
                	  __first += __clen;
                	  __result += __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  difference_type __llen = __last._M_cur - __last._M_first;
                	  _Tp* __lend = __last._M_cur;
                
                	  difference_type __rlen = __result._M_cur - __result._M_first;
                	  _Tp* __rend = __result._M_cur;
                
                	  if (!__llen)
                	    {
                	      __llen = _Self::_S_buffer_size();
                	      __lend = *(__last._M_node - 1) + __llen;
                	    }
                	  if (!__rlen)
                	    {
                	      __rlen = _Self::_S_buffer_size();
                	      __rend = *(__result._M_node - 1) + __rlen;
                	    }
                
                	  const difference_type __clen = std::min(__len,
                						  std::min(__llen, __rlen));
                	  std::copy_backward(__lend - __clen, __lend, __rend);
                	  __last -= __clen;
                	  __result -= __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  const difference_type __clen
                	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
                				       __result._M_last - __result._M_cur));
                	  std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
                	  __first += __clen;
                	  __result += __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    {
                      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                      typedef typename _Self::difference_type difference_type;
                
                      difference_type __len = __last - __first;
                      while (__len > 0)
                	{
                	  difference_type __llen = __last._M_cur - __last._M_first;
                	  _Tp* __lend = __last._M_cur;
                
                	  difference_type __rlen = __result._M_cur - __result._M_first;
                	  _Tp* __rend = __result._M_cur;
                
                	  if (!__llen)
                	    {
                	      __llen = _Self::_S_buffer_size();
                	      __lend = *(__last._M_node - 1) + __llen;
                	    }
                	  if (!__rlen)
                	    {
                	      __rlen = _Self::_S_buffer_size();
                	      __rend = *(__result._M_node - 1) + __rlen;
                	    }
                
                	  const difference_type __clen = std::min(__len,
                						  std::min(__llen, __rlen));
                	  std::move_backward(__lend - __clen, __lend, __rend);
                	  __last -= __clen;
                	  __result -= __clen;
                	  __len -= __clen;
                	}
                      return __result;
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      149       7680
      462        374
      546        353
      829        100
      901         52

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

     8559   Total number of line executions
  1711.80   Average executions per line


*** File /usr/include/c++/5/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <new>
                #include <bits/move.h>
                #include <ext/alloc_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   */
                #if __cplusplus >= 201103L
                  template<typename _T1, typename... _Args>
                    inline void
          11 ->     _Construct(_T1* __p, _Args&&... __args)
                    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
                #else
                  template<typename _T1, typename _T2>
                    inline void
                    _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                #endif
                
                  /**
                   * Destroy the object pointed to by a pointer type.
                   */
                  template<typename _Tp>
                    inline void
       ##### ->     _Destroy(_Tp* __pointer)
                    { __pointer->~_Tp(); }
                
                  template<bool>
                    struct _Destroy_aux
                    {
                      template<typename _ForwardIterator>
                        static void
         178 ->         __destroy(_ForwardIterator __first, _ForwardIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    std::_Destroy(std::__addressof(*__first));
                	}
                    };
                
                  template<>
                    struct _Destroy_aux<true>
                    {
                      template<typename _ForwardIterator>
                        static void
          89 ->         __destroy(_ForwardIterator, _ForwardIterator) { }
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator>
                    inline void
         267 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy(__first, __last);
                    }
                
                  /**
                   * Destroy a range of objects using the supplied allocator.  For
                   * nondefault allocators we do not optimize away invocation of 
                   * destroy() even if _Tp has a trivial destructor.
                   */
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator& __alloc)
                    {
                      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                      for (; __first != __last; ++__first)
                	__traits::destroy(__alloc, std::__addressof(*__first));
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
         268 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     allocator<_Tp>&)
                    {
                      _Destroy(__first, __last);
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */
                


Top 10 Lines:

     Line      Count

      148        268
      122        267
      100        178
      112         89
       74         11

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

      813   Total number of line executions
   135.50   Average executions per line


*** File /usr/include/c++/5/bits/shared_ptr_base.h:
                // shared_ptr and weak_ptr implementation details -*- C++ -*-
                
                // Copyright (C) 2007-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                // GCC Note: Based on files from version 1.32.0 of the Boost library.
                
                //  shared_count.hpp
                //  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
                
                //  shared_ptr.hpp
                //  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.
                //  Copyright (C) 2001, 2002, 2003 Peter Dimov
                
                //  weak_ptr.hpp
                //  Copyright (C) 2001, 2002, 2003 Peter Dimov
                
                //  enable_shared_from_this.hpp
                //  Copyright (C) 2002 Peter Dimov
                
                // Distributed under the Boost Software License, Version 1.0. (See
                // accompanying file LICENSE_1_0.txt or copy at
                // http://www.boost.org/LICENSE_1_0.txt)
                
                /** @file bits/shared_ptr_base.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _SHARED_PTR_BASE_H
                #define _SHARED_PTR_BASE_H 1
                
                #include <bits/allocated_ptr.h>
                #include <ext/aligned_buffer.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if _GLIBCXX_USE_DEPRECATED
                  template<typename> class auto_ptr;
                #endif
                
                 /**
                   *  @brief  Exception possibly thrown by @c shared_ptr.
                   *  @ingroup exceptions
                   */
                  class bad_weak_ptr : public std::exception
                  {
                  public:
                    virtual char const*
                    what() const noexcept;
                
                    virtual ~bad_weak_ptr() noexcept;    
                  };
                
                  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.
                  inline void
                  __throw_bad_weak_ptr()
                  { _GLIBCXX_THROW_OR_ABORT(bad_weak_ptr()); }
                
                  using __gnu_cxx::_Lock_policy;
                  using __gnu_cxx::__default_lock_policy;
                  using __gnu_cxx::_S_single;
                  using __gnu_cxx::_S_mutex;
                  using __gnu_cxx::_S_atomic;
                
                  // Empty helper class except when the template argument is _S_mutex.
                  template<_Lock_policy _Lp>
         395 ->     class _Mutex_base
                    {
                    protected:
                      // The atomic policy uses fully-fenced builtins, single doesn't care.
                      enum { _S_need_barriers = 0 };
                    };
                
                  template<>
                    class _Mutex_base<_S_mutex>
                    : public __gnu_cxx::__mutex
                    {
                    protected:
                      // This policy is used when atomic builtins are not available.
                      // The replacement atomic operations might not have the necessary
                      // memory barriers.
                      enum { _S_need_barriers = 1 };
                    };
                
                  template<_Lock_policy _Lp = __default_lock_policy>
                    class _Sp_counted_base
                    : public _Mutex_base<_Lp>
                    {
                    public:  
         397 ->       _Sp_counted_base() noexcept
                      : _M_use_count(1), _M_weak_count(1) { }
                      
                      virtual
         117 ->       ~_Sp_counted_base() noexcept
                      { }
                  
                      // Called when _M_use_count drops to zero, to release the resources
                      // managed by *this.
                      virtual void
                      _M_dispose() noexcept = 0;
                      
                      // Called when _M_weak_count drops to zero.
                      virtual void
       ##### ->       _M_destroy() noexcept
                      { delete this; }
                      
                      virtual void*
                      _M_get_deleter(const std::type_info&) noexcept = 0;
                
                      void
         161 ->       _M_add_ref_copy()
                      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }
                  
                      void
                      _M_add_ref_lock();
                
                      bool
                      _M_add_ref_lock_nothrow();
                
                      void
          80 ->       _M_release() noexcept
                      {
                        // Be race-detector-friendly.  For more info see bits/c++config.
                        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
                	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
                	  {
                            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
                	    _M_dispose();
                	    // There must be a memory barrier between dispose() and destroy()
                	    // to ensure that the effects of dispose() are observed in the
                	    // thread that runs destroy().
                	    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
                	    if (_Mutex_base<_Lp>::_S_need_barriers)
                	      {
                	        _GLIBCXX_READ_MEM_BARRIER;
                	        _GLIBCXX_WRITE_MEM_BARRIER;
                	      }
                
                            // Be race-detector-friendly.  For more info see bits/c++config.
                            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
                	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
                						       -1) == 1)
                              {
                                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
                	        _M_destroy();
                              }
                	  }
                      }
                  
                      void
                      _M_weak_add_ref() noexcept
                      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
                
                      void
                      _M_weak_release() noexcept
                      {
                        // Be race-detector-friendly. For more info see bits/c++config.
                        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
                	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
                	  {
                            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
                	    if (_Mutex_base<_Lp>::_S_need_barriers)
                	      {
                	        // See _M_release(),
                	        // destroy() must observe results of dispose()
                	        _GLIBCXX_READ_MEM_BARRIER;
                	        _GLIBCXX_WRITE_MEM_BARRIER;
                	      }
                	    _M_destroy();
                	  }
                      }
                  
                      long
                      _M_get_use_count() const noexcept
                      {
                        // No memory barrier is used here so there is no synchronization
                        // with other threads.
                        return __atomic_load_n(&_M_use_count, __ATOMIC_RELAXED);
                      }
                
                    private:  
                      _Sp_counted_base(_Sp_counted_base const&) = delete;
                      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;
                
                      _Atomic_word  _M_use_count;     // #shared
                      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)
                    };
                
                  template<>
                    inline void
                    _Sp_counted_base<_S_single>::
                    _M_add_ref_lock()
                    {
                      if (_M_use_count == 0)
                	__throw_bad_weak_ptr();
                      ++_M_use_count;
                    }
                
                  template<>
                    inline void
                    _Sp_counted_base<_S_mutex>::
                    _M_add_ref_lock()
                    {
                      __gnu_cxx::__scoped_lock sentry(*this);
                      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
                	{
                	  _M_use_count = 0;
                	  __throw_bad_weak_ptr();
                	}
                    }
                
                  template<> 
                    inline void
                    _Sp_counted_base<_S_atomic>::
                    _M_add_ref_lock()
                    {
                      // Perform lock-free add-if-not-zero operation.
                      _Atomic_word __count = _M_get_use_count();
                      do
                	{
                	  if (__count == 0)
                	    __throw_bad_weak_ptr();
                	  // Replace the current counter value with the old value + 1, as
                	  // long as it's not changed meanwhile. 
                	}
                      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
                					  true, __ATOMIC_ACQ_REL, 
                					  __ATOMIC_RELAXED));
                    }
                
                  template<>
                    inline bool
                    _Sp_counted_base<_S_single>::
                    _M_add_ref_lock_nothrow()
                    {
                      if (_M_use_count == 0)
                	return false;
                      ++_M_use_count;
                      return true;
                    }
                
                  template<>
                    inline bool
                    _Sp_counted_base<_S_mutex>::
                    _M_add_ref_lock_nothrow()
                    {
                      __gnu_cxx::__scoped_lock sentry(*this);
                      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
                	{
                	  _M_use_count = 0;
                	  return false;
                	}
                      return true;
                    }
                
                  template<>
                    inline bool
                    _Sp_counted_base<_S_atomic>::
                    _M_add_ref_lock_nothrow()
                    {
                      // Perform lock-free add-if-not-zero operation.
                      _Atomic_word __count = _M_get_use_count();
                      do
                	{
                	  if (__count == 0)
                	    return false;
                	  // Replace the current counter value with the old value + 1, as
                	  // long as it's not changed meanwhile.
                	}
                      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
                					  true, __ATOMIC_ACQ_REL,
                					  __ATOMIC_RELAXED));
                      return true;
                    }
                
                  template<>
                    inline void
                    _Sp_counted_base<_S_single>::_M_add_ref_copy()
                    { ++_M_use_count; }
                
                  template<>
                    inline void
                    _Sp_counted_base<_S_single>::_M_release() noexcept
                    {
                      if (--_M_use_count == 0)
                        {
                          _M_dispose();
                          if (--_M_weak_count == 0)
                            _M_destroy();
                        }
                    }
                
                  template<>
                    inline void
                    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
                    { ++_M_weak_count; }
                
                  template<>
                    inline void
                    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
                    {
                      if (--_M_weak_count == 0)
                        _M_destroy();
                    }
                
                  template<>
                    inline long
                    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
                    { return _M_use_count; }
                
                
                  // Forward declarations.
                  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
                    class __shared_ptr;
                
                  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
                    class __weak_ptr;
                
                  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
                    class __enable_shared_from_this;
                
                  template<typename _Tp>
                    class shared_ptr;
                
                  template<typename _Tp>
                    class weak_ptr;
                
                  template<typename _Tp>
                    struct owner_less;
                
                  template<typename _Tp>
                    class enable_shared_from_this;
                
                  template<_Lock_policy _Lp = __default_lock_policy>
                    class __weak_count;
                
                  template<_Lock_policy _Lp = __default_lock_policy>
                    class __shared_count;
                
                
                  // Counted ptr with no deleter or allocator support
                  template<typename _Ptr, _Lock_policy _Lp>
                    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
                    {
                    public:
                      explicit
                      _Sp_counted_ptr(_Ptr __p) noexcept
                      : _M_ptr(__p) { }
                
                      virtual void
                      _M_dispose() noexcept
                      { delete _M_ptr; }
                
                      virtual void
                      _M_destroy() noexcept
                      { delete this; }
                
                      virtual void*
                      _M_get_deleter(const std::type_info&) noexcept
                      { return nullptr; }
                
                      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
                      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;
                
                    private:
                      _Ptr             _M_ptr;
                    };
                
                  template<>
                    inline void
                    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }
                
                  template<>
                    inline void
                    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }
                
                  template<>
                    inline void
                    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }
                
                  template<int _Nm, typename _Tp,
                	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
                    struct _Sp_ebo_helper;
                
                  /// Specialization using EBO.
                  template<int _Nm, typename _Tp>
         118 ->     struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
                    {
         389 ->       explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
                
                      static _Tp&
         236 ->       _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
                    };
                
                  /// Specialization not using EBO.
                  template<int _Nm, typename _Tp>
                    struct _Sp_ebo_helper<_Nm, _Tp, false>
                    {
                      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
                
                      static _Tp&
                      _S_get(_Sp_ebo_helper& __eboh)
                      { return __eboh._M_tp; }
                
                    private:
                      _Tp _M_tp;
                    };
                
                  // Support for custom deleter and/or allocator
                  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
                    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
                    {
                      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
                      {
                	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
                	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;
                
                      public:
                	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
                	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
                	{ }
                
                	_Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
                	_Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }
                
                	_Ptr _M_ptr;
                      };
                
                    public:
                      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;
                
                      // __d(__p) must not throw.
                      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
                      : _M_impl(__p, __d, _Alloc()) { }
                
                      // __d(__p) must not throw.
                      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
                      : _M_impl(__p, __d, __a) { }
                
                      ~_Sp_counted_deleter() noexcept { }
                
                      virtual void
                      _M_dispose() noexcept
                      { _M_impl._M_del()(_M_impl._M_ptr); }
                
                      virtual void
                      _M_destroy() noexcept
                      {
                	__allocator_type __a(_M_impl._M_alloc());
                	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
                	this->~_Sp_counted_deleter();
                      }
                
                      virtual void*
                      _M_get_deleter(const std::type_info& __ti) noexcept
                      {
                #if __cpp_rtti
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 2400. shared_ptr's get_deleter() should use addressof()
                        return __ti == typeid(_Deleter)
                	  ? std::__addressof(_M_impl._M_del())
                	  : nullptr;
                #else
                        return nullptr;
                #endif
                      }
                
                    private:
                      _Impl _M_impl;
                    };
                
                  // helpers for make_shared / allocate_shared
                
                  struct _Sp_make_shared_tag { };
                
                  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
                    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
                    {
         119 ->       class _Impl : _Sp_ebo_helper<0, _Alloc>
                      {
                	typedef _Sp_ebo_helper<0, _Alloc>	_A_base;
                
                      public:
         396 -> 	explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }
                
         236 -> 	_Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }
                
                	__gnu_cxx::__aligned_buffer<_Tp> _M_storage;
                      };
                
                    public:
                      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;
                
                      template<typename... _Args>
         396 -> 	_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
                	: _M_impl(__a)
                	{
                	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	  // 2070.  allocate_shared should use allocator_traits<A>::construct
                	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
                	      std::forward<_Args>(__args)...); // might throw
                	}
                
         119 ->       ~_Sp_counted_ptr_inplace() noexcept { }
                
                      virtual void
       ##### ->       _M_dispose() noexcept
                      {
                	allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
                      }
                
                      // Override because the allocator needs to know the dynamic type
                      virtual void
       ##### ->       _M_destroy() noexcept
                      {
                	__allocator_type __a(_M_impl._M_alloc());
                	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
                	this->~_Sp_counted_ptr_inplace();
                      }
                
                      // Sneaky trick so __shared_ptr can get the managed pointer
                      virtual void*
         395 ->       _M_get_deleter(const std::type_info& __ti) noexcept
                      {
                #if __cpp_rtti
                	if (__ti == typeid(_Sp_make_shared_tag))
                	  return const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());
                #endif
                	return nullptr;
                      }
                
                    private:
         905 ->       _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }
                
                      _Impl _M_impl;
                    };
                
                
                  template<_Lock_policy _Lp>
                    class __shared_count
                    {
                    public:
         778 ->       constexpr __shared_count() noexcept : _M_pi(0)
                      { }
                
                      template<typename _Ptr>
                        explicit
                	__shared_count(_Ptr __p) : _M_pi(0)
                	{
                	  __try
                	    {
                	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
                	    }
                	  __catch(...)
                	    {
                	      delete __p;
                	      __throw_exception_again;
                	    }
                	}
                
                      template<typename _Ptr, typename _Deleter>
                	__shared_count(_Ptr __p, _Deleter __d)
                	: __shared_count(__p, std::move(__d), allocator<void>())
                	{ }
                
                      template<typename _Ptr, typename _Deleter, typename _Alloc>
                	__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
                	{
                	  typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
                	  __try
                	    {
                	      typename _Sp_cd_type::__allocator_type __a2(__a);
                	      auto __guard = std::__allocate_guarded(__a2);
                	      _Sp_cd_type* __mem = __guard.get();
                	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
                	      _M_pi = __mem;
                	      __guard = nullptr;
                	    }
                	  __catch(...)
                	    {
                	      __d(__p); // Call _Deleter on __p.
                	      __throw_exception_again;
                	    }
                	}
                
                      template<typename _Tp, typename _Alloc, typename... _Args>
         392 -> 	__shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
                		       _Args&&... __args)
                	: _M_pi(0)
                	{
                	  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
                	  typename _Sp_cp_type::__allocator_type __a2(__a);
                	  auto __guard = std::__allocate_guarded(__a2);
                	  _Sp_cp_type* __mem = __guard.get();
                	  ::new (__mem) _Sp_cp_type(std::move(__a),
                				    std::forward<_Args>(__args)...);
                	  _M_pi = __mem;
                	  __guard = nullptr;
                	}
                
                #if _GLIBCXX_USE_DEPRECATED
                      // Special case for auto_ptr<_Tp> to provide the strong guarantee.
                      template<typename _Tp>
                        explicit
                	__shared_count(std::auto_ptr<_Tp>&& __r);
                #endif
                
                      // Special case for unique_ptr<_Tp,_Del> to provide the strong guarantee.
                      template<typename _Tp, typename _Del>
                        explicit
                	__shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
                	{
                	  using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
                	  using _Del2 = typename conditional<is_reference<_Del>::value,
                	      reference_wrapper<typename remove_reference<_Del>::type>,
                	      _Del>::type;
                	  using _Sp_cd_type
                	    = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
                	  using _Alloc = allocator<_Sp_cd_type>;
                	  using _Alloc_traits = allocator_traits<_Alloc>;
                	  _Alloc __a;
                	  _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
                	  _Alloc_traits::construct(__a, __mem, __r.release(),
                				   __r.get_deleter());  // non-throwing
                	  _M_pi = __mem;
                	}
                
                      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
                      explicit __shared_count(const __weak_count<_Lp>& __r);
                
                      // Does not throw if __r._M_get_use_count() == 0, caller must check.
                      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);
                
         915 ->       ~__shared_count() noexcept
                      {
                	if (_M_pi != nullptr)
                	  _M_pi->_M_release();
                      }
                
          79 ->       __shared_count(const __shared_count& __r) noexcept
                      : _M_pi(__r._M_pi)
                      {
                	if (_M_pi != 0)
                	  _M_pi->_M_add_ref_copy();
                      }
                
                      __shared_count&
          82 ->       operator=(const __shared_count& __r) noexcept
                      {
                	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
                	if (__tmp != _M_pi)
                	  {
                	    if (__tmp != 0)
                	      __tmp->_M_add_ref_copy();
                	    if (_M_pi != 0)
                	      _M_pi->_M_release();
                	    _M_pi = __tmp;
                	  }
                	return *this;
                      }
                
                      void
         391 ->       _M_swap(__shared_count& __r) noexcept
                      {
                	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
                	__r._M_pi = _M_pi;
                	_M_pi = __tmp;
                      }
                
                      long
                      _M_get_use_count() const noexcept
                      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }
                
                      bool
                      _M_unique() const noexcept
                      { return this->_M_get_use_count() == 1; }
                
                      void*
         394 ->       _M_get_deleter(const std::type_info& __ti) const noexcept
                      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }
                
                      bool
                      _M_less(const __shared_count& __rhs) const noexcept
                      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
                
                      bool
                      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
                      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
                
                      // Friend function injected into enclosing namespace and found by ADL
                      friend inline bool
                      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
                      { return __a._M_pi == __b._M_pi; }
                
                    private:
                      friend class __weak_count<_Lp>;
                
                      _Sp_counted_base<_Lp>*  _M_pi;
                    };
                
                
                  template<_Lock_policy _Lp>
                    class __weak_count
                    {
                    public:
                      constexpr __weak_count() noexcept : _M_pi(nullptr)
                      { }
                
                      __weak_count(const __shared_count<_Lp>& __r) noexcept
                      : _M_pi(__r._M_pi)
                      {
                	if (_M_pi != nullptr)
                	  _M_pi->_M_weak_add_ref();
                      }
                
                      __weak_count(const __weak_count& __r) noexcept
                      : _M_pi(__r._M_pi)
                      {
                	if (_M_pi != nullptr)
                	  _M_pi->_M_weak_add_ref();
                      }
                
                      __weak_count(__weak_count&& __r) noexcept
                      : _M_pi(__r._M_pi)
                      { __r._M_pi = nullptr; }
                
                      ~__weak_count() noexcept
                      {
                	if (_M_pi != nullptr)
                	  _M_pi->_M_weak_release();
                      }
                
                      __weak_count&
                      operator=(const __shared_count<_Lp>& __r) noexcept
                      {
                	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
                	if (__tmp != nullptr)
                	  __tmp->_M_weak_add_ref();
                	if (_M_pi != nullptr)
                	  _M_pi->_M_weak_release();
                	_M_pi = __tmp;
                	return *this;
                      }
                
                      __weak_count&
                      operator=(const __weak_count& __r) noexcept
                      {
                	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
                	if (__tmp != nullptr)
                	  __tmp->_M_weak_add_ref();
                	if (_M_pi != nullptr)
                	  _M_pi->_M_weak_release();
                	_M_pi = __tmp;
                	return *this;
                      }
                
                      __weak_count&
                      operator=(__weak_count&& __r) noexcept
                      {
                	if (_M_pi != nullptr)
                	  _M_pi->_M_weak_release();
                	_M_pi = __r._M_pi;
                        __r._M_pi = nullptr;
                	return *this;
                      }
                
                      void
                      _M_swap(__weak_count& __r) noexcept
                      {
                	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
                	__r._M_pi = _M_pi;
                	_M_pi = __tmp;
                      }
                
                      long
                      _M_get_use_count() const noexcept
                      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }
                
                      bool
                      _M_less(const __weak_count& __rhs) const noexcept
                      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
                
                      bool
                      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
                      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
                
                      // Friend function injected into enclosing namespace and found by ADL
                      friend inline bool
                      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
                      { return __a._M_pi == __b._M_pi; }
                
                    private:
                      friend class __shared_count<_Lp>;
                
                      _Sp_counted_base<_Lp>*  _M_pi;
                    };
                
                  // Now that __weak_count is defined we can define this constructor:
                  template<_Lock_policy _Lp>
                    inline
                    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
                    : _M_pi(__r._M_pi)
                    {
                      if (_M_pi != nullptr)
                	_M_pi->_M_add_ref_lock();
                      else
                	__throw_bad_weak_ptr();
                    }
                
                  // Now that __weak_count is defined we can define this constructor:
                  template<_Lock_policy _Lp>
                    inline
                    __shared_count<_Lp>::
                    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
                    : _M_pi(__r._M_pi)
                    {
                      if (_M_pi != nullptr)
                	if (!_M_pi->_M_add_ref_lock_nothrow())
                	  _M_pi = nullptr;
                    }
                
                  // Support for enable_shared_from_this.
                
                  // Friend of __enable_shared_from_this.
                  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>
                    void
                    __enable_shared_from_this_helper(const __shared_count<_Lp>&,
                				     const __enable_shared_from_this<_Tp1,
                				     _Lp>*, const _Tp2*) noexcept;
                
                  // Friend of enable_shared_from_this.
                  template<typename _Tp1, typename _Tp2>
                    void
                    __enable_shared_from_this_helper(const __shared_count<>&,
                				     const enable_shared_from_this<_Tp1>*,
                				     const _Tp2*) noexcept;
                
                  template<_Lock_policy _Lp>
                    inline void
         399 ->     __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
                    { }
                
                
                  template<typename _Tp, _Lock_policy _Lp>
          82 ->     class __shared_ptr
                    {
                      template<typename _Ptr>
                	using _Convertible
                	  = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;
                
                    public:
                      typedef _Tp   element_type;
                
         394 ->       constexpr __shared_ptr() noexcept
                      : _M_ptr(0), _M_refcount()
                      { }
                
                      template<typename _Tp1>
                	explicit __shared_ptr(_Tp1* __p)
                        : _M_ptr(__p), _M_refcount(__p)
                	{
                	  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)
                	  static_assert( !is_void<_Tp1>::value, "incomplete type" );
                	  static_assert( sizeof(_Tp1) > 0, "incomplete type" );
                	  __enable_shared_from_this_helper(_M_refcount, __p, __p);
                	}
                
                      template<typename _Tp1, typename _Deleter>
                	__shared_ptr(_Tp1* __p, _Deleter __d)
                	: _M_ptr(__p), _M_refcount(__p, __d)
                	{
                	  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)
                	  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed
                	  __enable_shared_from_this_helper(_M_refcount, __p, __p);
                	}
                
                      template<typename _Tp1, typename _Deleter, typename _Alloc>
                	__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
                	: _M_ptr(__p), _M_refcount(__p, __d, std::move(__a))
                	{
                	  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)
                	  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed
                	  __enable_shared_from_this_helper(_M_refcount, __p, __p);
                	}
                
                      template<typename _Deleter>
                	__shared_ptr(nullptr_t __p, _Deleter __d)
                	: _M_ptr(0), _M_refcount(__p, __d)
                	{ }
                
                      template<typename _Deleter, typename _Alloc>
                        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
                	: _M_ptr(0), _M_refcount(__p, __d, std::move(__a))
                	{ }
                
                      template<typename _Tp1>
                	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
                	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
                	{ }
                
          81 ->       __shared_ptr(const __shared_ptr&) noexcept = default;
                      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
         922 ->       ~__shared_ptr() = default;
                
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
                	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
                	{ }
                
          80 ->       __shared_ptr(__shared_ptr&& __r) noexcept
                      : _M_ptr(__r._M_ptr), _M_refcount()
                      {
                	_M_refcount._M_swap(__r._M_refcount);
                	__r._M_ptr = 0;
                      }
                
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
         312 -> 	__shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
                	: _M_ptr(__r._M_ptr), _M_refcount()
                	{
                	  _M_refcount._M_swap(__r._M_refcount);
                	  __r._M_ptr = 0;
                	}
                
                      template<typename _Tp1>
                	explicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
                	: _M_refcount(__r._M_refcount) // may throw
                	{
                	  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)
                
                	  // It is now safe to copy __r._M_ptr, as
                	  // _M_refcount(__r._M_refcount) did not throw.
                	  _M_ptr = __r._M_ptr;
                	}
                
                      // If an exception is thrown this constructor has no effect.
                      template<typename _Tp1, typename _Del, typename
                	       = _Convertible<typename unique_ptr<_Tp1, _Del>::pointer>>
                	__shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
                	: _M_ptr(__r.get()), _M_refcount()
                	{
                	  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)
                	  auto __raw = _S_raw_ptr(__r.get());
                	  _M_refcount = __shared_count<_Lp>(std::move(__r));
                	  __enable_shared_from_this_helper(_M_refcount, __raw, __raw);
                	}
                
                #if _GLIBCXX_USE_DEPRECATED
                      // Postcondition: use_count() == 1 and __r.get() == 0
                      template<typename _Tp1>
                	__shared_ptr(std::auto_ptr<_Tp1>&& __r);
                #endif
                
                      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }
                
                      template<typename _Tp1>
                	__shared_ptr&
                	operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
                	{
                	  _M_ptr = __r._M_ptr;
                	  _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw
                	  return *this;
                	}
                
                #if _GLIBCXX_USE_DEPRECATED
                      template<typename _Tp1>
                	__shared_ptr&
                	operator=(std::auto_ptr<_Tp1>&& __r)
                	{
                	  __shared_ptr(std::move(__r)).swap(*this);
                	  return *this;
                	}
                #endif
                
                      __shared_ptr&
                      operator=(__shared_ptr&& __r) noexcept
                      {
                	__shared_ptr(std::move(__r)).swap(*this);
                	return *this;
                      }
                
                      template<class _Tp1>
                	__shared_ptr&
                	operator=(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
                	{
                	  __shared_ptr(std::move(__r)).swap(*this);
                	  return *this;
                	}
                
                      template<typename _Tp1, typename _Del>
                	__shared_ptr&
                	operator=(std::unique_ptr<_Tp1, _Del>&& __r)
                	{
                	  __shared_ptr(std::move(__r)).swap(*this);
                	  return *this;
                	}
                
                      void
                      reset() noexcept
                      { __shared_ptr().swap(*this); }
                
                      template<typename _Tp1>
                	void
                	reset(_Tp1* __p) // _Tp1 must be complete.
                	{
                	  // Catch self-reset errors.
                	  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr);
                	  __shared_ptr(__p).swap(*this);
                	}
                
                      template<typename _Tp1, typename _Deleter>
                	void
                	reset(_Tp1* __p, _Deleter __d)
                	{ __shared_ptr(__p, __d).swap(*this); }
                
                      template<typename _Tp1, typename _Deleter, typename _Alloc>
                	void
                        reset(_Tp1* __p, _Deleter __d, _Alloc __a)
                        { __shared_ptr(__p, __d, std::move(__a)).swap(*this); }
                
                      // Allow class instantiation when _Tp is [cv-qual] void.
                      typename std::add_lvalue_reference<_Tp>::type
       22686 ->       operator*() const noexcept
                      {
                	_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);
                	return *_M_ptr;
                      }
                
                      _Tp*
          82 ->       operator->() const noexcept
                      {
                	_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);
                	return _M_ptr;
                      }
                
                      _Tp*
       ##### ->       get() const noexcept
                      { return _M_ptr; }
                
                      explicit operator bool() const // never throws
                      { return _M_ptr == 0 ? false : true; }
                
                      bool
                      unique() const noexcept
                      { return _M_refcount._M_unique(); }
                
                      long
                      use_count() const noexcept
                      { return _M_refcount._M_get_use_count(); }
                
                      void
       ##### ->       swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
                      {
                	std::swap(_M_ptr, __other._M_ptr);
                	_M_refcount._M_swap(__other._M_refcount);
                      }
                
                      template<typename _Tp1>
                	bool
                	owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const
                	{ return _M_refcount._M_less(__rhs._M_refcount); }
                
                      template<typename _Tp1>
                	bool
                	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const
                	{ return _M_refcount._M_less(__rhs._M_refcount); }
                
                #if __cpp_rtti
                    protected:
                      // This constructor is non-standard, it is used by allocate_shared.
                      template<typename _Alloc, typename... _Args>
         391 -> 	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
                		     _Args&&... __args)
                	: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
                				std::forward<_Args>(__args)...)
                	{
                	  // _M_ptr needs to point to the newly constructed object.
                	  // This relies on _Sp_counted_ptr_inplace::_M_get_deleter.
                	  void* __p = _M_refcount._M_get_deleter(typeid(__tag));
                	  _M_ptr = static_cast<_Tp*>(__p);
                	  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);
                	}
                #else
                      template<typename _Alloc>
                        struct _Deleter
                        {
                          void operator()(typename _Alloc::value_type* __ptr)
                          {
                	    __allocated_ptr<_Alloc> __guard{ _M_alloc, __ptr };
                	    allocator_traits<_Alloc>::destroy(_M_alloc, __guard.get());
                          }
                          _Alloc _M_alloc;
                        };
                
                      template<typename _Alloc, typename... _Args>
                	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
                		     _Args&&... __args)
                	: _M_ptr(), _M_refcount()
                	{
                	  typedef typename allocator_traits<_Alloc>::template
                	    rebind_traits<typename std::remove_cv<_Tp>::type> __traits;
                	  _Deleter<typename __traits::allocator_type> __del = { __a };
                	  auto __guard = std::__allocate_guarded(__del._M_alloc);
                	  auto __ptr = __guard.get();
                	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	  // 2070. allocate_shared should use allocator_traits<A>::construct
                	  __traits::construct(__del._M_alloc, __ptr,
                			      std::forward<_Args>(__args)...);
                	  __guard = nullptr;
                	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
                	  _M_refcount._M_swap(__count);
                	  _M_ptr = __ptr;
                	  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);
                	}
                #endif
                
                      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
                	       typename... _Args>
                	friend __shared_ptr<_Tp1, _Lp1>
                	__allocate_shared(const _Alloc& __a, _Args&&... __args);
                
                      // This constructor is used by __weak_ptr::lock() and
                      // shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).
                      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
                      : _M_refcount(__r._M_refcount, std::nothrow)
                      {
                	_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
                      }
                
                      friend class __weak_ptr<_Tp, _Lp>;
                
                    private:
                      void*
                      _M_get_deleter(const std::type_info& __ti) const noexcept
                      { return _M_refcount._M_get_deleter(__ti); }
                
                      template<typename _Tp1>
                	static _Tp1*
                	_S_raw_ptr(_Tp1* __ptr)
                	{ return __ptr; }
                
                      template<typename _Tp1>
                	static auto
                	_S_raw_ptr(_Tp1 __ptr) -> decltype(std::__addressof(*__ptr))
                	{ return std::__addressof(*__ptr); }
                
                      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
                      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
                
                      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
                	friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;
                
                      _Tp*	   	   _M_ptr;         // Contained pointer.
                      __shared_count<_Lp>  _M_refcount;    // Reference counter.
                    };
                
                
                  // 20.7.2.2.7 shared_ptr comparisons
                  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
                    inline bool
                    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
                	       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
                    { return __a.get() == __b.get(); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
                    { return !__a; }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
                    { return !__a; }
                
                  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
                    inline bool
                    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
                	       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
                    { return __a.get() != __b.get(); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
                    { return (bool)__a; }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
                    { return (bool)__a; }
                
                  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
                    inline bool
                    operator<(const __shared_ptr<_Tp1, _Lp>& __a,
                	      const __shared_ptr<_Tp2, _Lp>& __b) noexcept
                    {
                      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
                      return std::less<_CT>()(__a.get(), __b.get());
                    }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
                    { return std::less<_Tp*>()(__a.get(), nullptr); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
                    { return std::less<_Tp*>()(nullptr, __a.get()); }
                
                  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
                    inline bool
                    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
                	       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
                    { return !(__b < __a); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
                    { return !(nullptr < __a); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
                    { return !(__a < nullptr); }
                
                  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
                    inline bool
                    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
                	      const __shared_ptr<_Tp2, _Lp>& __b) noexcept
                    { return (__b < __a); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
                    { return std::less<_Tp*>()(nullptr, __a.get()); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
                    { return std::less<_Tp*>()(__a.get(), nullptr); }
                
                  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
                    inline bool
                    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
                	       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
                    { return !(__a < __b); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
                    { return !(__a < nullptr); }
                
                  template<typename _Tp, _Lock_policy _Lp>
                    inline bool
                    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
                    { return !(nullptr < __a); }
                
                  template<typename _Sp>
                    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
                    {
                      bool
                      operator()(const _Sp& __lhs, const _Sp& __rhs) const noexcept
                      {
                	typedef typename _Sp::element_type element_type;
                	return std::less<element_type*>()(__lhs.get(), __rhs.get());
                      }
                    };
                
                  template<typename _Tp, _Lock_policy _Lp>
                    struct less<__shared_ptr<_Tp, _Lp>>
                    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
                    { };
                
                  // 20.7.2.2.8 shared_ptr specialized algorithms.
                  template<typename _Tp, _Lock_policy _Lp>
                    inline void
                    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
                    { __a.swap(__b); }
                
                  // 20.7.2.2.9 shared_ptr casts
                
                  // The seemingly equivalent code:
                  // shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))
                  // will eventually result in undefined behaviour, attempting to
                  // delete the same object twice.
                  /// static_pointer_cast
                  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
                    inline __shared_ptr<_Tp, _Lp>
                    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
                    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }
                
                  // The seemingly equivalent code:
                  // shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))
                  // will eventually result in undefined behaviour, attempting to
                  // delete the same object twice.
                  /// const_pointer_cast
                  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
                    inline __shared_ptr<_Tp, _Lp>
                    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
                    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }
                
                  // The seemingly equivalent code:
                  // shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))
                  // will eventually result in undefined behaviour, attempting to
                  // delete the same object twice.
                  /// dynamic_pointer_cast
                  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
                    inline __shared_ptr<_Tp, _Lp>
                    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
                    {
                      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
                	return __shared_ptr<_Tp, _Lp>(__r, __p);
                      return __shared_ptr<_Tp, _Lp>();
                    }
                
                
                  template<typename _Tp, _Lock_policy _Lp>
                    class __weak_ptr
                    {
                      template<typename _Ptr>
                	using _Convertible
                	  = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;
                
                    public:
                      typedef _Tp element_type;
                
                      constexpr __weak_ptr() noexcept
                      : _M_ptr(nullptr), _M_refcount()
                      { }
                
                      __weak_ptr(const __weak_ptr&) noexcept = default;
                
                      ~__weak_ptr() = default;
                
                      // The "obvious" converting constructor implementation:
                      //
                      //  template<typename _Tp1>
                      //    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
                      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws
                      //    { }
                      //
                      // has a serious problem.
                      //
                      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)
                      //  conversion may require access to *__r._M_ptr (virtual inheritance).
                      //
                      // It is not possible to avoid spurious access violations since
                      // in multithreaded programs __r._M_ptr may be invalidated at any point.
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	__weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
                	: _M_refcount(__r._M_refcount)
                        { _M_ptr = __r.lock().get(); }
                
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	__weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
                	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
                	{ }
                
                      __weak_ptr(__weak_ptr&& __r) noexcept
                      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
                      { __r._M_ptr = nullptr; }
                
                      template<typename _Tp1, typename = _Convertible<_Tp1*>>
                	__weak_ptr(__weak_ptr<_Tp1, _Lp>&& __r) noexcept
                	: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
                        { __r._M_ptr = nullptr; }
                
                      __weak_ptr&
                      operator=(const __weak_ptr& __r) noexcept = default;
                
                      template<typename _Tp1>
                	__weak_ptr&
                	operator=(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
                	{
                	  _M_ptr = __r.lock().get();
                	  _M_refcount = __r._M_refcount;
                	  return *this;
                	}
                
                      template<typename _Tp1>
                	__weak_ptr&
                	operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
                	{
                	  _M_ptr = __r._M_ptr;
                	  _M_refcount = __r._M_refcount;
                	  return *this;
                	}
                
                      __weak_ptr&
                      operator=(__weak_ptr&& __r) noexcept
                      {
                	_M_ptr = __r._M_ptr;
                	_M_refcount = std::move(__r._M_refcount);
                	__r._M_ptr = nullptr;
                	return *this;
                      }
                
                      template<typename _Tp1>
                	__weak_ptr&
                	operator=(__weak_ptr<_Tp1, _Lp>&& __r) noexcept
                	{
                	  _M_ptr = __r.lock().get();
                	  _M_refcount = std::move(__r._M_refcount);
                	  __r._M_ptr = nullptr;
                	  return *this;
                	}
                
                      __shared_ptr<_Tp, _Lp>
                      lock() const noexcept
                      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }
                
                      long
                      use_count() const noexcept
                      { return _M_refcount._M_get_use_count(); }
                
                      bool
                      expired() const noexcept
                      { return _M_refcount._M_get_use_count() == 0; }
                
                      template<typename _Tp1>
                	bool
                	owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const
                	{ return _M_refcount._M_less(__rhs._M_refcount); }
                
                      template<typename _Tp1>
                	bool
                	owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const
                	{ return _M_refcount._M_less(__rhs._M_refcount); }
                
                      void
                      reset() noexcept
                      { __weak_ptr().swap(*this); }
                
                      void
                      swap(__weak_ptr& __s) noexcept
                      {
                	std::swap(_M_ptr, __s._M_ptr);
                	_M_refcount._M_swap(__s._M_refcount);
                      }
                
                    private:
                      // Used by __enable_shared_from_this.
                      void
                      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
                      {
                	_M_ptr = __ptr;
                	_M_refcount = __refcount;
                      }
                
                      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
                      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
                      friend class __enable_shared_from_this<_Tp, _Lp>;
                      friend class enable_shared_from_this<_Tp>;
                
                      _Tp*	 	 _M_ptr;         // Contained pointer.
                      __weak_count<_Lp>  _M_refcount;    // Reference counter.
                    };
                
                  // 20.7.2.3.6 weak_ptr specialized algorithms.
                  template<typename _Tp, _Lock_policy _Lp>
                    inline void
                    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
                    { __a.swap(__b); }
                
                  template<typename _Tp, typename _Tp1>
                    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __lhs, const _Tp& __rhs) const
                      { return __lhs.owner_before(__rhs); }
                
                      bool
                      operator()(const _Tp& __lhs, const _Tp1& __rhs) const
                      { return __lhs.owner_before(__rhs); }
                
                      bool
                      operator()(const _Tp1& __lhs, const _Tp& __rhs) const
                      { return __lhs.owner_before(__rhs); }
                    };
                
                  template<typename _Tp, _Lock_policy _Lp>
                    struct owner_less<__shared_ptr<_Tp, _Lp>>
                    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
                    { };
                
                  template<typename _Tp, _Lock_policy _Lp>
                    struct owner_less<__weak_ptr<_Tp, _Lp>>
                    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
                    { };
                
                
                  template<typename _Tp, _Lock_policy _Lp>
                    class __enable_shared_from_this
                    {
                    protected:
                      constexpr __enable_shared_from_this() noexcept { }
                
                      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }
                
                      __enable_shared_from_this&
                      operator=(const __enable_shared_from_this&) noexcept
                      { return *this; }
                
                      ~__enable_shared_from_this() { }
                
                    public:
                      __shared_ptr<_Tp, _Lp>
                      shared_from_this()
                      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }
                
                      __shared_ptr<const _Tp, _Lp>
                      shared_from_this() const
                      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }
                
                    private:
                      template<typename _Tp1>
                	void
                	_M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
                	{ _M_weak_this._M_assign(__p, __n); }
                
                      template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
                	friend void
                	__enable_shared_from_this_helper(const __shared_count<_Lp1>&,
                					 const __enable_shared_from_this<_Tp1,
                					 _Lp1>*, const _Tp2*) noexcept;
                
                      mutable __weak_ptr<_Tp, _Lp>  _M_weak_this;
                    };
                
                  template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
                    inline void
                    __enable_shared_from_this_helper(const __shared_count<_Lp1>& __pn,
                				     const __enable_shared_from_this<_Tp1,
                				     _Lp1>* __pe,
                				     const _Tp2* __px) noexcept
                    {
                      if (__pe != nullptr)
                	__pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
                    }
                
                  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
                    inline __shared_ptr<_Tp, _Lp>
                    __allocate_shared(const _Alloc& __a, _Args&&... __args)
                    {
                      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(), __a,
                				    std::forward<_Args>(__args)...);
                    }
                
                  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
                    inline __shared_ptr<_Tp, _Lp>
                    __make_shared(_Args&&... __args)
                    {
                      typedef typename std::remove_const<_Tp>::type _Tp_nc;
                      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
                					      std::forward<_Args>(__args)...);
                    }
                
                  /// std::hash specialization for __shared_ptr.
                  template<typename _Tp, _Lock_policy _Lp>
                    struct hash<__shared_ptr<_Tp, _Lp>>
                    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
                    {
                      size_t
                      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
                      { return std::hash<_Tp*>()(__s.get()); }
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif // _SHARED_PTR_BASE_H


Top 10 Lines:

     Line      Count

     1045      22686
      925        922
      656        915
      555        905
      565        778
      862        399
      112        397
      506        396
      517        396
       89        395

Execution Summary:

       37   Executable lines in this file
       37   Lines executed
   100.00   Percent of the file executed

    32919   Total number of line executions
   889.70   Average executions per line


*** File /usr/include/c++/5/bits/stl_tree.h:
                // RB tree implementation -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 */
                
                /** @file bits/stl_tree.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{map,set}
                 */
                
                #ifndef _STL_TREE_H
                #define _STL_TREE_H 1
                
                #pragma GCC system_header
                
                #include <bits/stl_algobase.h>
                #include <bits/allocator.h>
                #include <bits/stl_function.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/alloc_traits.h>
                #if __cplusplus >= 201103L
                #include <ext/aligned_buffer.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Red-black tree class, designed for use in implementing STL
                  // associative containers (set, multiset, map, and multimap). The
                  // insertion and deletion algorithms are based on those in Cormen,
                  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
                  // 1990), except that
                  //
                  // (1) the header cell is maintained with links not only to the root
                  // but also to the leftmost node of the tree, to enable constant
                  // time begin(), and to the rightmost node of the tree, to enable
                  // linear time performance when used with the generic set algorithms
                  // (set_union, etc.)
                  // 
                  // (2) when a node being deleted has two children its successor node
                  // is relinked into its place, rather than copied, so that the only
                  // iterators invalidated are those referring to the deleted node.
                
                  enum _Rb_tree_color { _S_red = false, _S_black = true };
                
         224 ->   struct _Rb_tree_node_base
                  {
                    typedef _Rb_tree_node_base* _Base_ptr;
                    typedef const _Rb_tree_node_base* _Const_Base_ptr;
                
                    _Rb_tree_color	_M_color;
                    _Base_ptr		_M_parent;
                    _Base_ptr		_M_left;
                    _Base_ptr		_M_right;
                
                    static _Base_ptr
                    _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Base_ptr
                    _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                  };
                
                  template<typename _Val>
         225 ->     struct _Rb_tree_node : public _Rb_tree_node_base
                    {
                      typedef _Rb_tree_node<_Val>* _Link_type;
                
                #if __cplusplus < 201103L
                      _Val _M_value_field;
                
                      _Val*
                      _M_valptr()
                      { return std::__addressof(_M_value_field); }
                
                      const _Val*
                      _M_valptr() const
                      { return std::__addressof(_M_value_field); }
                #else
                      __gnu_cxx::__aligned_membuf<_Val> _M_storage;
                
                      _Val*
       26967 ->       _M_valptr()
                      { return _M_storage._M_ptr(); }
                
                      const _Val*
       59583 ->       _M_valptr() const
                      { return _M_storage._M_ptr(); }
                #endif
                    };
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
                
                  template<typename _Tp>
                    struct _Rb_tree_iterator
                    {
                      typedef _Tp  value_type;
                      typedef _Tp& reference;
                      typedef _Tp* pointer;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
                      typedef _Rb_tree_node<_Tp>*           _Link_type;
                
                      _Rb_tree_iterator() _GLIBCXX_NOEXCEPT
                      : _M_node() { }
                
                      explicit
       37141 ->       _Rb_tree_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      : _M_node(__x) { }
                
                      reference
       11755 ->       operator*() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      pointer
       14863 ->       operator->() const _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }
                
                      _Self&
         492 ->       operator++() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
       ##### ->       operator++(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
       ##### ->       operator--() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
       18061 ->       operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node == __x._M_node; }
                
                      bool
        4100 ->       operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                  };
                
                  template<typename _Tp>
                    struct _Rb_tree_const_iterator
                    {
                      typedef _Tp        value_type;
                      typedef const _Tp& reference;
                      typedef const _Tp* pointer;
                
                      typedef _Rb_tree_iterator<_Tp> iterator;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_const_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
                      typedef const _Rb_tree_node<_Tp>*           _Link_type;
                
                      _Rb_tree_const_iterator() _GLIBCXX_NOEXCEPT
                      : _M_node() { }
                
                      explicit
                      _Rb_tree_const_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      : _M_node(__x) { }
                
         134 ->       _Rb_tree_const_iterator(const iterator& __it) _GLIBCXX_NOEXCEPT
                      : _M_node(__it._M_node) { }
                
                      iterator
         181 ->       _M_const_cast() const _GLIBCXX_NOEXCEPT
                      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }
                
                      reference
                      operator*() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }
                
                      _Self&
                      operator++() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
                      operator--() _GLIBCXX_NOEXCEPT
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                    };
                
                  template<typename _Val>
                    inline bool
                    operator==(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
                    { return __x._M_node == __y._M_node; }
                
                  template<typename _Val>
                    inline bool
                    operator!=(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
                    { return __x._M_node != __y._M_node; }
                
                  void
                  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                                _Rb_tree_node_base* __x,
                                                _Rb_tree_node_base* __p,
                                                _Rb_tree_node_base& __header) throw ();
                
                  _Rb_tree_node_base*
                  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
                			       _Rb_tree_node_base& __header) throw ();
                
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc = allocator<_Val> >
                    class _Rb_tree
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                        rebind<_Rb_tree_node<_Val> >::other _Node_allocator;
                
                      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;
                
                    protected:
                      typedef _Rb_tree_node_base* 		_Base_ptr;
                      typedef const _Rb_tree_node_base* 	_Const_Base_ptr;
                      typedef _Rb_tree_node<_Val>* 		_Link_type;
                      typedef const _Rb_tree_node<_Val>*	_Const_Link_type;
                
                    private:
                      // Functor recycling a pool of nodes and using allocation once the pool
                      // is empty.
                      struct _Reuse_or_alloc_node
                      {
                	_Reuse_or_alloc_node(_Rb_tree& __t)
                	  : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
                	{
                	  if (_M_root)
                	    {
                	      _M_root->_M_parent = 0;
                
                	      if (_M_nodes->_M_left)
                		_M_nodes = _M_nodes->_M_left;
                	    }
                	  else
                	    _M_nodes = 0;
                	}
                
                #if __cplusplus >= 201103L
                	_Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;
                #endif
                
                	~_Reuse_or_alloc_node()
                	{ _M_t._M_erase(static_cast<_Link_type>(_M_root)); }
                
                	template<typename _Arg>
                	  _Link_type
                #if __cplusplus < 201103L
                	  operator()(const _Arg& __arg)
                #else
                	  operator()(_Arg&& __arg)
                #endif
                	  {
                	    _Link_type __node = static_cast<_Link_type>(_M_extract());
                	    if (__node)
                	      {
                		_M_t._M_destroy_node(__node);
                		_M_t._M_construct_node(__node, _GLIBCXX_FORWARD(_Arg, __arg));
                		return __node;
                	      }
                
                	    return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg));
                	  }
                
                      private:
                	_Base_ptr
                	_M_extract()
                	{
                	  if (!_M_nodes)
                	    return _M_nodes;
                
                	  _Base_ptr __node = _M_nodes;
                	  _M_nodes = _M_nodes->_M_parent;
                	  if (_M_nodes)
                	    {
                	      if (_M_nodes->_M_right == __node)
                		{
                		  _M_nodes->_M_right = 0;
                
                		  if (_M_nodes->_M_left)
                		    {
                		      _M_nodes = _M_nodes->_M_left;
                
                		      while (_M_nodes->_M_right)
                			_M_nodes = _M_nodes->_M_right;
                
                		      if (_M_nodes->_M_left)
                			_M_nodes = _M_nodes->_M_left;
                		    }
                		}
                	      else // __node is on the left.
                		_M_nodes->_M_left = 0;
                	    }
                	  else
                	    _M_root = 0;
                
                	  return __node;
                	}
                
                	_Base_ptr _M_root;
                	_Base_ptr _M_nodes;
                	_Rb_tree& _M_t;
                      };
                
                      // Functor similar to the previous one but without any pool of nodes to
                      // recycle.
                      struct _Alloc_node
                      {
                	_Alloc_node(_Rb_tree& __t)
                	  : _M_t(__t) { }
                
                	template<typename _Arg>
                	  _Link_type
                #if __cplusplus < 201103L
                	  operator()(const _Arg& __arg) const
                #else
                	  operator()(_Arg&& __arg) const
                #endif
                	  { return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg)); }
                
                      private:
                	_Rb_tree& _M_t;
                      };
                
                    public:
                      typedef _Key 				key_type;
                      typedef _Val 				value_type;
                      typedef value_type* 			pointer;
                      typedef const value_type* 		const_pointer;
                      typedef value_type& 			reference;
                      typedef const value_type& 		const_reference;
                      typedef size_t 				size_type;
                      typedef ptrdiff_t 			difference_type;
                      typedef _Alloc 				allocator_type;
                
                      _Node_allocator&
         671 ->       _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Node_allocator*>(&this->_M_impl); }
                      
                      const _Node_allocator&
                      _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Node_allocator()); }
                
                    protected:
                      _Link_type
         219 ->       _M_get_node()
                      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }
                
                      void
         110 ->       _M_put_node(_Link_type __p) _GLIBCXX_NOEXCEPT
                      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
                
                #if __cplusplus < 201103L
                      void
                      _M_construct_node(_Link_type __node, const value_type& __x)
                      {
                	__try
                	  { get_allocator().construct(__node->_M_valptr(), __x); }
                	__catch(...)
                	  {
                	    _M_put_node(__node);
                	    __throw_exception_again;
                	  }
                      }
                
                      _Link_type
                      _M_create_node(const value_type& __x)
                      {
                	_Link_type __tmp = _M_get_node();
                	_M_construct_node(__tmp, __x);
                	return __tmp;
                      }
                
                      void
                      _M_destroy_node(_Link_type __p)
                      { get_allocator().destroy(__p->_M_valptr()); }
                #else
                      template<typename... _Args>
                	void
         214 -> 	_M_construct_node(_Link_type __node, _Args&&... __args)
                	{
                	  __try
                	    {
                	      ::new(__node) _Rb_tree_node<_Val>;
                	      _Alloc_traits::construct(_M_get_Node_allocator(),
                				       __node->_M_valptr(),
                				       std::forward<_Args>(__args)...);
                	    }
                	  __catch(...)
                	    {
                	      __node->~_Rb_tree_node<_Val>();
                	      _M_put_node(__node);
                	      __throw_exception_again;
                	    }
                	}
                
                      template<typename... _Args>
                        _Link_type
         222 ->         _M_create_node(_Args&&... __args)
                	{
                	  _Link_type __tmp = _M_get_node();
                	  _M_construct_node(__tmp, std::forward<_Args>(__args)...);
                	  return __tmp;
                	}
                
                      void
         110 ->       _M_destroy_node(_Link_type __p) noexcept
                      {
                	_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
                	__p->~_Rb_tree_node<_Val>();
                      }
                #endif
                
                      void
         110 ->       _M_drop_node(_Link_type __p) _GLIBCXX_NOEXCEPT
                      {
                	_M_destroy_node(__p);
                	_M_put_node(__p);
                      }
                
                      template<typename _NodeGen>
                	_Link_type
                	_M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
                	{
                	  _Link_type __tmp = __node_gen(*__x->_M_valptr());
                	  __tmp->_M_color = __x->_M_color;
                	  __tmp->_M_left = 0;
                	  __tmp->_M_right = 0;
                	  return __tmp;
                	}
                
                    protected:
                      // Unused _Is_pod_comparator is kept as it is part of mangled name.
                      template<typename _Key_compare,
                	       bool /* _Is_pod_comparator */ = __is_pod(_Key_compare)>
          11 ->         struct _Rb_tree_impl : public _Node_allocator
                        {
                	  _Key_compare		_M_key_compare;
                	  _Rb_tree_node_base 	_M_header;
                	  size_type 		_M_node_count; // Keeps track of size of tree.
                
         109 -> 	  _Rb_tree_impl()
                	  : _Node_allocator(), _M_key_compare(), _M_header(),
                	    _M_node_count(0)
                	  { _M_initialize(); }
                
                	  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
                	  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
                	    _M_node_count(0)
                	  { _M_initialize(); }
                
                #if __cplusplus >= 201103L
                	  _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
                	  : _Node_allocator(std::move(__a)), _M_key_compare(__comp),
                	    _M_header(), _M_node_count(0)
                	  { _M_initialize(); }
                #endif
                
                	  void
                	  _M_reset()
                	  {
                	    this->_M_header._M_parent = 0;
                	    this->_M_header._M_left = &this->_M_header;
                	    this->_M_header._M_right = &this->_M_header;
                	    this->_M_node_count = 0;
                	  }
                
                	private:
                	  void
         110 -> 	  _M_initialize()
                	  {
                	    this->_M_header._M_color = _S_red;
                	    this->_M_header._M_parent = 0;
                	    this->_M_header._M_left = &this->_M_header;
                	    this->_M_header._M_right = &this->_M_header;
                	  }	    
                	};
                
                      _Rb_tree_impl<_Compare> _M_impl;
                
                    protected:
                      _Base_ptr&
                      _M_root() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Const_Base_ptr
                      _M_root() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Base_ptr&
       ##### ->       _M_leftmost() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_left; }
                
                      _Const_Base_ptr
                      _M_leftmost() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_left; }
                
                      _Base_ptr&
         223 ->       _M_rightmost() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_right; }
                
                      _Const_Base_ptr
                      _M_rightmost() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_header._M_right; }
                
                      _Link_type
       13948 ->       _M_begin() _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
                
                      _Const_Link_type
                      _M_begin() const _GLIBCXX_NOEXCEPT
                      {
                	return static_cast<_Const_Link_type>
                	  (this->_M_impl._M_header._M_parent);
                      }
                
                      _Link_type
       14520 ->       _M_end() _GLIBCXX_NOEXCEPT
                      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }
                
                      _Const_Link_type
                      _M_end() const _GLIBCXX_NOEXCEPT
                      { return reinterpret_cast<_Const_Link_type>(&this->_M_impl._M_header); }
                
                      static const_reference
       51671 ->       _S_value(_Const_Link_type __x)
                      { return *__x->_M_valptr(); }
                
                      static const _Key&
       52335 ->       _S_key(_Const_Link_type __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Link_type
       20384 ->       _S_left(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(__x->_M_left); }
                
                      static _Const_Link_type
                      _S_left(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Const_Link_type>(__x->_M_left); }
                
                      static _Link_type
       30641 ->       _S_right(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Link_type>(__x->_M_right); }
                
                      static _Const_Link_type
                      _S_right(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return static_cast<_Const_Link_type>(__x->_M_right); }
                
                      static const_reference
        8011 ->       _S_value(_Const_Base_ptr __x)
                      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }
                
                      static const _Key&
        7989 ->       _S_key(_Const_Base_ptr __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Base_ptr
                      _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Const_Base_ptr
                      _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Base_ptr
                      _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                      static _Const_Base_ptr
                      _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                    public:
                      typedef _Rb_tree_iterator<value_type>       iterator;
                      typedef _Rb_tree_const_iterator<value_type> const_iterator;
                
                      typedef std::reverse_iterator<iterator>       reverse_iterator;
                      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                
                    private:
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_unique_pos(const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_equal_pos(const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_hint_unique_pos(const_iterator __pos,
                				    const key_type& __k);
                
                      pair<_Base_ptr, _Base_ptr>
                      _M_get_insert_hint_equal_pos(const_iterator __pos,
                				   const key_type& __k);
                
                #if __cplusplus >= 201103L
                      template<typename _Arg, typename _NodeGen>
                        iterator
                	_M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);
                
                      iterator
                      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_lower(_Base_ptr __y, _Arg&& __v);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_equal_lower(_Arg&& __x);
                
                      iterator
                      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);
                
                      iterator
                      _M_insert_equal_lower_node(_Link_type __z);
                #else
                      template<typename _NodeGen>
                	iterator
                	_M_insert_(_Base_ptr __x, _Base_ptr __y,
                		   const value_type& __v, _NodeGen&);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 233. Insertion hints in associative containers.
                      iterator
                      _M_insert_lower(_Base_ptr __y, const value_type& __v);
                
                      iterator
                      _M_insert_equal_lower(const value_type& __x);
                #endif
                
                      template<typename _NodeGen>
                	_Link_type
                	_M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen&);
                
                      _Link_type
                      _M_copy(_Const_Link_type __x, _Link_type __p)
                      {
                	_Alloc_node __an(*this);
                	return _M_copy(__x, __p, __an);
                      }
                
                      void
                      _M_erase(_Link_type __x);
                
                      iterator
                      _M_lower_bound(_Link_type __x, _Link_type __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                		     const _Key& __k) const;
                
                      iterator
                      _M_upper_bound(_Link_type __x, _Link_type __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                		     const _Key& __k) const;
                
                    public:
                      // allocation/deallocation
         107 ->       _Rb_tree() { }
                
                      _Rb_tree(const _Compare& __comp,
                	       const allocator_type& __a = allocator_type())
                      : _M_impl(__comp, _Node_allocator(__a)) { }
                
                      _Rb_tree(const _Rb_tree& __x)
                      : _M_impl(__x._M_impl._M_key_compare,
                	        _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator()))
                      {
                	if (__x._M_root() != 0)
                	  {
                	    _M_root() = _M_copy(__x._M_begin(), _M_end());
                	    _M_leftmost() = _S_minimum(_M_root());
                	    _M_rightmost() = _S_maximum(_M_root());
                	    _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  }
                      }
                
                #if __cplusplus >= 201103L
                      _Rb_tree(const allocator_type& __a)
                      : _M_impl(_Compare(), _Node_allocator(__a))
                      { }
                
                      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
                      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
                      {
                	if (__x._M_root() != nullptr)
                	  {
                	    _M_root() = _M_copy(__x._M_begin(), _M_end());
                	    _M_leftmost() = _S_minimum(_M_root());
                	    _M_rightmost() = _S_maximum(_M_root());
                	    _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  }
                      }
                
                      _Rb_tree(_Rb_tree&& __x)
                      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
                      {
                	if (__x._M_root() != 0)
                	  _M_move_data(__x, std::true_type());
                      }
                
                      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
                      : _Rb_tree(std::move(__x), _Node_allocator(__a))
                      { }
                
                      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);
                #endif
                
          11 ->       ~_Rb_tree() _GLIBCXX_NOEXCEPT
                      { _M_erase(_M_begin()); }
                
                      _Rb_tree&
                      operator=(const _Rb_tree& __x);
                
                      // Accessors.
                      _Compare
        5544 ->       key_comp() const
                      { return _M_impl._M_key_compare; }
                
                      iterator
         190 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_header._M_left); }
                
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_header._M_left); }
                
                      iterator
       21942 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(&this->_M_impl._M_header); }
                
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(&this->_M_impl._M_header); }
                
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return _M_impl._M_node_count == 0; }
                
                      size_type
         194 ->       size() const _GLIBCXX_NOEXCEPT 
                      { return _M_impl._M_node_count; }
                
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }
                
                      void
                #if __cplusplus >= 201103L
                      swap(_Rb_tree& __t) noexcept(_Alloc_traits::_S_nothrow_swap());
                #else
                      swap(_Rb_tree& __t);
                #endif
                
                      // Insert/erase.
                #if __cplusplus >= 201103L
                      template<typename _Arg>
                        pair<iterator, bool>
                        _M_insert_unique(_Arg&& __x);
                
                      template<typename _Arg>
                        iterator
                        _M_insert_equal(_Arg&& __x);
                
                      template<typename _Arg, typename _NodeGen>
                        iterator
                	_M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);
                
                      template<typename _Arg>
                	iterator
                	_M_insert_unique_(const_iterator __pos, _Arg&& __x)
                	{
                	  _Alloc_node __an(*this);
                	  return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
                	}
                
                      template<typename _Arg, typename _NodeGen>
                	iterator
                	_M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);
                
                      template<typename _Arg>
                	iterator
                	_M_insert_equal_(const_iterator __pos, _Arg&& __x)
                	{
                	  _Alloc_node __an(*this);
                	  return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
                	}
                
                      template<typename... _Args>
                	pair<iterator, bool>
                	_M_emplace_unique(_Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_equal(_Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
                #else
                      pair<iterator, bool>
                      _M_insert_unique(const value_type& __x);
                
                      iterator
                      _M_insert_equal(const value_type& __x);
                
                      template<typename _NodeGen>
                	iterator
                	_M_insert_unique_(const_iterator __pos, const value_type& __x,
                			  _NodeGen&);
                
                      iterator
                      _M_insert_unique_(const_iterator __pos, const value_type& __x)
                      {
                	_Alloc_node __an(*this);
                	return _M_insert_unique_(__pos, __x, __an);
                      }
                
                      template<typename _NodeGen>
                	iterator
                	_M_insert_equal_(const_iterator __pos, const value_type& __x,
                			 _NodeGen&);
                      iterator
                      _M_insert_equal_(const_iterator __pos, const value_type& __x)
                      {
                	_Alloc_node __an(*this);
                	return _M_insert_equal_(__pos, __x, __an);
                      }
                #endif
                
                      template<typename _InputIterator>
                        void
                        _M_insert_unique(_InputIterator __first, _InputIterator __last);
                
                      template<typename _InputIterator>
                        void
                        _M_insert_equal(_InputIterator __first, _InputIterator __last);
                
                    private:
                      void
                      _M_erase_aux(const_iterator __position);
                
                      void
                      _M_erase_aux(const_iterator __first, const_iterator __last);
                
                    public:
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __position)
                      {
                	const_iterator __result = __position;
                	++__result;
                	_M_erase_aux(__position);
                	return __result._M_const_cast();
                      }
                
                      // LWG 2059.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
       ##### ->       erase(iterator __position)
                      {
                	iterator __result = __position;
                	++__result;
                	_M_erase_aux(__position);
                	return __result;
                      }
                #else
                      void
                      erase(iterator __position)
                      { _M_erase_aux(__position); }
                
                      void
                      erase(const_iterator __position)
                      { _M_erase_aux(__position); }
                #endif
                      size_type
                      erase(const key_type& __x);
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
                      erase(const_iterator __first, const_iterator __last)
                      {
                	_M_erase_aux(__first, __last);
                	return __last._M_const_cast();
                      }
                #else
                      void
                      erase(iterator __first, iterator __last)
                      { _M_erase_aux(__first, __last); }
                
                      void
                      erase(const_iterator __first, const_iterator __last)
                      { _M_erase_aux(__first, __last); }
                #endif
                      void
                      erase(const key_type* __first, const key_type* __last);
                
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      {
                        _M_erase(_M_begin());
                	_M_impl._M_reset();
                      }
                
                      // Set operations.
                      iterator
                      find(const key_type& __k);
                
                      const_iterator
                      find(const key_type& __k) const;
                
                      size_type
                      count(const key_type& __k) const;
                
                      iterator
        5970 ->       lower_bound(const key_type& __k)
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      lower_bound(const key_type& __k) const
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      iterator
                      upper_bound(const key_type& __k)
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      upper_bound(const key_type& __k) const
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      pair<iterator, iterator>
                      equal_range(const key_type& __k);
                
                      pair<const_iterator, const_iterator>
                      equal_range(const key_type& __k) const;
                
                #if __cplusplus > 201103L
                      template<typename _Cmp, typename _Kt, typename = __void_t<>>
                	struct __is_transparent { };
                
                      template<typename _Cmp, typename _Kt>
                	struct
                	__is_transparent<_Cmp, _Kt, __void_t<typename _Cmp::is_transparent>>
                	{ typedef void type; };
                
                      static auto _S_iter(_Link_type __x) { return iterator(__x); }
                
                      static auto _S_iter(_Const_Link_type __x) { return const_iterator(__x); }
                
                      template<typename _Cmp, typename _Link, typename _Kt>
                	static auto
                	_S_lower_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)
                	{
                	  while (__x != 0)
                	    if (!__cmp(_S_key(__x), __k))
                	      __y = __x, __x = _S_left(__x);
                	    else
                	      __x = _S_right(__x);
                	  return _S_iter(__y);
                	}
                
                      template<typename _Cmp, typename _Link, typename _Kt>
                	static auto
                	_S_upper_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)
                	{
                	  while (__x != 0)
                	    if (__cmp(__k, _S_key(__x)))
                	      __y = __x, __x = _S_left(__x);
                	    else
                	      __x = _S_right(__x);
                	  return _S_iter(__y);
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	iterator
                	_M_find_tr(const _Kt& __k)
                	{
                	  auto& __cmp = _M_impl._M_key_compare;
                	  auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
                	  return (__j == end() || __cmp(__k, _S_key(__j._M_node)))
                	    ? end() : __j;
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	const_iterator
                	_M_find_tr(const _Kt& __k) const
                	{
                	  auto& __cmp = _M_impl._M_key_compare;
                	  auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
                	  return (__j == end() || __cmp(__k, _S_key(__j._M_node)))
                	    ? end() : __j;
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	size_type
                	_M_count_tr(const _Kt& __k) const
                	{
                	  auto __p = _M_equal_range_tr(__k);
                	  return std::distance(__p.first, __p.second);
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	iterator
                	_M_lower_bound_tr(const _Kt& __k)
                	{
                	  auto& __cmp = _M_impl._M_key_compare;
                	  return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	const_iterator
                	_M_lower_bound_tr(const _Kt& __k) const
                	{
                	  auto& __cmp = _M_impl._M_key_compare;
                	  return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	iterator
                	_M_upper_bound_tr(const _Kt& __k)
                	{
                	  auto& __cmp = _M_impl._M_key_compare;
                	  return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	const_iterator
                	_M_upper_bound_tr(const _Kt& __k) const
                	{
                	  auto& __cmp = _M_impl._M_key_compare;
                	  return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	pair<iterator, iterator>
                	_M_equal_range_tr(const _Kt& __k)
                	{
                	  auto __low = _M_lower_bound_tr(__k);
                	  auto __high = __low;
                	  auto& __cmp = _M_impl._M_key_compare;
                	  while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
                	    ++__high;
                	  return { __low, __high };
                	}
                
                      template<typename _Kt,
                	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
                	pair<const_iterator, const_iterator>
                	_M_equal_range_tr(const _Kt& __k) const
                	{
                	  auto __low = _M_lower_bound_tr(__k);
                	  auto __high = __low;
                	  auto& __cmp = _M_impl._M_key_compare;
                	  while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
                	    ++__high;
                	  return { __low, __high };
                	}
                #endif
                
                      // Debugging.
                      bool
                      __rb_verify() const;
                
                #if __cplusplus >= 201103L
                      _Rb_tree&
                      operator=(_Rb_tree&&) noexcept(_Alloc_traits::_S_nothrow_move());
                
                      template<typename _Iterator>
                	void
                	_M_assign_unique(_Iterator, _Iterator);
                
                      template<typename _Iterator>
                	void
                	_M_assign_equal(_Iterator, _Iterator);
                
                    private:
                      // Move elements from container with equal allocator.
                      void
                      _M_move_data(_Rb_tree&, std::true_type);
                
                      // Move elements from container with possibly non-equal allocator,
                      // which might result in a copy not a move.
                      void
                      _M_move_data(_Rb_tree&, std::false_type);
                #endif
                    };
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return __x.size() == __y.size()
                	     && std::equal(__x.begin(), __x.end(), __y.begin());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return std::lexicographical_compare(__x.begin(), __x.end(), 
                					  __y.begin(), __y.end());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return __y < __x; }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { __x.swap(__y); }
                
                #if __cplusplus >= 201103L
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
                    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
                    {
                      using __eq = integral_constant<bool, _Alloc_traits::_S_always_equal()>;
                      if (__x._M_root() != nullptr)
                	_M_move_data(__x, __eq());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_data(_Rb_tree& __x, std::true_type)
                    {
                      _M_root() = __x._M_root();
                      _M_leftmost() = __x._M_leftmost();
                      _M_rightmost() = __x._M_rightmost();
                      _M_root()->_M_parent = _M_end();
                
                      __x._M_root() = 0;
                      __x._M_leftmost() = __x._M_end();
                      __x._M_rightmost() = __x._M_end();
                
                      this->_M_impl._M_node_count = __x._M_impl._M_node_count;
                      __x._M_impl._M_node_count = 0;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_move_data(_Rb_tree& __x, std::false_type)
                    {
                      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
                	  _M_move_data(__x, std::true_type());
                      else
                	{
                	  _Alloc_node __an(*this);
                	  auto __lbd =
                	    [&__an](const value_type& __cval)
                	    {
                	      auto& __val = const_cast<value_type&>(__cval);
                	      return __an(std::move_if_noexcept(__val));
                	    };
                	  _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
                	  _M_leftmost() = _S_minimum(_M_root());
                	  _M_rightmost() = _S_maximum(_M_root());
                	  _M_impl._M_node_count = __x._M_impl._M_node_count;
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    operator=(_Rb_tree&& __x)
                    noexcept(_Alloc_traits::_S_nothrow_move())
                    {
                      _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                      if (_Alloc_traits::_S_propagate_on_move_assign()
                	  || _Alloc_traits::_S_always_equal()
                	  || _M_get_Node_allocator() == __x._M_get_Node_allocator())
                	{
                	  clear();
                	  if (__x._M_root() != nullptr)
                	    _M_move_data(__x, std::true_type());
                	  std::__alloc_on_move(_M_get_Node_allocator(),
                			       __x._M_get_Node_allocator());
                	  return *this;
                	}
                
                      // Try to move each node reusing existing nodes and copying __x nodes
                      // structure.
                      _Reuse_or_alloc_node __roan(*this);
                      _M_impl._M_reset();
                      if (__x._M_root() != nullptr)
                	{
                	  auto __lbd =
                	    [&__roan](const value_type& __cval)
                	    {
                	      auto& __val = const_cast<value_type&>(__cval);
                	      return __roan(std::move_if_noexcept(__val));
                	    };
                	  _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
                	  _M_leftmost() = _S_minimum(_M_root());
                	  _M_rightmost() = _S_maximum(_M_root());
                	  _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  __x.clear();
                	}
                      return *this;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename _Iterator>
                      void
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_assign_unique(_Iterator __first, _Iterator __last)
                      {
                	_Reuse_or_alloc_node __roan(*this);
                	_M_impl._M_reset();
                	for (; __first != __last; ++__first)
                	  _M_insert_unique_(end(), *__first, __roan);
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename _Iterator>
                      void
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_assign_equal(_Iterator __first, _Iterator __last)
                      {
                	_Reuse_or_alloc_node __roan(*this);
                	_M_impl._M_reset();
                	for (; __first != __last; ++__first)
                	  _M_insert_equal_(end(), *__first, __roan);
                      }
                #endif
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    operator=(const _Rb_tree& __x)
                    {
                      if (this != &__x)
                	{
                	  // Note that _Key may be a constant type.
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      auto& __this_alloc = this->_M_get_Node_allocator();
                	      auto& __that_alloc = __x._M_get_Node_allocator();
                	      if (!_Alloc_traits::_S_always_equal()
                		  && __this_alloc != __that_alloc)
                		{
                		  // Replacement allocator cannot free existing storage, we need
                		  // to erase nodes first.
                		  clear();
                		  std::__alloc_on_copy(__this_alloc, __that_alloc);
                		}
                	    }
                #endif
                
                	  _Reuse_or_alloc_node __roan(*this);
                	  _M_impl._M_reset();
                	  _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                	  if (__x._M_root() != 0)
                	    {
                	      _M_root() = _M_copy(__x._M_begin(), _M_end(), __roan);
                	      _M_leftmost() = _S_minimum(_M_root());
                	      _M_rightmost() = _S_maximum(_M_root());
                	      _M_impl._M_node_count = __x._M_impl._M_node_count;
                	    }
                	}
                
                      return *this;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg, typename _NodeGen>
                #else
                    template<typename _NodeGen>
                #endif
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_insert_(_Base_ptr __x, _Base_ptr __p,
                #if __cplusplus >= 201103L
                		 _Arg&& __v,
                #else
                		 const _Val& __v,
                #endif
                		 _NodeGen& __node_gen)
                      {
                	bool __insert_left = (__x != 0 || __p == _M_end()
                			      || _M_impl._M_key_compare(_KeyOfValue()(__v),
                							_S_key(__p)));
                
                	_Link_type __z = __node_gen(_GLIBCXX_FORWARD(_Arg, __v));
                
                	_Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				      this->_M_impl._M_header);
                	++_M_impl._M_node_count;
                	return iterator(__z);
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_lower(_Base_ptr __p, _Arg&& __v)
                #else
                    _M_insert_lower(_Base_ptr __p, const _Val& __v)
                #endif
                    {
                      bool __insert_left = (__p == _M_end()
                			    || !_M_impl._M_key_compare(_S_key(__p),
                						       _KeyOfValue()(__v)));
                
                      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_equal_lower(_Arg&& __v)
                #else
                    _M_insert_equal_lower(const _Val& __v)
                #endif
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_lower(__y, _GLIBCXX_FORWARD(_Arg, __v));
                    }
                
                  template<typename _Key, typename _Val, typename _KoV,
                	   typename _Compare, typename _Alloc>
                    template<typename _NodeGen>
                      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
                      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
                      _M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen& __node_gen)
                      {
                	// Structural copy. __x and __p must be non-null.
                	_Link_type __top = _M_clone_node(__x, __node_gen);
                	__top->_M_parent = __p;
                
                	__try
                	  {
                	    if (__x->_M_right)
                	      __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
                	    __p = __top;
                	    __x = _S_left(__x);
                
                	    while (__x != 0)
                	      {
                		_Link_type __y = _M_clone_node(__x, __node_gen);
                		__p->_M_left = __y;
                		__y->_M_parent = __p;
                		if (__x->_M_right)
                		  __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
                		__p = __y;
                		__x = _S_left(__x);
                	      }
                	  }
                	__catch(...)
                	  {
                	    _M_erase(__top);
                	    __throw_exception_again;
                	  }
                	return __top;
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
          11 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase(_Link_type __x)
                    {
                      // Erase without rebalancing.
                      while (__x != 0)
                	{
                	  _M_erase(_S_right(__x));
                	  _Link_type __y = _S_left(__x);
                	  _M_drop_node(__x);
                	  __x = __y;
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
       14034 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Link_type __x, _Link_type __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Link_type __x, _Link_type __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Link_type __xu(__x), __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<iterator,
                		          iterator>(_M_lower_bound(__x, __y, __k),
                				    _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<iterator, iterator>(iterator(__y),
                				      iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k) const
                    {
                      _Const_Link_type __x = _M_begin();
                      _Const_Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Const_Link_type __xu(__x), __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<const_iterator,
                		          const_iterator>(_M_lower_bound(__x, __y, __k),
                					  _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<const_iterator, const_iterator>(const_iterator(__y),
                						  const_iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
                #if __cplusplus >= 201103L
                    noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                    {
                      if (_M_root() == 0)
                	{
                	  if (__t._M_root() != 0)
                	    {
                	      _M_root() = __t._M_root();
                	      _M_leftmost() = __t._M_leftmost();
                	      _M_rightmost() = __t._M_rightmost();
                	      _M_root()->_M_parent = _M_end();
                	      _M_impl._M_node_count = __t._M_impl._M_node_count;
                	      
                	      __t._M_impl._M_reset();
                	    }
                	}
                      else if (__t._M_root() == 0)
                	{
                	  __t._M_root() = _M_root();
                	  __t._M_leftmost() = _M_leftmost();
                	  __t._M_rightmost() = _M_rightmost();
                	  __t._M_root()->_M_parent = __t._M_end();
                	  __t._M_impl._M_node_count = _M_impl._M_node_count;
                	  
                	  _M_impl._M_reset();
                	}
                      else
                	{
                	  std::swap(_M_root(),__t._M_root());
                	  std::swap(_M_leftmost(),__t._M_leftmost());
                	  std::swap(_M_rightmost(),__t._M_rightmost());
                	  
                	  _M_root()->_M_parent = _M_end();
                	  __t._M_root()->_M_parent = __t._M_end();
                	  std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
                	}
                      // No need to swap header's color as it does not change.
                      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
                
                      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
                				__t._M_get_Node_allocator());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
         162 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_unique_pos(const key_type& __k)
                    {
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      bool __comp = true;
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
                	  __x = __comp ? _S_left(__x) : _S_right(__x);
                	}
                      iterator __j = iterator(__y);
                      if (__comp)
                	{
                	  if (__j == begin())
                	    return _Res(__x, __y);
                	  else
                	    --__j;
                	}
                      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
                	return _Res(__x, __y);
                      return _Res(__j._M_node, 0);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_equal_pos(const key_type& __k)
                    {
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _Res(__x, __y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator, bool>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_unique(_Arg&& __v)
                #else
                    _M_insert_unique(const _Val& __v)
                #endif
                    {
                      typedef pair<iterator, bool> _Res;
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_unique_pos(_KeyOfValue()(__v));
                
                      if (__res.second)
                	{
                	  _Alloc_node __an(*this);
                	  return _Res(_M_insert_(__res.first, __res.second,
                				 _GLIBCXX_FORWARD(_Arg, __v), __an),
                		      true);
                	}
                
                      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg>
                #endif
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                #if __cplusplus >= 201103L
                    _M_insert_equal(_Arg&& __v)
                #else
                    _M_insert_equal(const _Val& __v)
                #endif
                    {
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_equal_pos(_KeyOfValue()(__v));
                      _Alloc_node __an(*this);
                      return _M_insert_(__res.first, __res.second,
                			_GLIBCXX_FORWARD(_Arg, __v), __an);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                         typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
         191 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_hint_unique_pos(const_iterator __position,
                				  const key_type& __k)
                    {
                      iterator __pos = __position._M_const_cast();
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                
                      // end()
                      if (__pos._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
                	    return _Res(0, _M_rightmost());
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
                	{
                	  // First, try before...
                	  iterator __before = __pos;
                	  if (__pos._M_node == _M_leftmost()) // begin()
                	    return _Res(_M_leftmost(), _M_leftmost());
                	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _Res(0, __before._M_node);
                	      else
                		return _Res(__pos._M_node, __pos._M_node);
                	    }
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                	{
                	  // ... then try after.
                	  iterator __after = __pos;
                	  if (__pos._M_node == _M_rightmost())
                	    return _Res(0, _M_rightmost());
                	  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
                	    {
                	      if (_S_right(__pos._M_node) == 0)
                		return _Res(0, __pos._M_node);
                	      else
                		return _Res(__after._M_node, __after._M_node);
                	    }
                	  else
                	    return _M_get_insert_unique_pos(__k);
                	}
                      else
                	// Equivalent keys.
                	return _Res(__pos._M_node, 0);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg, typename _NodeGen>
                #else
                    template<typename _NodeGen>
                #endif
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_insert_unique_(const_iterator __position,
                #if __cplusplus >= 201103L
                			_Arg&& __v,
                #else
                			const _Val& __v,
                #endif
                			_NodeGen& __node_gen)
                    {
                      pair<_Base_ptr, _Base_ptr> __res
                	= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
                
                      if (__res.second)
                	return _M_insert_(__res.first, __res.second,
                			  _GLIBCXX_FORWARD(_Arg, __v),
                			  __node_gen);
                      return iterator(static_cast<_Link_type>(__res.first));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr,
                         typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::_Base_ptr>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
                    {
                      iterator __pos = __position._M_const_cast();
                      typedef pair<_Base_ptr, _Base_ptr> _Res;
                
                      // end()
                      if (__pos._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
                	    return _Res(0, _M_rightmost());
                	  else
                	    return _M_get_insert_equal_pos(__k);
                	}
                      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                	{
                	  // First, try before...
                	  iterator __before = __pos;
                	  if (__pos._M_node == _M_leftmost()) // begin()
                	    return _Res(_M_leftmost(), _M_leftmost());
                	  else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _Res(0, __before._M_node);
                	      else
                		return _Res(__pos._M_node, __pos._M_node);
                	    }
                	  else
                	    return _M_get_insert_equal_pos(__k);
                	}
                      else
                	{
                	  // ... then try after.  
                	  iterator __after = __pos;
                	  if (__pos._M_node == _M_rightmost())
                	    return _Res(0, _M_rightmost());
                	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
                	    {
                	      if (_S_right(__pos._M_node) == 0)
                		return _Res(0, __pos._M_node);
                	      else
                		return _Res(__after._M_node, __after._M_node);
                	    }
                	  else
                	    return _Res(0, 0);
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                #if __cplusplus >= 201103L
                    template<typename _Arg, typename _NodeGen>
                #else
                    template<typename _NodeGen>
                #endif
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_insert_equal_(const_iterator __position,
                #if __cplusplus >= 201103L
                		       _Arg&& __v,
                #else
                		       const _Val& __v,
                #endif
                		       _NodeGen& __node_gen)
                      {
                	pair<_Base_ptr, _Base_ptr> __res
                	  = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
                
                	if (__res.second)
                	  return _M_insert_(__res.first, __res.second,
                			    _GLIBCXX_FORWARD(_Arg, __v),
                			    __node_gen);
                
                	return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
         280 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || _M_impl._M_key_compare(_S_key(__z),
                						      _S_key(__p)));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
                    {
                      bool __insert_left = (__p == _M_end()
                			    || !_M_impl._M_key_compare(_S_key(__p),
                						       _S_key(__z)));
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_equal_lower_node(_Link_type __z)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_lower_node(__y, __z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			     _Compare, _Alloc>::iterator, bool>
          81 ->       _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_unique(_Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    typedef pair<iterator, bool> _Res;
                	    auto __res = _M_get_insert_unique_pos(_S_key(__z));
                	    if (__res.second)
                	      return _Res(_M_insert_node(__res.first, __res.second, __z), true);
                	
                	    _M_drop_node(__z);
                	    return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_equal(_Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_equal_pos(_S_key(__z));
                	    return _M_insert_node(__res.first, __res.second, __z);
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
         121 ->       _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
                
                	    if (__res.second)
                	      return _M_insert_node(__res.first, __res.second, __z);
                
                	    _M_drop_node(__z);
                	    return iterator(static_cast<_Link_type>(__res.first));
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    template<typename... _Args>
                      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
                      {
                	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                
                	__try
                	  {
                	    auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));
                
                	    if (__res.second)
                	      return _M_insert_node(__res.first, __res.second, __z);
                
                	    return _M_insert_equal_lower_node(__z);
                	  }
                	__catch(...)
                	  {
                	    _M_drop_node(__z);
                	    __throw_exception_again;
                	  }
                      }
                #endif
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      _M_insert_unique(_II __first, _II __last)
                      {
                	_Alloc_node __an(*this);
                	for (; __first != __last; ++__first)
                	  _M_insert_unique_(end(), *__first, __an);
                      }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      _M_insert_equal(_II __first, _II __last)
                      {
                	_Alloc_node __an(*this);
                	for (; __first != __last; ++__first)
                	  _M_insert_equal_(end(), *__first, __an);
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
       ##### ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase_aux(const_iterator __position)
                    {
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(const_cast<_Base_ptr>(__position._M_node),
                				 this->_M_impl._M_header));
                      _M_drop_node(__y);
                      --_M_impl._M_node_count;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase_aux(const_iterator __first, const_iterator __last)
                    {
                      if (__first == begin() && __last == end())
                	clear();
                      else
                	while (__first != __last)
                	  erase(__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key& __x)
                    {
                      pair<iterator, iterator> __p = equal_range(__x);
                      const size_type __old_size = size();
                      erase(__p.first, __p.second);
                      return __old_size - size();
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key* __first, const _Key* __last)
                    {
                      while (__first != __last)
                	erase(*__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
        8478 ->     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k)
                    {
                      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k,
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k) const
                    {
                      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k, 
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    count(const _Key& __k) const
                    {
                      pair<const_iterator, const_iterator> __p = equal_range(__k);
                      const size_type __n = std::distance(__p.first, __p.second);
                      return __n;
                    }
                
                  _GLIBCXX_PURE unsigned int
                  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                                       const _Rb_tree_node_base* __root) throw ();
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    bool
                    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
                    {
                      if (_M_impl._M_node_count == 0 || begin() == end())
                	return _M_impl._M_node_count == 0 && begin() == end()
                	       && this->_M_impl._M_header._M_left == _M_end()
                	       && this->_M_impl._M_header._M_right == _M_end();
                
                      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
                      for (const_iterator __it = begin(); __it != end(); ++__it)
                	{
                	  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
                	  _Const_Link_type __L = _S_left(__x);
                	  _Const_Link_type __R = _S_right(__x);
                
                	  if (__x->_M_color == _S_red)
                	    if ((__L && __L->_M_color == _S_red)
                		|| (__R && __R->_M_color == _S_red))
                	      return false;
                
                	  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
                	    return false;
                	  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
                	    return false;
                
                	  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
                	    return false;
                	}
                
                      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
                	return false;
                      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
                	return false;
                      return true;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      156      59583
      674      52335
      670      51671
      191      37141
      686      30641
      152      26967
      877      21942
      678      20384
      233      18061
      199      14863

Execution Summary:

       51   Executable lines in this file
       51   Lines executed
   100.00   Percent of the file executed

   432650   Total number of line executions
  8483.33   Average executions per line


*** File /usr/include/c++/5/mutex:
                // <mutex> -*- C++ -*-
                
                // Copyright (C) 2003-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/mutex
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_MUTEX
                #define _GLIBCXX_MUTEX 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <tuple>
                #include <chrono>
                #include <exception>
                #include <type_traits>
                #include <functional>
                #include <system_error>
                #include <bits/functexcept.h>
                #include <bits/gthr.h>
                #include <bits/move.h> // for std::swap
                #include <bits/cxxabi_forced.h>
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #ifdef _GLIBCXX_HAS_GTHREADS
                  // Common base class for std::mutex and std::timed_mutex
                  class __mutex_base
                  {
                  protected:
                    typedef __gthread_mutex_t			__native_type;
                
                #ifdef __GTHREAD_MUTEX_INIT
                    __native_type  _M_mutex = __GTHREAD_MUTEX_INIT;
                
         436 ->     constexpr __mutex_base() noexcept = default;
                #else
                    __native_type  _M_mutex;
                
                    __mutex_base() noexcept
                    {
                      // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)
                      __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mutex);
                    }
                
                    ~__mutex_base() noexcept { __gthread_mutex_destroy(&_M_mutex); }
                #endif
                
                    __mutex_base(const __mutex_base&) = delete;
                    __mutex_base& operator=(const __mutex_base&) = delete;
                  };
                
                  // Common base class for std::recursive_mutex and std::recursive_timed_mutex
                  class __recursive_mutex_base
                  {
                  protected:
                    typedef __gthread_recursive_mutex_t		__native_type;
                
                    __recursive_mutex_base(const __recursive_mutex_base&) = delete;
                    __recursive_mutex_base& operator=(const __recursive_mutex_base&) = delete;
                
                #ifdef __GTHREAD_RECURSIVE_MUTEX_INIT
                    __native_type  _M_mutex = __GTHREAD_RECURSIVE_MUTEX_INIT;
                
                    __recursive_mutex_base() = default;
                #else
                    __native_type  _M_mutex;
                
                    __recursive_mutex_base()
                    {
                      // XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)
                      __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(&_M_mutex);
                    }
                
                    ~__recursive_mutex_base()
                    { __gthread_recursive_mutex_destroy(&_M_mutex); }
                #endif
                  };
                
                  /**
                   * @defgroup mutexes Mutexes
                   * @ingroup concurrency
                   *
                   * Classes for mutex support.
                   * @{
                   */
                
                  /// The standard mutex type.
                  class mutex : private __mutex_base
                  {
                  public:
                    typedef __native_type* 			native_handle_type;
                
                #ifdef __GTHREAD_MUTEX_INIT
                    constexpr
                #endif
         437 ->     mutex() noexcept = default;
                    ~mutex() = default;
                
                    mutex(const mutex&) = delete;
                    mutex& operator=(const mutex&) = delete;
                
                    void
       46498 ->     lock()
                    {
                      int __e = __gthread_mutex_lock(&_M_mutex);
                
                      // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
                      if (__e)
                	__throw_system_error(__e);
                    }
                
                    bool
                    try_lock() noexcept
                    {
                      // XXX EINVAL, EAGAIN, EBUSY
                      return !__gthread_mutex_trylock(&_M_mutex);
                    }
                
                    void
       49291 ->     unlock()
                    {
                      // XXX EINVAL, EAGAIN, EPERM
                      __gthread_mutex_unlock(&_M_mutex);
                    }
                
                    native_handle_type
       12736 ->     native_handle()
                    { return &_M_mutex; }
                  };
                
                  /// The standard recursive mutex type.
                  class recursive_mutex : private __recursive_mutex_base
                  {
                  public:
                    typedef __native_type* 			native_handle_type;
                
                    recursive_mutex() = default;
                    ~recursive_mutex() = default;
                
                    recursive_mutex(const recursive_mutex&) = delete;
                    recursive_mutex& operator=(const recursive_mutex&) = delete;
                
                    void
                    lock()
                    {
                      int __e = __gthread_recursive_mutex_lock(&_M_mutex);
                
                      // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
                      if (__e)
                	__throw_system_error(__e);
                    }
                
                    bool
                    try_lock() noexcept
                    {
                      // XXX EINVAL, EAGAIN, EBUSY
                      return !__gthread_recursive_mutex_trylock(&_M_mutex);
                    }
                
                    void
                    unlock()
                    {
                      // XXX EINVAL, EAGAIN, EBUSY
                      __gthread_recursive_mutex_unlock(&_M_mutex);
                    }
                
                    native_handle_type
                    native_handle()
                    { return &_M_mutex; }
                  };
                
                #if _GTHREAD_USE_MUTEX_TIMEDLOCK
                  template<typename _Derived>
                    class __timed_mutex_impl
                    {
                    protected:
                      typedef chrono::high_resolution_clock 	__clock_t;
                
                      template<typename _Rep, typename _Period>
                	bool
                	_M_try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
                	{
                	  using chrono::steady_clock;
                	  auto __rt = chrono::duration_cast<steady_clock::duration>(__rtime);
                	  if (ratio_greater<steady_clock::period, _Period>())
                	    ++__rt;
                	  return _M_try_lock_until(steady_clock::now() + __rt);
                	}
                
                      template<typename _Duration>
                	bool
                	_M_try_lock_until(const chrono::time_point<__clock_t,
                						   _Duration>& __atime)
                	{
                	  auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
                	  auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);
                
                	  __gthread_time_t __ts = {
                	    static_cast<std::time_t>(__s.time_since_epoch().count()),
                	    static_cast<long>(__ns.count())
                	  };
                
                	  auto __mutex = static_cast<_Derived*>(this)->native_handle();
                	  return !__gthread_mutex_timedlock(__mutex, &__ts);
                	}
                
                      template<typename _Clock, typename _Duration>
                	bool
                	_M_try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
                	{
                	  auto __rtime = __atime - _Clock::now();
                	  return _M_try_lock_until(__clock_t::now() + __rtime);
                	}
                    };
                
                  /// The standard timed mutex type.
                  class timed_mutex
                  : private __mutex_base, public __timed_mutex_impl<timed_mutex>
                  {
                  public:
                    typedef __native_type* 		  	native_handle_type;
                
                    timed_mutex() = default;
                    ~timed_mutex() = default;
                
                    timed_mutex(const timed_mutex&) = delete;
                    timed_mutex& operator=(const timed_mutex&) = delete;
                
                    void
                    lock()
                    {
                      int __e = __gthread_mutex_lock(&_M_mutex);
                
                      // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
                      if (__e)
                	__throw_system_error(__e);
                    }
                
                    bool
                    try_lock() noexcept
                    {
                      // XXX EINVAL, EAGAIN, EBUSY
                      return !__gthread_mutex_trylock(&_M_mutex);
                    }
                
                    template <class _Rep, class _Period>
                      bool
                      try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
                      { return _M_try_lock_for(__rtime); }
                
                    template <class _Clock, class _Duration>
                      bool
                      try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
                      { return _M_try_lock_until(__atime); }
                
                    void
                    unlock()
                    {
                      // XXX EINVAL, EAGAIN, EBUSY
                      __gthread_mutex_unlock(&_M_mutex);
                    }
                
                    native_handle_type
                    native_handle()
                    { return &_M_mutex; }
                  };
                
                  /// The standard recursive timed mutex type.
                  class recursive_timed_mutex
                  : private __recursive_mutex_base,
                    public __timed_mutex_impl<recursive_timed_mutex>
                  {
                  public:
                    typedef __native_type* 			native_handle_type;
                
                    recursive_timed_mutex() = default;
                    ~recursive_timed_mutex() = default;
                
                    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
                    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;
                
                    void
                    lock()
                    {
                      int __e = __gthread_recursive_mutex_lock(&_M_mutex);
                
                      // EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)
                      if (__e)
                	__throw_system_error(__e);
                    }
                
                    bool
                    try_lock() noexcept
                    {
                      // XXX EINVAL, EAGAIN, EBUSY
                      return !__gthread_recursive_mutex_trylock(&_M_mutex);
                    }
                
                    template <class _Rep, class _Period>
                      bool
                      try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
                      { return _M_try_lock_for(__rtime); }
                
                    template <class _Clock, class _Duration>
                      bool
                      try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
                      { return _M_try_lock_until(__atime); }
                
                    void
                    unlock()
                    {
                      // XXX EINVAL, EAGAIN, EBUSY
                      __gthread_recursive_mutex_unlock(&_M_mutex);
                    }
                
                    native_handle_type
                    native_handle()
                    { return &_M_mutex; }
                  };
                #endif
                #endif // _GLIBCXX_HAS_GTHREADS
                
                  /// Do not acquire ownership of the mutex.
                  struct defer_lock_t { };
                
                  /// Try to acquire ownership of the mutex without blocking.
                  struct try_to_lock_t { };
                
                  /// Assume the calling thread has already obtained mutex ownership
                  /// and manage it.
                  struct adopt_lock_t { };
                
                  /// Tag used to prevent a scoped lock from acquiring ownership of a mutex.
                  constexpr defer_lock_t	defer_lock { };
                
                  /// Tag used to prevent a scoped lock from blocking if a mutex is locked.
                  constexpr try_to_lock_t	try_to_lock { };
                
                  /// Tag used to make a scoped lock take ownership of a locked mutex.
                  constexpr adopt_lock_t	adopt_lock { };
                
                  /** @brief A movable scoped lock type.
                   *
                   * A unique_lock controls mutex ownership within a scope. Ownership of the
                   * mutex can be delayed until after construction and can be transferred
                   * to another unique_lock by move construction or move assignment. If a
                   * mutex lock is owned when the destructor runs ownership will be released.
                   */
                  template<typename _Mutex>
                    class lock_guard
                    {
                    public:
                      typedef _Mutex mutex_type;
                
       35828 ->       explicit lock_guard(mutex_type& __m) : _M_device(__m)
                      { _M_device.lock(); }
                
                      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
                      { } // calling thread owns mutex
                
       37195 ->       ~lock_guard()
                      { _M_device.unlock(); }
                
                      lock_guard(const lock_guard&) = delete;
                      lock_guard& operator=(const lock_guard&) = delete;
                
                    private:
                      mutex_type&  _M_device;
                    };
                
                  /// unique_lock
                  template<typename _Mutex>
                    class unique_lock
                    {
                    public:
                      typedef _Mutex mutex_type;
                
                      unique_lock() noexcept
                      : _M_device(0), _M_owns(false)
                      { }
                
        2591 ->       explicit unique_lock(mutex_type& __m)
                      : _M_device(std::__addressof(__m)), _M_owns(false)
                      {
                	lock();
                	_M_owns = true;
                      }
                
                      unique_lock(mutex_type& __m, defer_lock_t) noexcept
                      : _M_device(std::__addressof(__m)), _M_owns(false)
                      { }
                
                      unique_lock(mutex_type& __m, try_to_lock_t)
                      : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())
                      { }
                
                      unique_lock(mutex_type& __m, adopt_lock_t)
                      : _M_device(std::__addressof(__m)), _M_owns(true)
                      {
                	// XXX calling thread owns mutex
                      }
                
                      template<typename _Clock, typename _Duration>
                	unique_lock(mutex_type& __m,
                		    const chrono::time_point<_Clock, _Duration>& __atime)
                	: _M_device(std::__addressof(__m)),
                	  _M_owns(_M_device->try_lock_until(__atime))
                	{ }
                
                      template<typename _Rep, typename _Period>
                	unique_lock(mutex_type& __m,
                		    const chrono::duration<_Rep, _Period>& __rtime)
                	: _M_device(std::__addressof(__m)),
                	  _M_owns(_M_device->try_lock_for(__rtime))
                	{ }
                
        3339 ->       ~unique_lock()
                      {
                	if (_M_owns)
                	  unlock();
                      }
                
                      unique_lock(const unique_lock&) = delete;
                      unique_lock& operator=(const unique_lock&) = delete;
                
                      unique_lock(unique_lock&& __u) noexcept
                      : _M_device(__u._M_device), _M_owns(__u._M_owns)
                      {
                	__u._M_device = 0;
                	__u._M_owns = false;
                      }
                
                      unique_lock& operator=(unique_lock&& __u) noexcept
                      {
                	if(_M_owns)
                	  unlock();
                
                	unique_lock(std::move(__u)).swap(*this);
                
                	__u._M_device = 0;
                	__u._M_owns = false;
                
                	return *this;
                      }
                
                      void
       11175 ->       lock()
                      {
                	if (!_M_device)
                	  __throw_system_error(int(errc::operation_not_permitted));
                	else if (_M_owns)
                	  __throw_system_error(int(errc::resource_deadlock_would_occur));
                	else
                	  {
                	    _M_device->lock();
                	    _M_owns = true;
                	  }
                      }
                
                      bool
                      try_lock()
                      {
                	if (!_M_device)
                	  __throw_system_error(int(errc::operation_not_permitted));
                	else if (_M_owns)
                	  __throw_system_error(int(errc::resource_deadlock_would_occur));
                	else
                	  {
                	    _M_owns = _M_device->try_lock();
                	    return _M_owns;
                	  }
                      }
                
                      template<typename _Clock, typename _Duration>
                	bool
                	try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
                	{
                	  if (!_M_device)
                	    __throw_system_error(int(errc::operation_not_permitted));
                	  else if (_M_owns)
                	    __throw_system_error(int(errc::resource_deadlock_would_occur));
                	  else
                	    {
                	      _M_owns = _M_device->try_lock_until(__atime);
                	      return _M_owns;
                	    }
                	}
                
                      template<typename _Rep, typename _Period>
                	bool
                	try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
                	{
                	  if (!_M_device)
                	    __throw_system_error(int(errc::operation_not_permitted));
                	  else if (_M_owns)
                	    __throw_system_error(int(errc::resource_deadlock_would_occur));
                	  else
                	    {
                	      _M_owns = _M_device->try_lock_for(__rtime);
                	      return _M_owns;
                	    }
                	 }
                
                      void
       10536 ->       unlock()
                      {
                	if (!_M_owns)
                	  __throw_system_error(int(errc::operation_not_permitted));
                	else if (_M_device)
                	  {
                	    _M_device->unlock();
                	    _M_owns = false;
                	  }
                      }
                
                      void
                      swap(unique_lock& __u) noexcept
                      {
                	std::swap(_M_device, __u._M_device);
                	std::swap(_M_owns, __u._M_owns);
                      }
                
                      mutex_type*
                      release() noexcept
                      {
                	mutex_type* __ret = _M_device;
                	_M_device = 0;
                	_M_owns = false;
                	return __ret;
                      }
                
                      bool
                      owns_lock() const noexcept
                      { return _M_owns; }
                
                      explicit operator bool() const noexcept
                      { return owns_lock(); }
                
                      mutex_type*
       12872 ->       mutex() const noexcept
                      { return _M_device; }
                
                    private:
                      mutex_type*	_M_device;
                      bool		_M_owns; // XXX use atomic_bool
                    };
                
                  /// Swap overload for unique_lock objects.
                  template<typename _Mutex>
                    inline void
                    swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept
                    { __x.swap(__y); }
                
                  template<typename _Lock>
                    inline unique_lock<_Lock>
                    __try_to_lock(_Lock& __l)
                    { return unique_lock<_Lock>{__l, try_to_lock}; }
                
                  template<int _Idx, bool _Continue = true>
                    struct __try_lock_impl
                    {
                      template<typename... _Lock>
                	static void
                	__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)
                	{
                          __idx = _Idx;
                          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));
                          if (__lock.owns_lock())
                            {
                	      constexpr bool __cont = _Idx + 2 < sizeof...(_Lock);
                	      using __try_locker = __try_lock_impl<_Idx + 1, __cont>;
                	      __try_locker::__do_try_lock(__locks, __idx);
                              if (__idx == -1)
                                __lock.release();
                            }
                	}
                    };
                
                  template<int _Idx>
                    struct __try_lock_impl<_Idx, false>
                    {
                      template<typename... _Lock>
                	static void
                	__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)
                	{
                          __idx = _Idx;
                          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));
                          if (__lock.owns_lock())
                            {
                              __idx = -1;
                              __lock.release();
                            }
                	}
                    };
                
                  /** @brief Generic try_lock.
                   *  @param __l1 Meets Mutex requirements (try_lock() may throw).
                   *  @param __l2 Meets Mutex requirements (try_lock() may throw).
                   *  @param __l3 Meets Mutex requirements (try_lock() may throw).
                   *  @return Returns -1 if all try_lock() calls return true. Otherwise returns
                   *          a 0-based index corresponding to the argument that returned false.
                   *  @post Either all arguments are locked, or none will be.
                   *
                   *  Sequentially calls try_lock() on each argument.
                   */
                  template<typename _Lock1, typename _Lock2, typename... _Lock3>
                    int
                    try_lock(_Lock1& __l1, _Lock2& __l2, _Lock3&... __l3)
                    {
                      int __idx;
                      auto __locks = std::tie(__l1, __l2, __l3...);
                      __try_lock_impl<0>::__do_try_lock(__locks, __idx);
                      return __idx;
                    }
                
                  /** @brief Generic lock.
                   *  @param __l1 Meets Mutex requirements (try_lock() may throw).
                   *  @param __l2 Meets Mutex requirements (try_lock() may throw).
                   *  @param __l3 Meets Mutex requirements (try_lock() may throw).
                   *  @throw An exception thrown by an argument's lock() or try_lock() member.
                   *  @post All arguments are locked.
                   *
                   *  All arguments are locked via a sequence of calls to lock(), try_lock()
                   *  and unlock().  If the call exits via an exception any locks that were
                   *  obtained will be released.
                   */
                  template<typename _L1, typename _L2, typename... _L3>
                    void
                    lock(_L1& __l1, _L2& __l2, _L3&... __l3)
                    {
                      while (true)
                        {
                          using __try_locker = __try_lock_impl<0, sizeof...(_L3) != 0>;
                          unique_lock<_L1> __first(__l1);
                          int __idx;
                          auto __locks = std::tie(__l2, __l3...);
                          __try_locker::__do_try_lock(__locks, __idx);
                          if (__idx == -1)
                            {
                              __first.release();
                              return;
                            }
                        }
                    }
                
                #ifdef _GLIBCXX_HAS_GTHREADS
                  /// once_flag
                  struct once_flag
                  {
                  private:
                    typedef __gthread_once_t __native_type;
                    __native_type  _M_once = __GTHREAD_ONCE_INIT;
                
                  public:
                    /// Constructor
                    constexpr once_flag() noexcept = default;
                
                    /// Deleted copy constructor
                    once_flag(const once_flag&) = delete;
                    /// Deleted assignment operator
                    once_flag& operator=(const once_flag&) = delete;
                
                    template<typename _Callable, typename... _Args>
                      friend void
                      call_once(once_flag& __once, _Callable&& __f, _Args&&... __args);
                  };
                
                #ifdef _GLIBCXX_HAVE_TLS
                  extern __thread void* __once_callable;
                  extern __thread void (*__once_call)();
                
                  template<typename _Callable>
                    inline void
                    __once_call_impl()
                    {
                      (*(_Callable*)__once_callable)();
                    }
                #else
                  extern function<void()> __once_functor;
                
                  extern void
                  __set_once_functor_lock_ptr(unique_lock<mutex>*);
                
                  extern mutex&
                  __get_once_mutex();
                #endif
                
                  extern "C" void __once_proxy(void);
                
                  /// call_once
                  template<typename _Callable, typename... _Args>
                    void
                    call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)
                    {
                #ifdef _GLIBCXX_HAVE_TLS
                      auto __bound_functor = std::__bind_simple(std::forward<_Callable>(__f),
                          std::forward<_Args>(__args)...);
                      __once_callable = std::__addressof(__bound_functor);
                      __once_call = &__once_call_impl<decltype(__bound_functor)>;
                #else
                      unique_lock<mutex> __functor_lock(__get_once_mutex());
                      auto __callable = std::__bind_simple(std::forward<_Callable>(__f),
                          std::forward<_Args>(__args)...);
                      __once_functor = [&]() { __callable(); };
                      __set_once_functor_lock_ptr(&__functor_lock);
                #endif
                
                      int __e = __gthread_once(&__once._M_once, &__once_proxy);
                
                #ifndef _GLIBCXX_HAVE_TLS
                      if (__functor_lock)
                        __set_once_functor_lock_ptr(0);
                #endif
                
                      if (__e)
                	__throw_system_error(__e);
                    }
                #endif // _GLIBCXX_HAS_GTHREADS
                
                  // @} group mutexes
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                #endif // _GLIBCXX_USE_C99_STDINT_TR1
                
                #endif // C++11
                
                #endif // _GLIBCXX_MUTEX


Top 10 Lines:

     Line      Count

      150      49291
      133      46498
      391      37195
      385      35828
      570      12872
      157      12736
      477      11175
      535      10536
      447       3339
      412       2591

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

   222934   Total number of line executions
 18577.83   Average executions per line


*** File /usr/include/c++/5/bits/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/alloc_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOC_TRAITS_H
                #define _ALLOC_TRAITS_H 1
                
                #if __cplusplus >= 201103L
                
                #include <bits/memoryfwd.h>
                #include <bits/ptr_traits.h>
                #include <ext/numeric_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc, typename _Tp>
                    class __alloctr_rebind_helper
                    {
                      template<typename _Alloc2, typename _Tp2>
                	static constexpr true_type
                	_S_chk(typename _Alloc2::template rebind<_Tp2>::other*);
                
                      template<typename, typename>
                	static constexpr false_type
                	_S_chk(...);
                
                    public:
                      using __type = decltype(_S_chk<_Alloc, _Tp>(nullptr));
                    };
                
                  template<typename _Alloc, typename _Tp,
                	   bool = __alloctr_rebind_helper<_Alloc, _Tp>::__type::value>
                    struct __alloctr_rebind;
                
                  template<typename _Alloc, typename _Tp>
                    struct __alloctr_rebind<_Alloc, _Tp, true>
                    {
                      typedef typename _Alloc::template rebind<_Tp>::other __type;
                    };
                
                  template<template<typename, typename...> class _Alloc, typename _Tp,
                	   typename _Up, typename... _Args>
                    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>
                    {
                      typedef _Alloc<_Tp, _Args...> __type;
                    };
                
                  template<typename _Alloc, typename _Tp>
                    using __alloc_rebind = typename __alloctr_rebind<_Alloc, _Tp>::__type;
                
                  /**
                   * @brief  Uniform interface to all allocator types.
                   * @ingroup allocators
                  */
                  template<typename _Alloc>
                    struct allocator_traits
                    {
                      /// The allocator type
                      typedef _Alloc allocator_type;
                      /// The allocated type
                      typedef typename _Alloc::value_type value_type;
                
                #define _GLIBCXX_ALLOC_TR_NESTED_TYPE(_NTYPE, _ALT) \
                  private: \
                  template<typename _Tp> \
                    static typename _Tp::_NTYPE _S_##_NTYPE##_helper(_Tp*); \
                  static _ALT _S_##_NTYPE##_helper(...); \
                    typedef decltype(_S_##_NTYPE##_helper((_Alloc*)0)) __##_NTYPE; \
                  public:
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(pointer, value_type*)
                
                      /**
                       * @brief   The allocator's pointer type.
                       *
                       * @c Alloc::pointer if that type exists, otherwise @c value_type*
                      */
                      typedef __pointer pointer;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(const_pointer,
                  typename pointer_traits<pointer>::template rebind<const value_type>)
                
                      /**
                       * @brief   The allocator's const pointer type.
                       *
                       * @c Alloc::const_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
                      */
                      typedef __const_pointer const_pointer;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(void_pointer,
                  typename pointer_traits<pointer>::template rebind<void>)
                
                      /**
                       * @brief   The allocator's void pointer type.
                       *
                       * @c Alloc::void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<void> </tt>
                      */
                      typedef __void_pointer void_pointer;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(const_void_pointer,
                  typename pointer_traits<pointer>::template rebind<const void>)
                
                      /**
                       * @brief   The allocator's const void pointer type.
                       *
                       * @c Alloc::const_void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
                      */
                      typedef __const_void_pointer const_void_pointer;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,
                			      typename pointer_traits<pointer>::difference_type)
                
                      /**
                       * @brief   The allocator's difference type
                       *
                       * @c Alloc::difference_type if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::difference_type </tt>
                      */
                      typedef __difference_type difference_type;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,
                			      typename make_unsigned<difference_type>::type)
                
                      /**
                       * @brief   The allocator's size type
                       *
                       * @c Alloc::size_type if that type exists, otherwise
                       * <tt> make_unsigned<difference_type>::type </tt>
                      */
                      typedef __size_type size_type;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,
                			      false_type)
                
                      /**
                       * @brief   How the allocator is propagated on copy assignment
                       *
                       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      typedef __propagate_on_container_copy_assignment
                	propagate_on_container_copy_assignment;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,
                			      false_type)
                
                      /**
                       * @brief   How the allocator is propagated on move assignment
                       *
                       * @c Alloc::propagate_on_container_move_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      typedef __propagate_on_container_move_assignment
                	propagate_on_container_move_assignment;
                
                _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,
                			      false_type)
                
                      /**
                       * @brief   How the allocator is propagated on swap
                       *
                       * @c Alloc::propagate_on_container_swap if that type exists,
                       * otherwise @c false_type
                      */
                      typedef __propagate_on_container_swap propagate_on_container_swap;
                
                #undef _GLIBCXX_ALLOC_TR_NESTED_TYPE
                
                      template<typename _Tp>
                	using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;
                      template<typename _Tp>
                	using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
                
                    private:
                      template<typename _Alloc2>
                	struct __allocate_helper
                	{
                	  template<typename _Alloc3,
                	    typename = decltype(std::declval<_Alloc3*>()->allocate(
                		  std::declval<size_type>(),
                		  std::declval<const_void_pointer>()))>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc>(0));
                	};
                
                      template<typename _Alloc2>
                	using __has_allocate = typename __allocate_helper<_Alloc2>::type;
                
                      template<typename _Alloc2,
                	       typename = _Require<__has_allocate<_Alloc2>>>
                	static pointer
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)
                	{ return __a.allocate(__n, __hint); }
                
                      template<typename _Alloc2, typename _UnusedHint,
                	       typename = _Require<__not_<__has_allocate<_Alloc2>>>>
                	static pointer
                	_S_allocate(_Alloc2& __a, size_type __n, _UnusedHint)
                	{ return __a.allocate(__n); }
                
                      template<typename _Tp, typename... _Args>
                	struct __construct_helper
                	{
                	  template<typename _Alloc2,
                	    typename = decltype(std::declval<_Alloc2*>()->construct(
                		  std::declval<_Tp*>(), std::declval<_Args>()...))>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc>(0));
                	};
                
                      template<typename _Tp, typename... _Args>
                	using __has_construct
                	  = typename __construct_helper<_Tp, _Args...>::type;
                
                      template<typename _Tp, typename... _Args>
                	static _Require<__has_construct<_Tp, _Args...>>
                	_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      template<typename _Tp, typename... _Args>
                	static
                	_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
                			       is_constructible<_Tp, _Args...>>>
                	_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
                	{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }
                
                      template<typename _Tp>
                	struct __destroy_helper
                	{
                	  template<typename _Alloc2,
                	    typename = decltype(std::declval<_Alloc2*>()->destroy(
                		  std::declval<_Tp*>()))>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc>(0));
                	};
                
                      template<typename _Tp>
                	using __has_destroy = typename __destroy_helper<_Tp>::type;
                
                      template<typename _Tp>
                	static _Require<__has_destroy<_Tp>>
                	_S_destroy(_Alloc& __a, _Tp* __p)
                	{ __a.destroy(__p); }
                
                      template<typename _Tp>
                	static _Require<__not_<__has_destroy<_Tp>>>
                	_S_destroy(_Alloc&, _Tp* __p)
                	{ __p->~_Tp(); }
                
                      template<typename _Alloc2>
                	struct __maxsize_helper
                	{
                	  template<typename _Alloc3,
                	    typename = decltype(std::declval<_Alloc3*>()->max_size())>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc2>(0));
                	};
                
                      template<typename _Alloc2>
                	using __has_max_size = typename __maxsize_helper<_Alloc2>::type;
                
                      template<typename _Alloc2,
                	       typename = _Require<__has_max_size<_Alloc2>>>
                	static size_type
                	_S_max_size(_Alloc2& __a, int)
                	{ return __a.max_size(); }
                
                      template<typename _Alloc2,
                	       typename = _Require<__not_<__has_max_size<_Alloc2>>>>
                	static size_type
                	_S_max_size(_Alloc2&, ...)
                	{ return __gnu_cxx::__numeric_traits<size_type>::__max; }
                
                      template<typename _Alloc2>
                	struct __select_helper
                	{
                	  template<typename _Alloc3, typename
                	    = decltype(std::declval<_Alloc3*>()
                		->select_on_container_copy_construction())>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc2>(0));
                	};
                
                      template<typename _Alloc2>
                	using __has_soccc = typename __select_helper<_Alloc2>::type;
                
                      template<typename _Alloc2,
                	       typename = _Require<__has_soccc<_Alloc2>>>
                	static _Alloc2
                	_S_select(_Alloc2& __a, int)
                	{ return __a.select_on_container_copy_construction(); }
                
                      template<typename _Alloc2,
                	       typename = _Require<__not_<__has_soccc<_Alloc2>>>>
                	static _Alloc2
                	_S_select(_Alloc2& __a, ...)
                	{ return __a; }
                
                    public:
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      static pointer
                      allocate(_Alloc& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is
                       *  well-formed, otherwise returns @c a.allocate(n)
                      */
                      static pointer
                      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
                      { return _S_allocate(__a, __n, __hint); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static void deallocate(_Alloc& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type @a _Tp
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                       *  if that expression is well-formed, otherwise uses placement-new
                       *  to construct an object of type @a _Tp at location @a __p from the
                       *  arguments @a __args...
                      */
                      template<typename _Tp, typename... _Args>
                	static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
                	{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Tp
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p) if that expression is well-formed,
                       *  otherwise calls @c __p->~_Tp()
                      */
                      template<typename _Tp>
                	static void destroy(_Alloc& __a, _Tp* __p)
                	{ _S_destroy(__a, __p); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
                       *
                       *  Returns @c __a.max_size() if that expression is well-formed,
                       *  otherwise returns @c numeric_limits<size_type>::max()
                      */
                      static size_type max_size(const _Alloc& __a) noexcept
                      { return _S_max_size(__a, 0); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
                       *
                       *  Returns @c __rhs.select_on_container_copy_construction() if that
                       *  expression is well-formed, otherwise returns @a __rhs
                      */
                      static _Alloc
                      select_on_container_copy_construction(const _Alloc& __rhs)
                      { return _S_select(__rhs, 0); }
                    };
                
                  /// Partial specialization for std::allocator.
                  template<typename _Tp>
                    struct allocator_traits<allocator<_Tp>>
                    {
                      /// The allocator type
                      using allocator_type = allocator<_Tp>;
                      /// The allocated type
                      using value_type = _Tp;
                
                      /// The allocator's pointer type.
                      using pointer = _Tp*;
                
                      /// The allocator's const pointer type.
                      using const_pointer = const _Tp*;
                
                      /// The allocator's void pointer type.
                      using void_pointer = void*;
                
                      /// The allocator's const void pointer type.
                      using const_void_pointer = const void*;
                
                      /// The allocator's difference type
                      using difference_type = std::ptrdiff_t;
                
                      /// The allocator's size type
                      using size_type = std::size_t;
                
                      /// How the allocator is propagated on copy assignment
                      using propagate_on_container_copy_assignment = false_type;
                
                      /// How the allocator is propagated on move assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      /// How the allocator is propagated on swap
                      using propagate_on_container_swap = false_type;
                
                      template<typename _Up>
                	using rebind_alloc = allocator<_Up>;
                
                      template<typename _Up>
                	using rebind_traits = allocator_traits<allocator<_Up>>;
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      static pointer
        1717 ->       allocate(allocator_type& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt>
                      */
                      static pointer
                      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
                      { return __a.allocate(__n, __hint); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static void
         925 ->       deallocate(allocator_type& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                      */
                      template<typename _Up, typename... _Args>
                	static void
       11111 -> 	construct(allocator_type& __a, _Up* __p, _Args&&... __args)
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p).
                      */
                      template<typename _Up>
                	static void
        7553 -> 	destroy(allocator_type& __a, _Up* __p)
                	{ __a.destroy(__p); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size()
                      */
                      static size_type
         282 ->       max_size(const allocator_type& __a) noexcept
                      { return __a.max_size(); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs
                      */
                      static allocator_type
           5 ->       select_on_container_copy_construction(const allocator_type& __rhs)
                      { return __rhs; }
                    };
                
                
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
                    { __one = __two; }
                
                  template<typename _Alloc>
                    inline void
       ##### ->     __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
       ##### ->     inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
                      __do_alloc_on_copy(__one, __two, __pocca());
                    }
                
                  template<typename _Alloc>
                    inline _Alloc __alloc_on_copy(const _Alloc& __a)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      return __traits::select_on_container_copy_construction(__a);
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
                    { __one = std::move(__two); }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
                    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_move_assignment __pocma;
                      __do_alloc_on_move(__one, __two, __pocma());
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
                    {
                      using std::swap;
                      swap(__one, __two);
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
                    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_swap __pocs;
                      __do_alloc_on_swap(__one, __two, __pocs());
                    }
                
                  template<typename _Alloc>
                    class __is_copy_insertable_impl
                    {
                      typedef allocator_traits<_Alloc> _Traits;
                
                      template<typename _Up, typename
                	       = decltype(_Traits::construct(std::declval<_Alloc&>(),
                					     std::declval<_Up*>(),
                					     std::declval<const _Up&>()))>
                	static true_type
                	_M_select(int);
                
                      template<typename _Up>
                	static false_type
                	_M_select(...);
                
                    public:
                      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
                    };
                
                  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc
                  template<typename _Alloc>
                    struct __is_copy_insertable
                    : __is_copy_insertable_impl<_Alloc>::type
                    { };
                
                  // std::allocator<_Tp> just requires CopyConstructible
                  template<typename _Tp>
                    struct __is_copy_insertable<allocator<_Tp>>
                    : is_copy_constructible<_Tp>
                    { };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif
                #endif


Top 10 Lines:

     Line      Count

      529      11111
      541       7553
      490       1717
      516        925
      550        282
      559          5

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

    21593   Total number of line executions
  2699.12   Average executions per line


*** File /usr/include/c++/5/bits/stl_iterator.h:
                // Iterators -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file implements reverse_iterator, back_insert_iterator,
                 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                 *  supporting functions and overloaded operators.
                 */
                
                #ifndef _STL_ITERATOR_H
                #define _STL_ITERATOR_H 1
                
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <bits/move.h>
                #include <bits/ptr_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.1 Reverse iterators
                  /**
                   *  Bidirectional and random access iterators have corresponding reverse
                   *  %iterator adaptors that iterate through the data structure in the
                   *  opposite direction.  They have the same signatures as the corresponding
                   *  iterators.  The fundamental relation between a reverse %iterator and its
                   *  corresponding %iterator @c i is established by the identity:
                   *  @code
                   *      &*(reverse_iterator(i)) == &*(i - 1)
                   *  @endcode
                   *
                   *  <em>This mapping is dictated by the fact that while there is always a
                   *  pointer past the end of an array, there might not be a valid pointer
                   *  before the beginning of an array.</em> [24.4.1]/1,2
                   *
                   *  Reverse iterators can be tricky and surprising at first.  Their
                   *  semantics make sense, however, and the trickiness is a side effect of
                   *  the requirement that the iterators must be safe.
                  */
                  template<typename _Iterator>
                    class reverse_iterator
                    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                		      typename iterator_traits<_Iterator>::value_type,
                		      typename iterator_traits<_Iterator>::difference_type,
                		      typename iterator_traits<_Iterator>::pointer,
                                      typename iterator_traits<_Iterator>::reference>
                    {
                    protected:
                      _Iterator current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      typedef typename __traits_type::pointer		pointer;
                      typedef typename __traits_type::reference		reference;
                
                      /**
                       *  The default constructor value-initializes member @p current.
                       *  If it is a pointer, that means it is zero-initialized.
                      */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 235 No specification of default ctor for reverse_iterator
                      reverse_iterator() : current() { }
                
                      /**
                       *  This %iterator will move in the opposite direction that @p x does.
                      */
                      explicit
                      reverse_iterator(iterator_type __x) : current(__x) { }
                
                      /**
                       *  The copy constructor is normal.
                      */
                      reverse_iterator(const reverse_iterator& __x)
                      : current(__x.current) { }
                
                      /**
                       *  A %reverse_iterator across other types can be copied if the
                       *  underlying %iterator can be converted to the type of @c current.
                      */
                      template<typename _Iter>
                        reverse_iterator(const reverse_iterator<_Iter>& __x)
                	: current(__x.base()) { }
                
                      /**
                       *  @return  @c current, the %iterator used for underlying work.
                      */
                      iterator_type
                      base() const
                      { return current; }
                
                      /**
                       *  @return  A reference to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                       *
                       *  @warning This implementation requires that for an iterator of the
                       *           underlying iterator type, @c x, a reference obtained by
                       *           @c *x remains valid after @c x has been modified or
                       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
                      */
                      reference
                      operator*() const
                      {
                	_Iterator __tmp = current;
                	return *--__tmp;
                      }
                
                      /**
                       *  @return  A pointer to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                      */
                      pointer
                      operator->() const
                      { return &(operator*()); }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      reverse_iterator&
                      operator++()
                      {
                	--current;
                	return *this;
                      }
                
                      /**
                       *  @return  The original value of @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      reverse_iterator
                      operator++(int)
                      {
                	reverse_iterator __tmp = *this;
                	--current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      reverse_iterator&
                      operator--()
                      {
                	++current;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator with the previous value of @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      reverse_iterator
                      operator--(int)
                      {
                	reverse_iterator __tmp = *this;
                	++current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator
                      operator+(difference_type __n) const
                      { return reverse_iterator(current - __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator backwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator&
                      operator+=(difference_type __n)
                      {
                	current -= __n;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator
                      operator-(difference_type __n) const
                      { return reverse_iterator(current + __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator forwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reverse_iterator&
                      operator-=(difference_type __n)
                      {
                	current += __n;
                	return *this;
                      }
                
                      /**
                       *  @return  The value at @c current - @a __n - 1
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      reference
                      operator[](difference_type __n) const
                      { return *(*this + __n); }
                    };
                
                  //@{
                  /**
                   *  @param  __x  A %reverse_iterator.
                   *  @param  __y  A %reverse_iterator.
                   *  @return  A simple bool.
                   *
                   *  Reverse iterators forward many operations to their underlying base()
                   *  iterators.  Others are implemented in terms of one another.
                   *
                  */
                  template<typename _Iterator>
                    inline bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator<(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator!=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline bool
                    operator<=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Iterator>
                    inline typename reverse_iterator<_Iterator>::difference_type
                    operator-(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() - __x.base(); }
                
                  template<typename _Iterator>
                    inline reverse_iterator<_Iterator>
                    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                	      const reverse_iterator<_Iterator>& __x)
                    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                #if __cplusplus >= 201103L
                    // DR 685.
                    inline auto
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    -> decltype(__y.base() - __x.base())
                #else
                    inline typename reverse_iterator<_IteratorL>::difference_type
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                #endif
                    { return __y.base() - __x.base(); }
                  //@}
                
                #if __cplusplus > 201103L
                #define __cpp_lib_make_reverse_iterator 201402
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 2285. make_reverse_iterator
                  /// Generator function for reverse_iterator.
                  template<typename _Iterator>
                    inline reverse_iterator<_Iterator>
                    make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                #endif
                
                  // 24.4.2.2.1 back_insert_iterator
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator appends it to the container using
                   *  push_back.
                   *
                   *  Tip:  Using the back_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class back_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit
                      back_insert_iterator(_Container& __x) : container(&__x) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the end, if you like).  Assigning a value to the %iterator will
                       *  always append the value to the end of the container.
                      */
                #if __cplusplus < 201103L
                      back_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                #else
                      back_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                
                      back_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_back(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      back_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of back_insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating back_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline back_insert_iterator<_Container>
                    back_inserter(_Container& __x)
                    { return back_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator prepends it to the container using
                   *  push_front.
                   *
                   *  Tip:  Using the front_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class front_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the front, if you like).  Assigning a value to the %iterator will
                       *  always prepend the value to the front of the container.
                      */
                #if __cplusplus < 201103L
                      front_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                #else
                      front_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                
                      front_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_front(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      front_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of front_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating front_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline front_insert_iterator<_Container>
                    front_inserter(_Container& __x)
                    { return front_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator inserts it in the container at the
                   *  %iterator's position, rather than overwriting the value at that
                   *  position.
                   *
                   *  (Sequences will actually insert a @e copy of the value before the
                   *  %iterator's position.)
                   *
                   *  Tip:  Using the inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                      typename _Container::iterator iter;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /**
                       *  The only way to create this %iterator is with a container and an
                       *  initial position (a normal %iterator into the container).
                      */
                      insert_iterator(_Container& __x, typename _Container::iterator __i)
                      : container(&__x), iter(__i) {}
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator maintains its own position in the
                       *  container.  Assigning a value to the %iterator will insert the
                       *  value into the container at the place before the %iterator.
                       *
                       *  The position is maintained such that subsequent assignments will
                       *  insert values immediately after one another.  For example,
                       *  @code
                       *     // vector v contains A and Z
                       *
                       *     insert_iterator i (v, ++v.begin());
                       *     i = 1;
                       *     i = 2;
                       *     i = 3;
                       *
                       *     // vector v contains A, 1, 2, 3, and Z
                       *  @endcode
                      */
                #if __cplusplus < 201103L
                      insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                #else
                      insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                
                      insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	iter = container->insert(iter, std::move(__value));
                	++iter;
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param __x  A container of arbitrary type.
                   *  @return  An instance of insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container, typename _Iterator>
                    inline insert_iterator<_Container>
                    inserter(_Container& __x, _Iterator __i)
                    {
                      return insert_iterator<_Container>(__x,
                					 typename _Container::iterator(__i));
                    }
                
                  // @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // This iterator adapter is @a normal in the sense that it does not
                  // change the semantics of any of the operators of its iterator
                  // parameter.  Its primary purpose is to convert an iterator that is
                  // not a class, e.g. a pointer, into an iterator that is a class.
                  // The _Container parameter exists solely so that different containers
                  // using this template can instantiate different types, even if the
                  // _Iterator parameter is the same.
                  using std::iterator_traits;
                  using std::iterator;
                  template<typename _Iterator, typename _Container>
                    class __normal_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type 	difference_type;
                      typedef typename __traits_type::reference 	reference;
                      typedef typename __traits_type::pointer   	pointer;
                
                      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
                      : _M_current(_Iterator()) { }
                
                      explicit
          84 ->       __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
                      : _M_current(__i) { }
                
                      // Allow iterator to const_iterator conversion
                      template<typename _Iter>
                        __normal_iterator(const __normal_iterator<_Iter,
                			  typename __enable_if<
                      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
                		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
                        : _M_current(__i.base()) { }
                
                      // Forward iterator requirements
                      reference
       10111 ->       operator*() const _GLIBCXX_NOEXCEPT
                      { return *_M_current; }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                
                      __normal_iterator&
        9977 ->       operator++() _GLIBCXX_NOEXCEPT
                      {
                	++_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator++(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current++); }
                
                      // Bidirectional iterator requirements
                      __normal_iterator&
                      operator--() _GLIBCXX_NOEXCEPT
                      {
                	--_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator--(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current--); }
                
                      // Random access iterator requirements
                      reference
                      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return _M_current[__n]; }
                
                      __normal_iterator&
                      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current += __n; return *this; }
                
                      __normal_iterator
                      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current + __n); }
                
                      __normal_iterator&
                      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current -= __n; return *this; }
                
                      __normal_iterator
          10 ->       operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current - __n); }
                
                      const _Iterator&
       20292 ->       base() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                    };
                
                  // Note: In what follows, the left- and right-hand-side iterators are
                  // allowed to vary in types (conceptually in cv-qualification) so that
                  // comparison between cv-qualified and non-cv-qualified iterators be
                  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                  // will make overload resolution ambiguous (when in scope) if we don't
                  // provide overloads whose operands are of the same type.  Can someone
                  // remind me what generic programming is about? -- Gaby
                
                  // Forward iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
       10145 ->     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  // Random access iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                #if __cplusplus >= 201103L
                    // DR 685.
                    inline auto
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
                    -> decltype(__lhs.base() - __rhs.base())
                #else
                    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                #endif
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline typename __normal_iterator<_Iterator, _Container>::difference_type
                    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline __normal_iterator<_Iterator, _Container>
                    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                    _GLIBCXX_NOEXCEPT
                    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.3  Move iterators
                  /**
                   *  Class template move_iterator is an iterator adapter with the same
                   *  behavior as the underlying iterator except that its dereference
                   *  operator implicitly converts the value returned by the underlying
                   *  iterator's dereference operator to an rvalue reference.  Some
                   *  generic algorithms can be called with move iterators to replace
                   *  copying with moving.
                   */
                  template<typename _Iterator>
                    class move_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                      typedef typename __traits_type::reference		__base_ref;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      // NB: DR 680.
                      typedef _Iterator					pointer;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2106. move_iterator wrapping iterators returning prvalues
                      typedef typename conditional<is_reference<__base_ref>::value,
                			 typename remove_reference<__base_ref>::type&&,
                			 __base_ref>::type		reference;
                
                      move_iterator()
                      : _M_current() { }
                
                      explicit
         282 ->       move_iterator(iterator_type __i)
                      : _M_current(__i) { }
                
                      template<typename _Iter>
                	move_iterator(const move_iterator<_Iter>& __i)
                	: _M_current(__i.base()) { }
                
                      iterator_type
         266 ->       base() const
                      { return _M_current; }
                
                      reference
       ##### ->       operator*() const
                      { return static_cast<reference>(*_M_current); }
                
                      pointer
                      operator->() const
                      { return _M_current; }
                
                      move_iterator&
       ##### ->       operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      move_iterator
                      operator++(int)
                      {
                	move_iterator __tmp = *this;
                	++_M_current;
                	return __tmp;
                      }
                
                      move_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      move_iterator
                      operator--(int)
                      {
                	move_iterator __tmp = *this;
                	--_M_current;
                	return __tmp;
                      }
                
                      move_iterator
                      operator+(difference_type __n) const
                      { return move_iterator(_M_current + __n); }
                
                      move_iterator&
                      operator+=(difference_type __n)
                      {
                	_M_current += __n;
                	return *this;
                      }
                
                      move_iterator
                      operator-(difference_type __n) const
                      { return move_iterator(_M_current - __n); }
                    
                      move_iterator&
                      operator-=(difference_type __n)
                      { 
                	_M_current -= __n;
                	return *this;
                      }
                
                      reference
                      operator[](difference_type __n) const
                      { return std::move(_M_current[__n]); }
                    };
                
                  // Note: See __normal_iterator operators note from Gaby to understand
                  // why there are always 2 versions for most of the move_iterator
                  // operators.
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator==(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline bool
          87 ->     operator==(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator!=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline bool
          83 ->     operator!=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator<(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline bool
                    operator<=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline bool
                    operator>(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // DR 685.
                  template<typename _IteratorL, typename _IteratorR>
                    inline auto
                    operator-(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline auto
                    operator-(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline move_iterator<_Iterator>
                    operator+(typename move_iterator<_Iterator>::difference_type __n,
                	      const move_iterator<_Iterator>& __x)
                    { return __x + __n; }
                
                  template<typename _Iterator>
                    inline move_iterator<_Iterator>
                    make_move_iterator(_Iterator __i)
                    { return move_iterator<_Iterator>(__i); }
                
                  template<typename _Iterator, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond
                      <typename iterator_traits<_Iterator>::value_type>::value,
                                _Iterator, move_iterator<_Iterator>>::type>
                    inline _ReturnType
         277 ->     __make_move_if_noexcept_iterator(_Iterator __i)
                    { return _ReturnType(__i); }
                
                  // @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
                  std::__make_move_if_noexcept_iterator(_Iter)
                #else
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
                #endif // C++11
                
                #endif


Top 10 Lines:

     Line      Count

      805      20292
      841      10145
      753      10111
      761       9977
      984        282
     1166        277
      992        266
     1071         87
      740         84
     1083         83

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

    51614   Total number of line executions
  3970.31   Average executions per line


*** File /usr/include/c++/5/bits/stl_deque.h:
                // Deque implementation -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_deque.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{deque}
                 */
                
                #ifndef _STL_DEQUE_H
                #define _STL_DEQUE_H 1
                
                #include <bits/concept_check.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /**
                   *  @brief This function controls the size of memory nodes.
                   *  @param  __size  The size of an element.
                   *  @return   The number (not byte size) of elements per node.
                   *
                   *  This function started off as a compiler kludge from SGI, but
                   *  seems to be a useful wrapper around a repeated constant
                   *  expression.  The @b 512 is tunable (and no other code needs to
                   *  change), but no investigation has been done since inheriting the
                   *  SGI code.  Touch _GLIBCXX_DEQUE_BUF_SIZE only if you know what
                   *  you are doing, however: changing it breaks the binary
                   *  compatibility!!
                  */
                
                #ifndef _GLIBCXX_DEQUE_BUF_SIZE
                #define _GLIBCXX_DEQUE_BUF_SIZE 512
                #endif
                
                  _GLIBCXX_CONSTEXPR inline size_t
                  __deque_buf_size(size_t __size)
        7772 ->   { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
                	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
                
                
                  /**
                   *  @brief A deque::iterator.
                   *
                   *  Quite a bit of intelligence here.  Much of the functionality of
                   *  deque is actually passed off to this class.  A deque holds two
                   *  of these internally, marking its valid range.  Access to
                   *  elements is done as offsets of either of those two, relying on
                   *  operator overloading in this class.
                   *
                   *  All the functions are op overloads except for _M_set_node.
                  */
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    struct _Deque_iterator
                    {
                #if __cplusplus < 201103L
                      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
                      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
                      typedef _Tp*                                         _Elt_pointer;
                      typedef _Tp**                                        _Map_pointer;
                #else
                    private:
                      template<typename _Up>
                	using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
                      template<typename _CvTp>
                	using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
                    public:
                      typedef __iter<_Tp>		iterator;
                      typedef __iter<const _Tp>		const_iterator;
                      typedef __ptr_to<_Tp>		_Elt_pointer;
                      typedef __ptr_to<_Elt_pointer>	_Map_pointer;
                #endif
                
        6260 ->       static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
                      { return __deque_buf_size(sizeof(_Tp)); }
                
                      typedef std::random_access_iterator_tag iterator_category;
                      typedef _Tp                             value_type;
                      typedef _Ptr                            pointer;
                      typedef _Ref                            reference;
                      typedef size_t                          size_type;
                      typedef ptrdiff_t                       difference_type;
                      typedef _Deque_iterator                 _Self;
                
                      _Elt_pointer _M_cur;
                      _Elt_pointer _M_first;
                      _Elt_pointer _M_last;
                      _Map_pointer _M_node;
                
                      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
                      : _M_cur(__x), _M_first(*__y),
                        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }
                
         560 ->       _Deque_iterator() _GLIBCXX_NOEXCEPT
                      : _M_cur(), _M_first(), _M_last(), _M_node() { }
                
       20189 ->       _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
                      : _M_cur(__x._M_cur), _M_first(__x._M_first),
                        _M_last(__x._M_last), _M_node(__x._M_node) { }
                
                      iterator
                      _M_const_cast() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_cur, _M_node); }
                
                      reference
       16148 ->       operator*() const _GLIBCXX_NOEXCEPT
                      { return *_M_cur; }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return _M_cur; }
                
                      _Self&
       ##### ->       operator++() _GLIBCXX_NOEXCEPT
                      {
                	++_M_cur;
                	if (_M_cur == _M_last)
                	  {
                	    _M_set_node(_M_node + 1);
                	    _M_cur = _M_first;
                	  }
                	return *this;
                      }
                
                      _Self
                      operator++(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	++*this;
                	return __tmp;
                      }
                
                      _Self&
                      operator--() _GLIBCXX_NOEXCEPT
                      {
                	if (_M_cur == _M_first)
                	  {
                	    _M_set_node(_M_node - 1);
                	    _M_cur = _M_last;
                	  }
                	--_M_cur;
                	return *this;
                      }
                
                      _Self
                      operator--(int) _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	--*this;
                	return __tmp;
                      }
                
                      _Self&
                      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __offset = __n + (_M_cur - _M_first);
                	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
                	  _M_cur += __n;
                	else
                	  {
                	    const difference_type __node_offset =
                	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
                	                   : -difference_type((-__offset - 1)
                					      / _S_buffer_size()) - 1;
                	    _M_set_node(_M_node + __node_offset);
                	    _M_cur = _M_first + (__offset - __node_offset
                				 * difference_type(_S_buffer_size()));
                	  }
                	return *this;
                      }
                
                      _Self
                      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	return __tmp += __n;
                      }
                
                      _Self&
                      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { return *this += -__n; }
                
                      _Self
                      operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
                      {
                	_Self __tmp = *this;
                	return __tmp -= __n;
                      }
                
                      reference
                      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return *(*this + __n); }
                
                      /** 
                       *  Prepares to traverse new_node.  Sets everything except
                       *  _M_cur, which should therefore be set by the caller
                       *  immediately afterwards, based on _M_first and _M_last.
                       */
                      void
        1421 ->       _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
                      {
                	_M_node = __new_node;
                	_M_first = *__new_node;
                	_M_last = _M_first + difference_type(_S_buffer_size());
                      }
                    };
                
                  // Note: we also provide overloads whose operands are of the same type in
                  // order to avoid ambiguous overload resolution when std::rel_ops operators
                  // are in scope (for additional details, see libstdc++/3628)
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline bool
       39474 ->     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
                    { return __x._M_cur == __y._M_cur; }
                
                  template<typename _Tp, typename _RefL, typename _PtrL,
                	   typename _RefR, typename _PtrR>
                    inline bool
                    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
                    { return __x._M_cur == __y._M_cur; }
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline bool
        1665 ->     operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
                    { return !(__x == __y); }
                
                  template<typename _Tp, typename _RefL, typename _PtrL,
                	   typename _RefR, typename _PtrR>
                    inline bool
                    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
                    { return !(__x == __y); }
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline bool
                    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
                    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                                          : (__x._M_node < __y._M_node); }
                
                  template<typename _Tp, typename _RefL, typename _PtrL,
                	   typename _RefR, typename _PtrR>
                    inline bool
                    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
                    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                	                                  : (__x._M_node < __y._M_node); }
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline bool
                    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
                    { return __y < __x; }
                
                  template<typename _Tp, typename _RefL, typename _PtrL,
                	   typename _RefR, typename _PtrR>
                    inline bool
                    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
                    { return __y < __x; }
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline bool
                    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
                    { return !(__y < __x); }
                
                  template<typename _Tp, typename _RefL, typename _PtrL,
                	   typename _RefR, typename _PtrR>
                    inline bool
                    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
                    { return !(__y < __x); }
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline bool
                    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
                    { return !(__x < __y); }
                
                  template<typename _Tp, typename _RefL, typename _PtrL,
                	   typename _RefR, typename _PtrR>
                    inline bool
                    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
                    { return !(__x < __y); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
        4949 ->     operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
                    {
                      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
                	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
                	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
                	+ (__y._M_last - __y._M_cur);
                    }
                
                  template<typename _Tp, typename _RefL, typename _PtrL,
                	   typename _RefR, typename _PtrR>
                    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
                    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
                    {
                      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
                	(_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
                	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
                	+ (__y._M_last - __y._M_cur);
                    }
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    inline _Deque_iterator<_Tp, _Ref, _Ptr>
                    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
                    _GLIBCXX_NOEXCEPT
                    { return __x + __n; }
                
                  template<typename _Tp>
                    void
                    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
                	 const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<typename _Tp>
                    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
                		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
                		       __result); }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<typename _Tp>
                    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    { return std::copy_backward(_Deque_iterator<_Tp,
                				const _Tp&, const _Tp*>(__first),
                				_Deque_iterator<_Tp,
                				const _Tp&, const _Tp*>(__last),
                				__result); }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<typename _Tp>
                    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
                		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
                		       __result); }
                
                  template<typename _Tp>
                    _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<typename _Tp>
                    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                    { return std::move_backward(_Deque_iterator<_Tp,
                				const _Tp&, const _Tp*>(__first),
                				_Deque_iterator<_Tp,
                				const _Tp&, const _Tp*>(__last),
                				__result); }
                #endif
                
                  /**
                   *  Deque base class.  This class provides the unified face for %deque's
                   *  allocation.  This class's constructor and destructor allocate and
                   *  deallocate (but do not initialize) storage.  This makes %exception
                   *  safety easier.
                   *
                   *  Nothing in this class ever constructs or destroys an actual Tp element.
                   *  (Deque handles that itself.)  Only/All memory management is performed
                   *  here.
                  */
                  template<typename _Tp, typename _Alloc>
                    class _Deque_base
                    {
                    protected:
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_Tp>::other _Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	 _Alloc_traits;
                
                #if __cplusplus < 201103L
                      typedef _Tp*					_Ptr;
                      typedef const _Tp*				_Ptr_const;
                #else
                      typedef typename _Alloc_traits::pointer		_Ptr;
                      typedef typename _Alloc_traits::const_pointer	_Ptr_const;
                #endif
                
                      typedef typename _Alloc_traits::template rebind<_Ptr>::other
                	_Map_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;
                
                    public:
                      typedef _Alloc                  allocator_type;
                      typedef typename _Alloc_traits::size_type size_type;
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
                      typedef _Deque_iterator<_Tp, _Tp&, _Ptr>          iterator;
                      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;
                
         273 ->       _Deque_base()
                      : _M_impl()
                      { _M_initialize_map(0); }
                
                      _Deque_base(size_t __num_elements)
                      : _M_impl()
                      { _M_initialize_map(__num_elements); }
                
                      _Deque_base(const allocator_type& __a, size_t __num_elements)
                      : _M_impl(__a)
                      { _M_initialize_map(__num_elements); }
                
                      _Deque_base(const allocator_type& __a)
                      : _M_impl(__a)
                      { /* Caller must initialize map. */ }
                
                #if __cplusplus >= 201103L
                      _Deque_base(_Deque_base&& __x, false_type)
                      : _M_impl(__x._M_move_impl())
                      { }
                
                      _Deque_base(_Deque_base&& __x, true_type)
                      : _M_impl(std::move(__x._M_get_Tp_allocator()))
                      {
                	_M_initialize_map(0);
                	if (__x._M_impl._M_map)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                      }
                
                      _Deque_base(_Deque_base&& __x)
                      : _Deque_base(std::move(__x),
                		    __gnu_cxx::__allocator_always_compares_equal<_Alloc>{})
                      { }
                
                      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  {
                	    if (__x._M_impl._M_map)
                	      {
                		_M_initialize_map(0);
                		this->_M_impl._M_swap_data(__x._M_impl);
                	      }
                	  }
                	else
                	  {
                	    _M_initialize_map(__n);
                	  }
                      }
                #endif
                
                      ~_Deque_base() _GLIBCXX_NOEXCEPT;
                
                    protected:
                      typedef typename iterator::_Map_pointer _Map_pointer;
                
                      //This struct encapsulates the implementation of the std::deque
                      //standard container and at the same time makes use of the EBO
                      //for empty allocators.
         120 ->       struct _Deque_impl
                      : public _Tp_alloc_type
                      {
                	_Map_pointer _M_map;
                	size_t _M_map_size;
                	iterator _M_start;
                	iterator _M_finish;
                
         274 -> 	_Deque_impl()
                	: _Tp_alloc_type(), _M_map(), _M_map_size(0),
                	  _M_start(), _M_finish()
                	{ }
                
                	_Deque_impl(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
                	: _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
                	  _M_start(), _M_finish()
                	{ }
                
                #if __cplusplus >= 201103L
                	_Deque_impl(_Deque_impl&&) = default;
                
                	_Deque_impl(_Tp_alloc_type&& __a) noexcept
                	: _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
                	  _M_start(), _M_finish()
                	{ }
                #endif
                
                	void _M_swap_data(_Deque_impl& __x) _GLIBCXX_NOEXCEPT
                	{
                	  using std::swap;
                	  swap(this->_M_start, __x._M_start);
                	  swap(this->_M_finish, __x._M_finish);
                	  swap(this->_M_map, __x._M_map);
                	  swap(this->_M_map_size, __x._M_map_size);
                	}
                      };
                
                      _Tp_alloc_type&
         580 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                
                      const _Tp_alloc_type&
         408 ->       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                
                      _Map_alloc_type
         407 ->       _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
                      { return _Map_alloc_type(_M_get_Tp_allocator()); }
                
                      _Ptr
         653 ->       _M_allocate_node()
                      { 
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
                	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
                      }
                
                      void
         474 ->       _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
                	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
                      }
                
                      _Map_pointer
         284 ->       _M_allocate_map(size_t __n)
                      {
                	_Map_alloc_type __map_alloc = _M_get_map_allocator();
                	return _Map_alloc_traits::allocate(__map_alloc, __n);
                      }
                
                      void
         120 ->       _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
                      {
                	_Map_alloc_type __map_alloc = _M_get_map_allocator();
                	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
                      }
                
                    protected:
                      void _M_initialize_map(size_t);
                      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
                      void _M_destroy_nodes(_Map_pointer __nstart,
                			    _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT;
                      enum { _S_initial_map_size = 8 };
                
                      _Deque_impl _M_impl;
                
                #if __cplusplus >= 201103L
                    private:
                      _Deque_impl
                      _M_move_impl()
                      {
                	if (!_M_impl._M_map)
                	  return std::move(_M_impl);
                
                	// Create a copy of the current allocator.
                	_Tp_alloc_type __alloc{_M_get_Tp_allocator()};
                	// Put that copy in a moved-from state.
                	_Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};
                	// Create an empty map that allocates using the moved-from allocator.
                	_Deque_base __empty{__alloc};
                	__empty._M_initialize_map(0);
                	// Now safe to modify current allocator and perform non-throwing swaps.
                	_Deque_impl __ret{std::move(_M_get_Tp_allocator())};
                	_M_impl._M_swap_data(__ret);
                	_M_impl._M_swap_data(__empty._M_impl);
                	return __ret;
                      }
                #endif
                    };
                
                  template<typename _Tp, typename _Alloc>
         120 ->     _Deque_base<_Tp, _Alloc>::
                    ~_Deque_base() _GLIBCXX_NOEXCEPT
                    {
                      if (this->_M_impl._M_map)
                	{
                	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
                			   this->_M_impl._M_finish._M_node + 1);
                	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                	}
                    }
                
                  /**
                   *  @brief Layout storage.
                   *  @param  __num_elements  The count of T's for which to allocate space
                   *                          at first.
                   *  @return   Nothing.
                   *
                   *  The initial underlying memory layout is a bit complicated...
                  */
                  template<typename _Tp, typename _Alloc>
                    void
         278 ->     _Deque_base<_Tp, _Alloc>::
                    _M_initialize_map(size_t __num_elements)
                    {
                      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
                				  + 1);
                
                      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
                					   size_t(__num_nodes + 2));
                      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
                
                      // For "small" maps (needing less than _M_map_size nodes), allocation
                      // starts in the middle elements and grows outwards.  So nstart may be
                      // the beginning of _M_map, but for small maps it may be as far in as
                      // _M_map+3.
                
                      _Map_pointer __nstart = (this->_M_impl._M_map
                			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
                      _Map_pointer __nfinish = __nstart + __num_nodes;
                
                      __try
                	{ _M_create_nodes(__nstart, __nfinish); }
                      __catch(...)
                	{
                	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                	  this->_M_impl._M_map = _Map_pointer();
                	  this->_M_impl._M_map_size = 0;
                	  __throw_exception_again;
                	}
                
                      this->_M_impl._M_start._M_set_node(__nstart);
                      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
                      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
                      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
                					+ __num_elements
                					% __deque_buf_size(sizeof(_Tp)));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
         296 ->     _Deque_base<_Tp, _Alloc>::
                    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
                    {
                      _Map_pointer __cur;
                      __try
                	{
                	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
                	    *__cur = this->_M_allocate_node();
                	}
                      __catch(...)
                	{
                	  _M_destroy_nodes(__nstart, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
         120 ->     _Deque_base<_Tp, _Alloc>::
                    _M_destroy_nodes(_Map_pointer __nstart,
                		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
                    {
                      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
                	_M_deallocate_node(*__n);
                    }
                
                  /**
                   *  @brief  A standard container using fixed-size memory allocation and
                   *  constant-time manipulation of elements at either end.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a>.
                   *
                   *  In previous HP/SGI versions of deque, there was an extra template
                   *  parameter so users could control the node size.  This extension turned
                   *  out to violate the C++ standard (it can be detected using template
                   *  template parameters), and it was removed.
                   *
                   *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:
                   *
                   *  - Tp**        _M_map
                   *  - size_t      _M_map_size
                   *  - iterator    _M_start, _M_finish
                   *
                   *  map_size is at least 8.  %map is an array of map_size
                   *  pointers-to-@a nodes.  (The name %map has nothing to do with the
                   *  std::map class, and @b nodes should not be confused with
                   *  std::list's usage of @a node.)
                   *
                   *  A @a node has no specific type name as such, but it is referred
                   *  to as @a node in this file.  It is a simple array-of-Tp.  If Tp
                   *  is very large, there will be one Tp element per node (i.e., an
                   *  @a array of one).  For non-huge Tp's, node size is inversely
                   *  related to Tp size: the larger the Tp, the fewer Tp's will fit
                   *  in a node.  The goal here is to keep the total size of a node
                   *  relatively small and constant over different Tp's, to improve
                   *  allocator efficiency.
                   *
                   *  Not every pointer in the %map array will point to a node.  If
                   *  the initial number of elements in the deque is small, the
                   *  /middle/ %map pointers will be valid, and the ones at the edges
                   *  will be unused.  This same situation will arise as the %map
                   *  grows: available %map pointers, if any, will be on the ends.  As
                   *  new nodes are created, only a subset of the %map's pointers need
                   *  to be copied @a outward.
                   *
                   *  Class invariants:
                   * - For any nonsingular iterator i:
                   *    - i.node points to a member of the %map array.  (Yes, you read that
                   *      correctly:  i.node does not actually point to a node.)  The member of
                   *      the %map array is what actually points to the node.
                   *    - i.first == *(i.node)    (This points to the node (first Tp element).)
                   *    - i.last  == i.first + node_size
                   *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:
                   *      the implication of this is that i.cur is always a dereferenceable
                   *      pointer, even if i is a past-the-end iterator.
                   * - Start and Finish are always nonsingular iterators.  NOTE: this
                   * means that an empty deque must have one node, a deque with <N
                   * elements (where N is the node buffer size) must have one node, a
                   * deque with N through (2N-1) elements must have two nodes, etc.
                   * - For every node other than start.node and finish.node, every
                   * element in the node is an initialized object.  If start.node ==
                   * finish.node, then [start.cur, finish.cur) are initialized
                   * objects, and the elements outside that range are uninitialized
                   * storage.  Otherwise, [start.cur, start.last) and [finish.first,
                   * finish.cur) are initialized objects, and [start.first, start.cur)
                   * and [finish.cur, finish.last) are uninitialized storage.
                   * - [%map, %map + map_size) is a valid, non-empty range.
                   * - [start.node, finish.node] is a valid range contained within
                   *   [%map, %map + map_size).
                   * - A pointer in the range [%map, %map + map_size) points to an allocated
                   *   node if and only if the pointer is in the range
                   *   [start.node, finish.node].
                   *
                   *  Here's the magic:  nothing in deque is @b aware of the discontiguous
                   *  storage!
                   *
                   *  The memory setup and layout occurs in the parent, _Base, and the iterator
                   *  class is entirely responsible for @a leaping from one node to the next.
                   *  All the implementation routines for deque itself work only through the
                   *  start and finish iterators.  This keeps the routines simple and sane,
                   *  and we can use other standard algorithms as well.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class deque : protected _Deque_base<_Tp, _Alloc>
                    {
                      // concept requirements
                      typedef typename _Alloc::value_type        _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                
                      typedef _Deque_base<_Tp, _Alloc>			_Base;
                      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
                      typedef typename _Base::_Alloc_traits		_Alloc_traits;
                      typedef typename _Base::_Map_pointer		_Map_pointer;
                
                    public:
                      typedef _Tp                                        value_type;
                      typedef typename _Alloc_traits::pointer            pointer;
                      typedef typename _Alloc_traits::const_pointer      const_pointer;
                      typedef typename _Alloc_traits::reference          reference;
                      typedef typename _Alloc_traits::const_reference    const_reference;
                      typedef typename _Base::iterator                   iterator;
                      typedef typename _Base::const_iterator             const_iterator;
                      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>            reverse_iterator;
                      typedef size_t                             size_type;
                      typedef ptrdiff_t                          difference_type;
                      typedef _Alloc                             allocator_type;
                
                    protected:
       ##### ->       static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
                      { return __deque_buf_size(sizeof(_Tp)); }
                
                      // Functions controlling memory layout, and nothing else.
                      using _Base::_M_initialize_map;
                      using _Base::_M_create_nodes;
                      using _Base::_M_destroy_nodes;
                      using _Base::_M_allocate_node;
                      using _Base::_M_deallocate_node;
                      using _Base::_M_allocate_map;
                      using _Base::_M_deallocate_map;
                      using _Base::_M_get_Tp_allocator;
                
                      /** 
                       *  A total of four data members accumulated down the hierarchy.
                       *  May be accessed via _M_impl.*
                       */
                      using _Base::_M_impl;
                
                    public:
                      // [23.2.1.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                
                      /**
                       *  @brief  Creates a %deque with no elements.
                       */
         277 ->       deque() : _Base() { }
                
                      /**
                       *  @brief  Creates a %deque with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      deque(const allocator_type& __a)
                      : _Base(__a, 0) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %deque with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *
                       *  This constructor fills the %deque with @a n default
                       *  constructed elements.
                       */
                      explicit
                      deque(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(__a, __n)
                      { _M_default_initialize(); }
                
                      /**
                       *  @brief  Creates a %deque with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %deque with @a __n copies of @a __value.
                       */
                      deque(size_type __n, const value_type& __value,
                	    const allocator_type& __a = allocator_type())
                      : _Base(__a, __n)
                      { _M_fill_initialize(__value); }
                #else
                      /**
                       *  @brief  Creates a %deque with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %deque with @a __n copies of @a __value.
                       */
                      explicit
                      deque(size_type __n, const value_type& __value = value_type(),
                	    const allocator_type& __a = allocator_type())
                      : _Base(__a, __n)
                      { _M_fill_initialize(__value); }
                #endif
                
                      /**
                       *  @brief  %Deque copy constructor.
                       *  @param  __x  A %deque of identical element and allocator types.
                       *
                       *  The newly-created %deque uses a copy of the allocation object used
                       *  by @a __x.
                       */
                      deque(const deque& __x)
                      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
                	      __x.size())
                      { std::__uninitialized_copy_a(__x.begin(), __x.end(), 
                				    this->_M_impl._M_start,
                				    _M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Deque move constructor.
                       *  @param  __x  A %deque of identical element and allocator types.
                       *
                       *  The newly-created %deque contains the exact contents of @a __x.
                       *  The contents of @a __x are a valid, but unspecified %deque.
                       */
                      deque(deque&& __x)
                      : _Base(std::move(__x)) { }
                
                      /// Copy constructor with alternative allocator
                      deque(const deque& __x, const allocator_type& __a)
                      : _Base(__a, __x.size())
                      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				    this->_M_impl._M_start,
                				    _M_get_Tp_allocator()); }
                
                      /// Move constructor with alternative allocator
                      deque(deque&& __x, const allocator_type& __a)
                      : _Base(std::move(__x), __a, __x.size())
                      {
                	if (__x.get_allocator() != __a)
                	  {
                	    std::__uninitialized_move_a(__x.begin(), __x.end(),
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	    __x.clear();
                	  }
                      }
                
                      /**
                       *  @brief  Builds a %deque from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator object.
                       *
                       *  Create a %deque consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is __l.size()) and do no memory reallocation.
                       */
                      deque(initializer_list<value_type> __l,
                	    const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %deque from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator object.
                       *
                       *  Create a %deque consisting of copies of the elements from [__first,
                       *  __last).
                       *
                       *  If the iterators are forward, bidirectional, or random-access, then
                       *  this will call the elements' copy constructor N times (where N is
                       *  distance(__first,__last)) and do no memory reallocation.  But if only
                       *  input iterators are used, then this will do at most 2N calls to the
                       *  copy constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        deque(_InputIterator __first, _InputIterator __last,
                	      const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        { _M_initialize_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        deque(_InputIterator __first, _InputIterator __last,
                	      const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the elements
                       *  themselves are pointers, the pointed-to memory is not touched in any
                       *  way.  Managing the pointer is the user's responsibility.
                       */
         120 ->       ~deque()
                      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
                
                      /**
                       *  @brief  %Deque assignment operator.
                       *  @param  __x  A %deque of identical element and allocator types.
                       *
                       *  All the elements of @a x are copied, but unlike the copy constructor,
                       *  the allocator object is not copied.
                       */
                      deque&
                      operator=(const deque& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Deque move assignment operator.
                       *  @param  __x  A %deque of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this deque (without copying,
                       *  if the allocators permit it).
                       *  @a __x is a valid, but unspecified %deque.
                       */
                      deque&
                      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
                      {
                	constexpr bool __always_equal = _Alloc_traits::_S_always_equal();
                	_M_move_assign1(std::move(__x),
                		        integral_constant<bool, __always_equal>());
                	return *this;
                      }
                
                      /**
                       *  @brief  Assigns an initializer list to a %deque.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %deque with copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  Note that the assignment completely changes the %deque and that the
                       *  resulting %deque's size is the same as the number of elements
                       *  assigned.  Old data may be lost.
                       */
                      deque&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->assign(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %deque.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %deque with @a n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %deque and that the resulting %deque's size is the same as
                       *  the number of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %deque.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %deque with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %deque and that the
                       *  resulting %deque's size is the same as the number of elements
                       *  assigned.  Old data may be lost.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        { _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %deque.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %deque with copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  Note that the assignment completely changes the %deque and that the
                       *  resulting %deque's size is the same as the number of elements
                       *  assigned.  Old data may be lost.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      { this->assign(__l.begin(), __l.end()); }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _Base::get_allocator(); }
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first element in the
                       *  %deque.  Iteration is done in ordinary element order.
                       */
                      iterator
       18215 ->       begin() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_start; }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %deque.  Iteration is done in ordinary element order.
                       */
                      const_iterator
       ##### ->       begin() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_start; }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %deque.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
        1751 ->       end() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_finish; }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %deque.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_finish; }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %deque.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %deque.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %deque.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %deque.  Iteration is
                       *  done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->_M_impl._M_start); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %deque.  Iteration is done in ordinary element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return this->_M_impl._M_start; }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %deque.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return this->_M_impl._M_finish; }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %deque.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %deque.  Iteration is
                       *  done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->_M_impl._M_start); }
                #endif
                
                      // [23.2.1.2] capacity
                      /**  Returns the number of elements in the %deque.  */
                      size_type
        4583 ->       size() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
                
                      /**  Returns the size() of the largest possible %deque.  */
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %deque to the specified number of elements.
                       *  @param  __new_size  Number of elements the %deque should contain.
                       *
                       *  This function will %resize the %deque to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %deque's current size the %deque is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	const size_type __len = size();
                	if (__new_size > __len)
                	  _M_default_append(__new_size - __len);
                	else if (__new_size < __len)
                	  _M_erase_at_end(this->_M_impl._M_start
                			  + difference_type(__new_size));
                      }
                
                      /**
                       *  @brief  Resizes the %deque to the specified number of elements.
                       *  @param  __new_size  Number of elements the %deque should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %deque to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %deque's current size the %deque is truncated, otherwise the
                       *  %deque is extended and new elements are populated with given
                       *  data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	const size_type __len = size();
                	if (__new_size > __len)
                	  insert(this->_M_impl._M_finish, __new_size - __len, __x);
                	else if (__new_size < __len)
                	  _M_erase_at_end(this->_M_impl._M_start
                			  + difference_type(__new_size));
                      }
                #else
                      /**
                       *  @brief  Resizes the %deque to the specified number of elements.
                       *  @param  __new_size  Number of elements the %deque should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %deque to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %deque's current size the %deque is truncated, otherwise the
                       *  %deque is extended and new elements are populated with given
                       *  data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	const size_type __len = size();
                	if (__new_size > __len)
                	  insert(this->_M_impl._M_finish, __new_size - __len, __x);
                	else if (__new_size < __len)
                	  _M_erase_at_end(this->_M_impl._M_start
                			  + difference_type(__new_size));
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce memory use.  */
                      void
                      shrink_to_fit() noexcept
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns true if the %deque is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      bool
       37693 ->       empty() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
                
                      // element access
                      /**
                       *  @brief Subscript access to the data contained in the %deque.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __n) _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_start[difference_type(__n)]; }
                
                      /**
                       *  @brief Subscript access to the data contained in the %deque.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl._M_start[difference_type(__n)]; }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("deque::_M_range_check: __n "
                				       "(which is %zu)>= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %deque.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the deque.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %deque.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is first
                       *  checked that it is in the range of the deque.  The function throws
                       *  out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %deque.
                       */
                      reference
       16276 ->       front() _GLIBCXX_NOEXCEPT
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %deque.
                       */
                      const_reference
       ##### ->       front() const _GLIBCXX_NOEXCEPT
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last element of the
                       *  %deque.
                       */
                      reference
                      back() _GLIBCXX_NOEXCEPT
                      {
                	iterator __tmp = end();
                	--__tmp;
                	return *__tmp;
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the last
                       *  element of the %deque.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      {
                	const_iterator __tmp = end();
                	--__tmp;
                	return *__tmp;
                      }
                
                      // [23.2.1.2] modifiers
                      /**
                       *  @brief  Add data to the front of the %deque.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the front of the %deque and assigns the given
                       *  data to it.  Due to the nature of a %deque this operation
                       *  can be done in constant time.
                       */
                      void
                      push_front(const value_type& __x)
                      {
                	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
                	  {
                	    _Alloc_traits::construct(this->_M_impl,
                	                             this->_M_impl._M_start._M_cur - 1,
                	                             __x);
                	    --this->_M_impl._M_start._M_cur;
                	  }
                	else
                	  _M_push_front_aux(__x);
                      }
                
                #if __cplusplus >= 201103L
                      void
                      push_front(value_type&& __x)
                      { emplace_front(std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_front(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Add data to the end of the %deque.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %deque and assigns the given data
                       *  to it.  Due to the nature of a %deque this operation can be
                       *  done in constant time.
                       */
                      void
                      push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish._M_cur
                	    != this->_M_impl._M_finish._M_last - 1)
                	  {
                	    _Alloc_traits::construct(this->_M_impl,
                	                             this->_M_impl._M_finish._M_cur, __x);
                	    ++this->_M_impl._M_finish._M_cur;
                	  }
                	else
                	  _M_push_back_aux(__x);
                      }
                
                #if __cplusplus >= 201103L
                      void
        3185 ->       push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes first element.
                       *
                       *  This is a typical stack operation.  It shrinks the %deque by one.
                       *
                       *  Note that no data is returned, and if the first element's data is
                       *  needed, it should be retrieved before pop_front() is called.
                       */
                      void
        7171 ->       pop_front() _GLIBCXX_NOEXCEPT
                      {
                	if (this->_M_impl._M_start._M_cur
                	    != this->_M_impl._M_start._M_last - 1)
                	  {
                	    _Alloc_traits::destroy(this->_M_impl,
                	                           this->_M_impl._M_start._M_cur);
                	    ++this->_M_impl._M_start._M_cur;
                	  }
                	else
                	  _M_pop_front_aux();
                      }
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation.  It shrinks the %deque by one.
                       *
                       *  Note that no data is returned, and if the last element's data is
                       *  needed, it should be retrieved before pop_back() is called.
                       */
                      void
                      pop_back() _GLIBCXX_NOEXCEPT
                      {
                	if (this->_M_impl._M_finish._M_cur
                	    != this->_M_impl._M_finish._M_first)
                	  {
                	    --this->_M_impl._M_finish._M_cur;
                	    _Alloc_traits::destroy(this->_M_impl,
                	                           this->_M_impl._M_finish._M_cur);
                	  }
                	else
                	  _M_pop_back_aux();
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %deque before specified iterator.
                       *  @param  __position  A const_iterator into the %deque.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       */
                      template<typename... _Args>
                        iterator
                        emplace(const_iterator __position, _Args&&... __args);
                
                      /**
                       *  @brief  Inserts given value into %deque before specified iterator.
                       *  @param  __position  A const_iterator into the %deque.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before the
                       *  specified location.
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x);
                #else
                      /**
                       *  @brief  Inserts given value into %deque before specified iterator.
                       *  @param  __position  An iterator into the %deque.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before the
                       *  specified location.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %deque before specified iterator.
                       *  @param  __position  A const_iterator into the %deque.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before the
                       *  specified location.
                       */
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return emplace(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer list into the %deque.
                       *  @param  __p  An iterator into the %deque.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the
                       *  initializer_list @a __l into the %deque before the location
                       *  specified by @a __p.  This is known as <em>list insert</em>.
                       */
                      iterator
                      insert(const_iterator __p, initializer_list<value_type> __l)
                      { return this->insert(__p, __l.begin(), __l.end()); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a number of copies of given data into the %deque.
                       *  @param  __position  A const_iterator into the %deque.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a specified number of copies of the given
                       *  data before the location specified by @a __position.
                       */
                      iterator
                      insert(const_iterator __position, size_type __n, const value_type& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(__position._M_const_cast(), __n, __x);
                	return begin() + __offset;
                      }
                #else
                      /**
                       *  @brief  Inserts a number of copies of given data into the %deque.
                       *  @param  __position  An iterator into the %deque.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of the given
                       *  data before the location specified by @a __position.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a range into the %deque.
                       *  @param  __position  A const_iterator into the %deque.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %deque before the location specified
                       *  by @a __position.  This is known as <em>range insert</em>.
                       */
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        iterator
                        insert(const_iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(__position._M_const_cast(),
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      /**
                       *  @brief  Inserts a range into the %deque.
                       *  @param  __position  An iterator into the %deque.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %deque before the location specified
                       *  by @a __position.  This is known as <em>range insert</em>.
                       */
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %deque by one.
                       *
                       *  The user is cautioned that
                       *  this function only erases the element, and that if the element is
                       *  itself a pointer, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __position)
                #else
                      erase(iterator __position)
                #endif
                      { return _M_erase(__position._M_const_cast()); }
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                erased.
                       *  @return  An iterator pointing to the element pointed to by @a last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %deque accordingly.
                       *
                       *  The user is cautioned that
                       *  this function only erases the elements, and that if the elements
                       *  themselves are pointers, the pointed-to memory is not touched in any
                       *  way.  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __first, const_iterator __last)
                #else
                      erase(iterator __first, iterator __last)
                #endif
                      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
                
                      /**
                       *  @brief  Swaps data with another %deque.
                       *  @param  __x  A %deque of the same element and allocator types.
                       *
                       *  This exchanges the elements between two deques in constant time.
                       *  (Four pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(d1,d2) will feed to this function.
                       */
                      void
                      swap(deque& __x)
                #if __cplusplus >= 201103L
                      noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                      {
                	_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                				  __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(begin()); }
                
                    protected:
                      // Internal constructor functions follow.
                
                      // called by the range constructor to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
                        {
                	  _M_initialize_map(static_cast<size_type>(__n));
                	  _M_fill_initialize(__x);
                	}
                
                      // called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_initialize(__first, __last, _IterCategory());
                	}
                
                      // called by the second initialize_dispatch above
                      //@{
                      /**
                       *  @brief Fills the deque with whatever is in [first,last).
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @return   Nothing.
                       *
                       *  If the iterators are actually forward iterators (or better), then the
                       *  memory layout can be done all at once.  Else we move forward using
                       *  push_back on each value from the iterator.
                       */
                      template<typename _InputIterator>
                        void
                        _M_range_initialize(_InputIterator __first, _InputIterator __last,
                			    std::input_iterator_tag);
                
                      // called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                			    std::forward_iterator_tag);
                      //@}
                
                      /**
                       *  @brief Fills the %deque with copies of value.
                       *  @param  __value  Initial value.
                       *  @return   Nothing.
                       *  @pre _M_start and _M_finish have already been initialized,
                       *  but none of the %deque's elements have yet been constructed.
                       *
                       *  This function is called only when the user provides an explicit size
                       *  (with or without an explicit exemplar value).
                       */
                      void
                      _M_fill_initialize(const value_type& __value);
                
                #if __cplusplus >= 201103L
                      // called by deque(n).
                      void
                      _M_default_initialize();
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        { _M_fill_assign(__n, __val); }
                
                      // called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_assign_aux(__first, __last, _IterCategory());
                	}
                
                      // called by the second assign_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag)
                        {
                	  const size_type __len = std::distance(__first, __last);
                	  if (__len > size())
                	    {
                	      _ForwardIterator __mid = __first;
                	      std::advance(__mid, size());
                	      std::copy(__first, __mid, begin());
                	      insert(end(), __mid, __last);
                	    }
                	  else
                	    _M_erase_at_end(std::copy(__first, __last, begin()));
                	}
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val)
                      {
                	if (__n > size())
                	  {
                	    std::fill(begin(), end(), __val);
                	    insert(end(), __n - size(), __val);
                	  }
                	else
                	  {
                	    _M_erase_at_end(begin() + difference_type(__n));
                	    std::fill(begin(), end(), __val);
                	  }
                      }
                
                      //@{
                      /// Helper functions for push_* and pop_*.
                #if __cplusplus < 201103L
                      void _M_push_back_aux(const value_type&);
                
                      void _M_push_front_aux(const value_type&);
                #else
                      template<typename... _Args>
                        void _M_push_back_aux(_Args&&... __args);
                
                      template<typename... _Args>
                        void _M_push_front_aux(_Args&&... __args);
                #endif
                
                      void _M_pop_back_aux();
                
                      void _M_pop_front_aux();
                      //@}
                
                      // Internal insert functions follow.  The *_aux functions do the actual
                      // insertion work when all shortcuts fail.
                
                      // called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_insert_dispatch(iterator __pos,
                			   _Integer __n, _Integer __x, __true_type)
                        { _M_fill_insert(__pos, __n, __x); }
                
                      // called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_insert_dispatch(iterator __pos,
                			   _InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
                	}
                
                      // called by the second insert_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_insert_aux(iterator __pos, _InputIterator __first,
                			    _InputIterator __last, std::input_iterator_tag);
                
                      // called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
                			    _ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.  Can use fill functions in optimal situations,
                      // otherwise passes off to insert_aux(p,n,x).
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                      // called by insert(p,x)
                #if __cplusplus < 201103L
                      iterator
                      _M_insert_aux(iterator __pos, const value_type& __x);
                #else
                      template<typename... _Args>
                        iterator
                        _M_insert_aux(iterator __pos, _Args&&... __args);
                #endif
                
                      // called by insert(p,n,x) via fill_insert
                      void
                      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);
                
                      // called by range_insert_aux for forward iterators
                      template<typename _ForwardIterator>
                        void
                        _M_insert_aux(iterator __pos,
                		      _ForwardIterator __first, _ForwardIterator __last,
                		      size_type __n);
                
                
                      // Internal erase functions follow.
                
                      void
                      _M_destroy_data_aux(iterator __first, iterator __last);
                
                      // Called by ~deque().
                      // NB: Doesn't deallocate the nodes.
                      template<typename _Alloc1>
                        void
                        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
                        { _M_destroy_data_aux(__first, __last); }
                
                      void
         120 ->       _M_destroy_data(iterator __first, iterator __last,
                		      const std::allocator<_Tp>&)
                      {
                	if (!__has_trivial_destructor(value_type))
                	  _M_destroy_data_aux(__first, __last);
                      }
                
                      // Called by erase(q1, q2).
                      void
                      _M_erase_at_begin(iterator __pos)
                      {
                	_M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
                	_M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
                	this->_M_impl._M_start = __pos;
                      }
                
                      // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
                      // _M_fill_assign, operator=.
                      void
                      _M_erase_at_end(iterator __pos)
                      {
                	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
                	_M_destroy_nodes(__pos._M_node + 1,
                			 this->_M_impl._M_finish._M_node + 1);
                	this->_M_impl._M_finish = __pos;
                      }
                
                      iterator
                      _M_erase(iterator __pos);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                
                #if __cplusplus >= 201103L
                      // Called by resize(sz).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                      //@{
                      /// Memory-handling helpers for the previous internal insert functions.
                      iterator
                      _M_reserve_elements_at_front(size_type __n)
                      {
                	const size_type __vacancies = this->_M_impl._M_start._M_cur
                	                              - this->_M_impl._M_start._M_first;
                	if (__n > __vacancies)
                	  _M_new_elements_at_front(__n - __vacancies);
                	return this->_M_impl._M_start - difference_type(__n);
                      }
                
                      iterator
                      _M_reserve_elements_at_back(size_type __n)
                      {
                	const size_type __vacancies = (this->_M_impl._M_finish._M_last
                				       - this->_M_impl._M_finish._M_cur) - 1;
                	if (__n > __vacancies)
                	  _M_new_elements_at_back(__n - __vacancies);
                	return this->_M_impl._M_finish + difference_type(__n);
                      }
                
                      void
                      _M_new_elements_at_front(size_type __new_elements);
                
                      void
                      _M_new_elements_at_back(size_type __new_elements);
                      //@}
                
                
                      //@{
                      /**
                       *  @brief Memory-handling helpers for the major %map.
                       *
                       *  Makes sure the _M_map has space for new nodes.  Does not
                       *  actually add the nodes.  Can invalidate _M_map pointers.
                       *  (And consequently, %deque iterators.)
                       */
                      void
         381 ->       _M_reserve_map_at_back(size_type __nodes_to_add = 1)
                      {
                	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
                	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
                	  _M_reallocate_map(__nodes_to_add, false);
                      }
                
                      void
                      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
                      {
                	if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
                				       - this->_M_impl._M_map))
                	  _M_reallocate_map(__nodes_to_add, true);
                      }
                
                      void
                      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
                      //@}
                
                #if __cplusplus >= 201103L
                      // Constant-time, nothrow move assignment when source object's memory
                      // can be moved because the allocators are equal.
                      void
                      _M_move_assign1(deque&& __x, /* always equal: */ true_type) noexcept
                      {
                	this->_M_impl._M_swap_data(__x._M_impl);
                	__x.clear();
                	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
                      }
                
                      void
                      _M_move_assign1(deque&& __x, /* always equal: */ false_type)
                      {
                	constexpr bool __move_storage =
                	  _Alloc_traits::_S_propagate_on_move_assign();
                	_M_move_assign2(std::move(__x),
                			integral_constant<bool, __move_storage>());
                      }
                
                      // Destroy all elements and deallocate all memory, then replace
                      // with elements created from __args.
                      template<typename... _Args>
                      void
                      _M_replace_map(_Args&&... __args)
                      {
                	// Create new data first, so if allocation fails there are no effects.
                	deque __newobj(std::forward<_Args>(__args)...);
                	// Free existing storage using existing allocator.
                	clear();
                	_M_deallocate_node(*begin()._M_node); // one node left after clear()
                	_M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                	this->_M_impl._M_map = nullptr;
                	this->_M_impl._M_map_size = 0;
                	// Take ownership of replacement memory.
                	this->_M_impl._M_swap_data(__newobj._M_impl);
                      }
                
                      // Do move assignment when the allocator propagates.
                      void
                      _M_move_assign2(deque&& __x, /* propagate: */ true_type)
                      {
                	// Make a copy of the original allocator state.
                	auto __alloc = __x._M_get_Tp_allocator();
                	// The allocator propagates so storage can be moved from __x,
                	// leaving __x in a valid empty state with a moved-from allocator.
                	_M_replace_map(std::move(__x));
                	// Move the corresponding allocator state too.
                	_M_get_Tp_allocator() = std::move(__alloc);
                      }
                
                      // Do move assignment when it may not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign2(deque&& __x, /* propagate: */ false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  {
                	    // The allocators are equal so storage can be moved from __x,
                	    // leaving __x in a valid empty state with its current allocator.
                	    _M_replace_map(std::move(__x), __x.get_allocator());
                	  }
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                			 std::__make_move_if_noexcept_iterator(__x.end()));
                	    __x.clear();
                	  }
                      }
                #endif
                    };
                
                
                  /**
                   *  @brief  Deque equality comparison.
                   *  @param  __x  A %deque.
                   *  @param  __y  A %deque of the same type as @a __x.
                   *  @return  True iff the size and elements of the deques are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  deques.  Deques are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const deque<_Tp, _Alloc>& __x,
                                         const deque<_Tp, _Alloc>& __y)
                    { return __x.size() == __y.size()
                             && std::equal(__x.begin(), __x.end(), __y.begin()); }
                
                  /**
                   *  @brief  Deque ordering relation.
                   *  @param  __x  A %deque.
                   *  @param  __y  A %deque of the same type as @a __x.
                   *  @return  True iff @a x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  deques.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const deque<_Tp, _Alloc>& __x,
                	      const deque<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const deque<_Tp, _Alloc>& __x,
                	       const deque<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const deque<_Tp, _Alloc>& __x,
                	      const deque<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const deque<_Tp, _Alloc>& __x,
                	       const deque<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const deque<_Tp, _Alloc>& __x,
                	       const deque<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::deque::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
                    { __x.swap(__y); }
                
                #undef _GLIBCXX_DEQUE_BUF_SIZE
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif /* _STL_DEQUE_H */


Top 10 Lines:

     Line      Count

      265      39474
     1349      37693
      149      20189
     1158      18215
     1437      16276
      158      16148
       90       7772
     1548       7171
      126       6260
      349       4949

Execution Summary:

       38   Executable lines in this file
       38   Lines executed
   100.00   Percent of the file executed

   192617   Total number of line executions
  5068.87   Average executions per line


*** File /usr/include/c++/5/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                        rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
          32 ->       struct _Vector_impl 
                      : public _Tp_alloc_type
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
         417 -> 	_Vector_impl()
                	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                
           9 -> 	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
                	: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                
                #if __cplusplus >= 201103L
                	_Vector_impl(_Tp_alloc_type&& __a) noexcept
                	: _Tp_alloc_type(std::move(__a)),
                	  _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                #endif
                
                	void _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT
                	{
                	  std::swap(_M_start, __x._M_start);
                	  std::swap(_M_finish, __x._M_finish);
                	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
                	}
                      };
                      
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
         309 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                
                      const _Tp_alloc_type&
         284 ->       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
         418 ->       _Vector_base()
                      : _M_impl() { }
                
           2 ->       _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _M_impl(__a) { }
                
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                
           6 ->       _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
                      _Vector_base(_Tp_alloc_type&& __a) noexcept
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x) noexcept
                      : _M_impl(std::move(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_swap_data(__x._M_impl); }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                #endif
                
          32 ->       ~_Vector_base() _GLIBCXX_NOEXCEPT
                      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start); }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
         144 ->       _M_allocate(size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
                      }
                
                      void
         166 ->       _M_deallocate(pointer __p, size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	if (__p)
                	  _Tr::deallocate(_M_impl, __p, __n);
                      }
                
                    private:
                      void
           3 ->       _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                      // Concept requirements.
                      typedef typename _Alloc::value_type                _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                      
                      typedef _Vector_base<_Tp, _Alloc>			 _Base;
                      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;
                
                    public:
                      typedef _Tp					 value_type;
                      typedef typename _Base::pointer                    pointer;
                      typedef typename _Alloc_traits::const_pointer      const_pointer;
                      typedef typename _Alloc_traits::reference          reference;
                      typedef typename _Alloc_traits::const_reference    const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		 reverse_iterator;
                      typedef size_t					 size_type;
                      typedef ptrdiff_t					 difference_type;
                      typedef _Alloc                        		 allocator_type;
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       */
         417 ->       vector()
                #if __cplusplus >= 201103L
                      noexcept(is_nothrow_default_constructible<_Alloc>::value)
                #endif
                      : _Base() { }
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
                      vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector uses a copy of the allocation
                       *  object used by @a __x.  All the elements of @a __x are copied,
                       *  but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.
                       */
           4 ->       vector(const vector& __x)
                      : _Base(__x.size(),
                        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector contains the exact contents of @a __x.
                       *  The contents of @a __x are a valid, but unspecified %vector.
                       */
                      vector(vector&& __x) noexcept
                      : _Base(std::move(__x)) { }
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      noexcept(_Alloc_traits::_S_always_equal())
                      : _Base(std::move(__rv), __m)
                      {
                	if (__rv.get_allocator() != __m)
                	  {
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
           2 ->       vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        { _M_initialize_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
          30 ->       ~vector() _GLIBCXX_NOEXCEPT
                      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator()); }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.  Unlike the
                       *  copy constructor, the allocator object is not copied.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  @a __x is a valid, but unspecified %vector.
                       */
                      vector&
                      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                        constexpr bool __move_storage =
                          _Alloc_traits::_S_propagate_on_move_assign()
                          || _Alloc_traits::_S_always_equal();
                        _M_move_assign(std::move(__x),
                                       integral_constant<bool, __move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->assign(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        { _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      { this->assign(__l.begin(), __l.end()); }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
          13 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
          27 ->       begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
          14 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
          25 ->       end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
         856 ->       size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
         275 ->       max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
           8 ->       capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
       20825 ->       operator[](size_type __n) _GLIBCXX_NOEXCEPT
                      { return *(this->_M_impl._M_start + __n); }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
       ##### ->       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
                      { return *(this->_M_impl._M_start + __n); }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n]; 
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front() _GLIBCXX_NOEXCEPT
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
          10 ->       front() const _GLIBCXX_NOEXCEPT
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back() _GLIBCXX_NOEXCEPT
                      { return *(end() - 1); }
                      
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
          10 ->       back() const _GLIBCXX_NOEXCEPT
                      { return *(end() - 1); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                #if __cplusplus >= 201103L
                      _Tp*
                #else
                      pointer
                #endif
                      data() _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                #if __cplusplus >= 201103L
                      const _Tp*
                #else
                      const_pointer
                #endif
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
         250 ->       push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                	                             __x);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                #if __cplusplus >= 201103L
                	  _M_emplace_back_aux(__x);
                #else
                	  _M_insert_aux(end(), __x);
                #endif
                      }
                
                #if __cplusplus >= 201103L
                      void
        2260 ->       push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
       ##### ->       pop_back() _GLIBCXX_NOEXCEPT
                      {
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                        iterator
                        emplace(const_iterator __position, _Args&&... __args);
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x);
                #else
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return emplace(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the 
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, initializer_list<value_type> __l)
                      { return this->insert(__position, __l.begin(), __l.end()); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, size_type __n, const value_type& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(begin() + __offset, __n, __x);
                	return begin() + __offset;
                      }
                #else
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        iterator
                        insert(const_iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(begin() + __offset,
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __position)
                      { return _M_erase(begin() + (__position - cbegin())); }
                #else
                      erase(iterator __position)
                      { return _M_erase(__position); }
                #endif
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __first, const_iterator __last)
                      {
                	const auto __beg = begin();
                	const auto __cbeg = cbegin();
                	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
                      }
                #else
                      erase(iterator __first, iterator __last)
                      { return _M_erase(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       */
                      void
                      swap(vector& __x)
                #if __cplusplus >= 201103L
                      noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                      {
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                	                          __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
       ##### ->       clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                        pointer
           7 ->         _M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                        {
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                        {
                	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_initialize(__first, __last, _IterCategory());
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_initialize(_InputIterator __first,
                			    _InputIterator __last, std::input_iterator_tag)
                        {
                	  for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	    emplace_back(*__first);
                #else
                	    push_back(*__first);
                #endif
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                        void
           2 ->         _M_range_initialize(_ForwardIterator __first,
                			    _ForwardIterator __last, std::forward_iterator_tag)
                        {
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start = this->_M_allocate(__n);
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
                      _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
                					_M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
                      _M_default_initialize(size_type __n)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
                					   _M_get_Tp_allocator());
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        { _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_assign_aux(__first, __last, _IterCategory());
                	}
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                        { _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_insert(__pos, __first, __last, _IterCategory());
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                      // Called by insert(p,x)
                #if __cplusplus < 201103L
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                #else
                      template<typename... _Args>
                        void
                        _M_insert_aux(iterator __position, _Args&&... __args);
                
                      template<typename... _Args>
                        void
                        _M_emplace_back_aux(_Args&&... __args);
                #endif
                
                      // Called by the latter.
                      size_type
         138 ->       _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + std::max(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
       ##### ->       _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
                      {
                	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                	this->_M_impl._M_finish = __pos;
                      }
                
                      iterator
                      _M_erase(iterator __position);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
                      _M_move_assign(vector&& __x, std::true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__tmp._M_impl);
                	this->_M_impl._M_swap_data(__x._M_impl);
                	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, std::false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), std::true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                			 std::__make_move_if_noexcept_iterator(__x.end()));
                	    __x.clear();
                	  }
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) const
                	{ return __ptr; }
                
                      template<typename _Ptr>
                	typename std::pointer_traits<_Ptr>::element_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? nullptr : std::__addressof(*__ptr); }
                #else
                      template<typename _Ptr>
                	_Ptr
                	_M_data_ptr(_Ptr __ptr) const
                	{ return __ptr; }
                #endif
                    };
                
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

      779      20825
      931       2260
      654        856
      124        418
       86        417
      253        417
      113        309
      117        284
      659        275
      913        250

Execution Summary:

       35   Executable lines in this file
       35   Lines executed
   100.00   Percent of the file executed

    26995   Total number of line executions
   771.29   Average executions per line


*** File /usr/include/c++/5/chrono:
                // <chrono> -*- C++ -*-
                
                // Copyright (C) 2008-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/chrono
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_CHRONO
                #define _GLIBCXX_CHRONO 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <ratio>
                #include <type_traits>
                #include <limits>
                #include <ctime>
                #include <bits/parse_numbers.h> // for literals support.
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                  /**
                   * @defgroup chrono Time
                   * @ingroup utilities
                   *
                   * Classes and functions for time.
                   * @{
                   */
                
                  /** @namespace std::chrono
                   *  @brief ISO C++ 2011 entities sub-namespace for time and date.
                   */
                  namespace chrono
                  {
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                    template<typename _Rep, typename _Period = ratio<1>>
                      struct duration;
                
                    template<typename _Clock, typename _Dur = typename _Clock::duration>
                      struct time_point;
                
                  _GLIBCXX_END_NAMESPACE_VERSION
                  }
                
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)
                  
                  template<typename _CT, typename _Period1, typename _Period2>
                    struct __duration_common_type_wrapper
                    {
                    private:
                      typedef __static_gcd<_Period1::num, _Period2::num> __gcd_num;
                      typedef __static_gcd<_Period1::den, _Period2::den> __gcd_den;
                      typedef typename _CT::type __cr;
                      typedef ratio<__gcd_num::value,
                        (_Period1::den / __gcd_den::value) * _Period2::den> __r;
                    public:
                      typedef __success_type<chrono::duration<__cr, __r>> type;
                    };
                
                  template<typename _Period1, typename _Period2>
                    struct __duration_common_type_wrapper<__failure_type, _Period1, _Period2>
                    { typedef __failure_type type; };
                
                  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>
                    struct common_type<chrono::duration<_Rep1, _Period1>,
                             chrono::duration<_Rep2, _Period2>>
                    : public __duration_common_type_wrapper<typename __member_type_wrapper<
                             common_type<_Rep1, _Rep2>>::type, _Period1, _Period2>::type
                    { };
                
                  // 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)
                  
                  template<typename _CT, typename _Clock>
                    struct __timepoint_common_type_wrapper
                    {
                      typedef __success_type<chrono::time_point<_Clock, typename _CT::type>>
                        type;
                    };
                
                  template<typename _Clock>
                    struct __timepoint_common_type_wrapper<__failure_type, _Clock>
                    { typedef __failure_type type; };
                
                  template<typename _Clock, typename _Duration1, typename _Duration2>
                    struct common_type<chrono::time_point<_Clock, _Duration1>,
                             chrono::time_point<_Clock, _Duration2>>
                    : public __timepoint_common_type_wrapper<typename __member_type_wrapper<
                             common_type<_Duration1, _Duration2>>::type, _Clock>::type
                    { };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                
                  namespace chrono
                  {
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                    // Primary template for duration_cast impl.
                    template<typename _ToDur, typename _CF, typename _CR,
                	     bool _NumIsOne = false, bool _DenIsOne = false>
                      struct __duration_cast_impl
                      {
                	template<typename _Rep, typename _Period>
                	  static constexpr _ToDur
                	  __cast(const duration<_Rep, _Period>& __d)
                	  {
                	    typedef typename _ToDur::rep			__to_rep;
                	    return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())
                	      * static_cast<_CR>(_CF::num)
                	      / static_cast<_CR>(_CF::den)));
                	  }
                      };
                
                    template<typename _ToDur, typename _CF, typename _CR>
                      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>
                      {
                	template<typename _Rep, typename _Period>
                	  static constexpr _ToDur
       22443 -> 	  __cast(const duration<_Rep, _Period>& __d)
                	  {
                	    typedef typename _ToDur::rep			__to_rep;
                	    return _ToDur(static_cast<__to_rep>(__d.count()));
                	  }
                      };
                
                    template<typename _ToDur, typename _CF, typename _CR>
                      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>
                      {
                	template<typename _Rep, typename _Period>
                	  static constexpr _ToDur
       15497 -> 	  __cast(const duration<_Rep, _Period>& __d)
                	  {
                	    typedef typename _ToDur::rep			__to_rep;
                	    return _ToDur(static_cast<__to_rep>(
                	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
                	  }
                      };
                
                    template<typename _ToDur, typename _CF, typename _CR>
                      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>
                      {
                	template<typename _Rep, typename _Period>
                	  static constexpr _ToDur
       27808 -> 	  __cast(const duration<_Rep, _Period>& __d)
                	  {
                	    typedef typename _ToDur::rep			__to_rep;
                	    return _ToDur(static_cast<__to_rep>(
                	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
                	  }
                      };
                
                    template<typename _Tp>
                      struct __is_duration
                      : std::false_type
                      { };
                
                    template<typename _Rep, typename _Period>
                      struct __is_duration<duration<_Rep, _Period>>
                      : std::true_type
                      { };
                
                    /// duration_cast
                    template<typename _ToDur, typename _Rep, typename _Period>
                      constexpr typename enable_if<__is_duration<_ToDur>::value,
                				   _ToDur>::type
       65351 ->       duration_cast(const duration<_Rep, _Period>& __d)
                      {
                	typedef typename _ToDur::period				__to_period;
                	typedef typename _ToDur::rep				__to_rep;
                	typedef ratio_divide<_Period, __to_period> 		__cf;
                	typedef typename common_type<__to_rep, _Rep, intmax_t>::type
                	  							__cr;
                	typedef  __duration_cast_impl<_ToDur, __cf, __cr,
                				      __cf::num == 1, __cf::den == 1> __dc;
                	return __dc::__cast(__d);
                      }
                
                    /// treat_as_floating_point
                    template<typename _Rep>
                      struct treat_as_floating_point
                      : is_floating_point<_Rep>
                      { };
                
                    /// duration_values
                    template<typename _Rep>
                      struct duration_values
                      {
                	static constexpr _Rep
        3061 -> 	zero()
                	{ return _Rep(0); }
                
                	static constexpr _Rep
                	max()
                	{ return numeric_limits<_Rep>::max(); }
                
                	static constexpr _Rep
                	min()
                	{ return numeric_limits<_Rep>::lowest(); }
                      };
                
                    template<typename _Tp>
                      struct __is_ratio
                      : std::false_type
                      { };
                
                    template<intmax_t _Num, intmax_t _Den>
                      struct __is_ratio<ratio<_Num, _Den>>
                      : std::true_type
                      { };
                
                    /// duration
                    template<typename _Rep, typename _Period>
                      struct duration
                      {
                	typedef _Rep						rep;
                	typedef _Period 					period;
                
                	static_assert(!__is_duration<_Rep>::value, "rep cannot be a duration");
                	static_assert(__is_ratio<_Period>::value,
                		      "period must be a specialization of ratio");
                	static_assert(_Period::num > 0, "period must be positive");
                
                	// 20.11.5.1 construction / copy / destroy
          70 -> 	constexpr duration() = default;
                
                	// NB: Make constexpr implicit. This cannot be explicitly
                	// constexpr, as any UDT that is not a literal type with a
                	// constexpr copy constructor will be ill-formed.
                	duration(const duration&) = default;
                
                	template<typename _Rep2, typename = typename
                	       enable_if<is_convertible<_Rep2, rep>::value
                			 && (treat_as_floating_point<rep>::value
                			     || !treat_as_floating_point<_Rep2>::value)>::type>
      116819 -> 	  constexpr explicit duration(const _Rep2& __rep)
                	  : __r(static_cast<rep>(__rep)) { }
                
                	template<typename _Rep2, typename _Period2, typename = typename
                	       enable_if<treat_as_floating_point<rep>::value
                			 || (ratio_divide<_Period2, period>::den == 1
                			     && !treat_as_floating_point<_Rep2>::value)>::type>
       24512 -> 	  constexpr duration(const duration<_Rep2, _Period2>& __d)
                	  : __r(duration_cast<duration>(__d).count()) { }
                
                	~duration() = default;
                	duration& operator=(const duration&) = default;
                
                	// 20.11.5.2 observer
                	constexpr rep
      293238 -> 	count() const
                	{ return __r; }
                
                	// 20.11.5.3 arithmetic
                	constexpr duration
                	operator+() const
                	{ return *this; }
                
                	constexpr duration
                	operator-() const
                	{ return duration(-__r); }
                
                	duration&
                	operator++()
                	{
                	  ++__r;
                	  return *this;
                	}
                
                	duration
                	operator++(int)
                	{ return duration(__r++); }
                
                	duration&
                	operator--()
                	{
                	  --__r;
                	  return *this;
                	}
                
                	duration
                	operator--(int)
                	{ return duration(__r--); }
                
                	duration&
       10016 -> 	operator+=(const duration& __d)
                	{
                	  __r += __d.count();
                	  return *this;
                	}
                
                	duration&
                	operator-=(const duration& __d)
                	{
                	  __r -= __d.count();
                	  return *this;
                	}
                
                	duration&
                	operator*=(const rep& __rhs)
                	{
                	  __r *= __rhs;
                	  return *this;
                	}
                
                	duration&
                	operator/=(const rep& __rhs)
                	{
                	  __r /= __rhs;
                	  return *this;
                	}
                
                	// DR 934.
                	template<typename _Rep2 = rep>
                	  typename enable_if<!treat_as_floating_point<_Rep2>::value,
                			     duration&>::type
                	  operator%=(const rep& __rhs)
                	  {
                	    __r %= __rhs;
                	    return *this;
                	  }
                
                	template<typename _Rep2 = rep>
                	  typename enable_if<!treat_as_floating_point<_Rep2>::value,
                			     duration&>::type
                	  operator%=(const duration& __d)
                	  {
                	    __r %= __d.count();
                	    return *this;
                	  }
                
                	// 20.11.5.4 special values
                	static constexpr duration
        3177 -> 	zero()
                	{ return duration(duration_values<rep>::zero()); }
                
                	static constexpr duration
                	min()
                	{ return duration(duration_values<rep>::min()); }
                
                	static constexpr duration
                	max()
                	{ return duration(duration_values<rep>::max()); }
                
                      private:
                	rep __r;
                      };
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr typename common_type<duration<_Rep1, _Period1>,
                				     duration<_Rep2, _Period2>>::type
       15399 ->       operator+(const duration<_Rep1, _Period1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      {
                	typedef duration<_Rep1, _Period1>			__dur1;
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<__dur1,__dur2>::type	__cd;
                	return __cd(__cd(__lhs).count() + __cd(__rhs).count());
                      }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr typename common_type<duration<_Rep1, _Period1>,
                				     duration<_Rep2, _Period2>>::type
       31467 ->       operator-(const duration<_Rep1, _Period1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      {
                	typedef duration<_Rep1, _Period1>			__dur1;
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<__dur1,__dur2>::type	__cd;
                	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
                      }
                
                    template<typename _Rep1, typename _Rep2, bool =
                	     is_convertible<_Rep2,
                			    typename common_type<_Rep1, _Rep2>::type>::value>
                      struct __common_rep_type { };
                
                    template<typename _Rep1, typename _Rep2>
                      struct __common_rep_type<_Rep1, _Rep2, true>
                      { typedef typename common_type<_Rep1, _Rep2>::type type; };
                
                    template<typename _Rep1, typename _Period, typename _Rep2>
                      constexpr
                      duration<typename __common_rep_type<_Rep1, _Rep2>::type, _Period>
                      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
                      {
                	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
                	  __cd;
                	return __cd(__cd(__d).count() * __s);
                      }
                
                    template<typename _Rep1, typename _Rep2, typename _Period>
                      constexpr
                      duration<typename __common_rep_type<_Rep2, _Rep1>::type, _Period>
                      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
                      { return __d * __s; }
                
                    template<typename _Rep1, typename _Period, typename _Rep2>
                      constexpr duration<typename __common_rep_type<_Rep1, typename
                	enable_if<!__is_duration<_Rep2>::value, _Rep2>::type>::type, _Period>
                      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
                      {
                	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
                	  __cd;
                	return __cd(__cd(__d).count() / __s);
                      }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr typename common_type<_Rep1, _Rep2>::type
           1 ->       operator/(const duration<_Rep1, _Period1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      {
                	typedef duration<_Rep1, _Period1>			__dur1;
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<__dur1,__dur2>::type	__cd;
                	return __cd(__lhs).count() / __cd(__rhs).count();
                      }
                
                    // DR 934.
                    template<typename _Rep1, typename _Period, typename _Rep2>
                      constexpr duration<typename __common_rep_type<_Rep1, typename
                	enable_if<!__is_duration<_Rep2>::value, _Rep2>::type>::type, _Period>
                      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
                      {
                	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
                	  __cd;
                	return __cd(__cd(__d).count() % __s);
                      }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr typename common_type<duration<_Rep1, _Period1>,
                				     duration<_Rep2, _Period2>>::type
                      operator%(const duration<_Rep1, _Period1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      {
                	typedef duration<_Rep1, _Period1>			__dur1;
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<__dur1,__dur2>::type	__cd;
                	return __cd(__cd(__lhs).count() % __cd(__rhs).count());
                      }
                
                    // comparisons
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr bool
                      operator==(const duration<_Rep1, _Period1>& __lhs,
                		 const duration<_Rep2, _Period2>& __rhs)
                      {
                	typedef duration<_Rep1, _Period1>			__dur1;
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<__dur1,__dur2>::type	__ct;
                	return __ct(__lhs).count() == __ct(__rhs).count();
                      }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr bool
       33171 ->       operator<(const duration<_Rep1, _Period1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      {
                	typedef duration<_Rep1, _Period1>			__dur1;
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<__dur1,__dur2>::type	__ct;
                	return __ct(__lhs).count() < __ct(__rhs).count();
                      }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr bool
                      operator!=(const duration<_Rep1, _Period1>& __lhs,
                		 const duration<_Rep2, _Period2>& __rhs)
                      { return !(__lhs == __rhs); }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr bool
        3042 ->       operator<=(const duration<_Rep1, _Period1>& __lhs,
                		 const duration<_Rep2, _Period2>& __rhs)
                      { return !(__rhs < __lhs); }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr bool
                      operator>(const duration<_Rep1, _Period1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      { return __rhs < __lhs; }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Rep2, typename _Period2>
                      constexpr bool
         100 ->       operator>=(const duration<_Rep1, _Period1>& __lhs,
                		 const duration<_Rep2, _Period2>& __rhs)
                      { return !(__lhs < __rhs); }
                
                    /// nanoseconds
                    typedef duration<int64_t, nano> 	    nanoseconds;
                
                    /// microseconds
                    typedef duration<int64_t, micro> 	    microseconds;
                
                    /// milliseconds
                    typedef duration<int64_t, milli> 	    milliseconds;
                
                    /// seconds
                    typedef duration<int64_t> 		    seconds;
                
                    /// minutes
                    typedef duration<int64_t, ratio< 60>>   minutes;
                
                    /// hours
                    typedef duration<int64_t, ratio<3600>>  hours;
                
                    /// time_point
                    template<typename _Clock, typename _Dur>
                      struct time_point
                      {
                	typedef _Clock			  			clock;
                	typedef _Dur		  				duration;
                	typedef typename duration::rep	  			rep;
                	typedef typename duration::period			period;
                
           4 -> 	constexpr time_point() : __d(duration::zero())
                	{ }
                
       27483 -> 	constexpr explicit time_point(const duration& __dur)
                	: __d(__dur)
                	{ }
                
                	// conversions
                	template<typename _Dur2>
                	  constexpr time_point(const time_point<clock, _Dur2>& __t)
                	  : __d(__t.time_since_epoch())
                	  { }
                
                	// observer
                	constexpr duration
      159809 -> 	time_since_epoch() const
                	{ return __d; }
                
                	// arithmetic
                	time_point&
         149 -> 	operator+=(const duration& __dur)
                	{
                	  __d += __dur;
                	  return *this;
                	}
                
                	time_point&
                	operator-=(const duration& __dur)
                	{
                	  __d -= __dur;
                	  return *this;
                	}
                
                	// special values
                	static constexpr time_point
                	min()
                	{ return time_point(duration::min()); }
                
                	static constexpr time_point
                	max()
                	{ return time_point(duration::max()); }
                
                      private:
                	duration __d;
                      };
                
                    /// time_point_cast
                    template<typename _ToDur, typename _Clock, typename _Dur>
                      constexpr typename enable_if<__is_duration<_ToDur>::value,
                				   time_point<_Clock, _ToDur>>::type
       12248 ->       time_point_cast(const time_point<_Clock, _Dur>& __t)
                      {
                	typedef time_point<_Clock, _ToDur> 			__time_point;
                	return __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));
                      }
                
                    template<typename _Clock, typename _Dur1,
                	     typename _Rep2, typename _Period2>
                      constexpr time_point<_Clock,
                	typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
       15386 ->       operator+(const time_point<_Clock, _Dur1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      {
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<_Dur1,__dur2>::type	__ct;
                	typedef time_point<_Clock, __ct> 			__time_point;
                	return __time_point(__lhs.time_since_epoch() + __rhs);
                      }
                
                    template<typename _Rep1, typename _Period1,
                	     typename _Clock, typename _Dur2>
                      constexpr time_point<_Clock,
                	typename common_type<duration<_Rep1, _Period1>, _Dur2>::type>
                      operator+(const duration<_Rep1, _Period1>& __lhs,
                		const time_point<_Clock, _Dur2>& __rhs)
                      { 
                	typedef duration<_Rep1, _Period1>			__dur1;
                	typedef typename common_type<__dur1,_Dur2>::type	__ct;
                	typedef time_point<_Clock, __ct> 			__time_point;
                	return __time_point(__rhs.time_since_epoch() + __lhs); 
                      }
                
                    template<typename _Clock, typename _Dur1,
                	     typename _Rep2, typename _Period2>
                      constexpr time_point<_Clock,
                	typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
       ##### ->       operator-(const time_point<_Clock, _Dur1>& __lhs,
                		const duration<_Rep2, _Period2>& __rhs)
                      { 
                	typedef duration<_Rep2, _Period2>			__dur2;
                	typedef typename common_type<_Dur1,__dur2>::type	__ct;
                	typedef time_point<_Clock, __ct> 			__time_point;
                	return __time_point(__lhs.time_since_epoch() -__rhs); 
                      }
                
                    template<typename _Clock, typename _Dur1, typename _Dur2>
                      constexpr typename common_type<_Dur1, _Dur2>::type
       29352 ->       operator-(const time_point<_Clock, _Dur1>& __lhs,
                		const time_point<_Clock, _Dur2>& __rhs)
                      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }
                
                    template<typename _Clock, typename _Dur1, typename _Dur2>
                      constexpr bool
                      operator==(const time_point<_Clock, _Dur1>& __lhs,
                		 const time_point<_Clock, _Dur2>& __rhs)
                      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }
                
                    template<typename _Clock, typename _Dur1, typename _Dur2>
                      constexpr bool
                      operator!=(const time_point<_Clock, _Dur1>& __lhs,
                		 const time_point<_Clock, _Dur2>& __rhs)
                      { return !(__lhs == __rhs); }
                
                    template<typename _Clock, typename _Dur1, typename _Dur2>
                      constexpr bool
       31542 ->       operator<(const time_point<_Clock, _Dur1>& __lhs,
                		const time_point<_Clock, _Dur2>& __rhs)
                      { return  __lhs.time_since_epoch() < __rhs.time_since_epoch(); }
                
                    template<typename _Clock, typename _Dur1, typename _Dur2>
                      constexpr bool
       ##### ->       operator<=(const time_point<_Clock, _Dur1>& __lhs,
                		 const time_point<_Clock, _Dur2>& __rhs)
                      { return !(__rhs < __lhs); }
                
                    template<typename _Clock, typename _Dur1, typename _Dur2>
                      constexpr bool
          20 ->       operator>(const time_point<_Clock, _Dur1>& __lhs,
                		const time_point<_Clock, _Dur2>& __rhs)
                      { return __rhs < __lhs; }
                
                    template<typename _Clock, typename _Dur1, typename _Dur2>
                      constexpr bool
                      operator>=(const time_point<_Clock, _Dur1>& __lhs,
                		 const time_point<_Clock, _Dur2>& __rhs)
                      { return !(__lhs < __rhs); }
                
                
                    // Clocks. 
                
                    // Why nanosecond resolution as the default?  
                    // Why have std::system_clock always count in the higest
                    // resolution (ie nanoseconds), even if on some OSes the low 3
                    // or 9 decimal digits will be always zero? This allows later
                    // implementations to change the system_clock::now()
                    // implementation any time to provide better resolution without
                    // changing function signature or units.
                
                    // To support the (forward) evolution of the library's defined
                    // clocks, wrap inside inline namespace so that the current
                    // defintions of system_clock, steady_clock, and
                    // high_resolution_clock types are uniquely mangled. This way, new
                    // code can use the latests clocks, while the library can contain
                    // compatibility definitions for previous versions.  At some
                    // point, when these clocks settle down, the inlined namespaces
                    // can be removed.  XXX GLIBCXX_ABI Deprecated
                    inline namespace _V2 {
                
                    /**
                     *  @brief System clock.
                     *
                     *  Time returned represents wall time from the system-wide clock.
                    */
                    struct system_clock
                    {
                      typedef chrono::nanoseconds     				duration;
                      typedef duration::rep    					rep;
                      typedef duration::period 					period;
                      typedef chrono::time_point<system_clock, duration> 	time_point;
                
                      static_assert(system_clock::duration::min()
                		    < system_clock::duration::zero(),
                		    "a clock's minimum duration cannot be less than its epoch");
                
                      static constexpr bool is_steady = false;
                
                      static time_point
                      now() noexcept;
                
                      // Map to C API
                      static std::time_t
                      to_time_t(const time_point& __t) noexcept
                      {
                	return std::time_t(duration_cast<chrono::seconds>
                			   (__t.time_since_epoch()).count());
                      }
                
                      static time_point
                      from_time_t(std::time_t __t) noexcept
                      {
                	typedef chrono::time_point<system_clock, seconds>	__from;
                	return time_point_cast<system_clock::duration>
                	       (__from(chrono::seconds(__t)));
                      }
                    };
                
                
                    /**
                     *  @brief Monotonic clock
                     *
                     *  Time returned has the property of only increasing at a uniform rate.
                    */
                    struct steady_clock
                    {
                      typedef chrono::nanoseconds 				duration;
                      typedef duration::rep	  				rep;
                      typedef duration::period	  				period;
                      typedef chrono::time_point<steady_clock, duration> 	time_point;
                
                      static constexpr bool is_steady = true;
                
                      static time_point
                      now() noexcept;
                    };
                
                
                    /**
                     *  @brief Highest-resolution clock
                     *
                     *  This is the clock "with the shortest tick period." Alias to
                     *  std::system_clock until higher-than-nanosecond definitions
                     *  become feasible.
                    */
                    using high_resolution_clock = system_clock;
                
                    } // end inline namespace _V2
                
                  _GLIBCXX_END_NAMESPACE_VERSION
                  } // namespace chrono
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_chrono_udls 201304
                
                  inline namespace literals
                  {
                  inline namespace chrono_literals
                  {
                
                    template<typename _Rep, unsigned long long _Val>
                      struct _Checked_integral_constant
                      : integral_constant<_Rep, static_cast<_Rep>(_Val)>
                      {
                	static_assert(_Checked_integral_constant::value >= 0
                		      && _Checked_integral_constant::value == _Val,
                		      "literal value cannot be represented by duration type");
                      };
                
                    template<typename _Dur, char... _Digits>
                      constexpr _Dur __check_overflow()
                      {
                	using _Val = __parse_int::_Parse_int<_Digits...>;
                	using _Rep = typename _Dur::rep;
                	// TODO: should be simply integral_constant<_Rep, _Val::value>
                	// but GCC doesn't reject narrowing conversions to _Rep.
                	using _CheckedVal = _Checked_integral_constant<_Rep, _Val::value>;
                	return _Dur{_CheckedVal::value};
                      }
                
                    constexpr chrono::duration<long double, ratio<3600,1>>
                    operator""h(long double __hours)
                    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }
                
                    template <char... _Digits>
                      constexpr chrono::hours
                      operator""h()
                      { return __check_overflow<chrono::hours, _Digits...>(); }
                
                    constexpr chrono::duration<long double, ratio<60,1>>
                    operator""min(long double __mins)
                    { return chrono::duration<long double, ratio<60,1>>{__mins}; }
                
                    template <char... _Digits>
                      constexpr chrono::minutes
                      operator""min()
                      { return __check_overflow<chrono::minutes, _Digits...>(); }
                
                    constexpr chrono::duration<long double>
                    operator""s(long double __secs)
                    { return chrono::duration<long double>{__secs}; }
                
                    template <char... _Digits>
                      constexpr chrono::seconds
                      operator""s()
                      { return __check_overflow<chrono::seconds, _Digits...>(); }
                
                    constexpr chrono::duration<long double, milli>
                    operator""ms(long double __msecs)
                    { return chrono::duration<long double, milli>{__msecs}; }
                
                    template <char... _Digits>
                      constexpr chrono::milliseconds
                      operator""ms()
                      { return __check_overflow<chrono::milliseconds, _Digits...>(); }
                
                    constexpr chrono::duration<long double, micro>
                    operator""us(long double __usecs)
                    { return chrono::duration<long double, micro>{__usecs}; }
                
                    template <char... _Digits>
                      constexpr chrono::microseconds
                      operator""us()
                      { return __check_overflow<chrono::microseconds, _Digits...>(); }
                
                    constexpr chrono::duration<long double, nano>
                    operator""ns(long double __nsecs)
                    { return chrono::duration<long double, nano>{__nsecs}; }
                
                    template <char... _Digits>
                      constexpr chrono::nanoseconds
                      operator""ns()
                      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }
                
                  } // inline namespace chrono_literals
                  } // inline namespace literals
                
                  namespace chrono
                  {
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  using namespace literals::chrono_literals;
                
                  _GLIBCXX_END_NAMESPACE_VERSION
                  } // namespace chrono
                
                #endif // __cplusplus > 201103L
                
                  // @} group chrono
                } // namespace std
                
                #endif //_GLIBCXX_USE_C99_STDINT_TR1
                
                #endif // C++11
                
                #endif //_GLIBCXX_CHRONO


Top 10 Lines:

     Line      Count

      278     293238
      568     159809
      263     116819
      194      65351
      489      33171
      668      31542
      393      31467
      650      29352
      172      27808
      556      27483

Execution Summary:

       28   Executable lines in this file
       28   Lines executed
   100.00   Percent of the file executed

   941165   Total number of line executions
 33613.04   Average executions per line


*** File /usr/include/c++/5/bits/stl_map.h:
                // Map implementation -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_map.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{map}
                 */
                
                #ifndef _STL_MAP_H
                #define _STL_MAP_H 1
                
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #include <tuple>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /**
                   *  @brief A standard container made up of (key,value) pairs, which can be
                   *  retrieved based on a key, in logarithmic time.
                   *
                   *  @ingroup associative_containers
                   *
                   *  @tparam _Key  Type of key objects.
                   *  @tparam  _Tp  Type of mapped objects.
                   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
                   *  @tparam _Alloc  Allocator type, defaults to 
                   *                  allocator<pair<const _Key, _Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and an
                   *  <a href="tables.html#69">associative container</a> (using unique keys).
                   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the
                   *  value_type is std::pair<const Key,T>.
                   *
                   *  Maps support bidirectional iterators.
                   *
                   *  The private tree data is declared exactly the same way for map and
                   *  multimap; the distinction is made entirely in how the tree functions are
                   *  called (*_unique versus *_equal, same as the standard).
                  */
                  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
                            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
          11 ->     class map
                    {
                    public:
                      typedef _Key                                          key_type;
                      typedef _Tp                                           mapped_type;
                      typedef std::pair<const _Key, _Tp>                    value_type;
                      typedef _Compare                                      key_compare;
                      typedef _Alloc                                        allocator_type;
                
                    private:
                      // concept requirements
                      typedef typename _Alloc::value_type                   _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
                				_BinaryFunctionConcept)
                      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)
                
                    public:
                      class value_compare
                      : public std::binary_function<value_type, value_type, bool>
                      {
                	friend class map<_Key, _Tp, _Compare, _Alloc>;
                      protected:
                	_Compare comp;
                
                	value_compare(_Compare __c)
                	: comp(__c) { }
                
                      public:
                	bool operator()(const value_type& __x, const value_type& __y) const
                	{ return comp(__x.first, __y.first); }
                      };
                
                    private:
                      /// This turns a red-black tree into a [multi]map. 
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<value_type>::other _Pair_alloc_type;
                
                      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
                		       key_compare, _Pair_alloc_type> _Rep_type;
                
                      /// The actual tree structure.
                      _Rep_type _M_t;
                
                      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;
                
                    public:
                      // many of these are specified differently in ISO, but the following are
                      // "functionally equivalent"
                      typedef typename _Alloc_traits::pointer            pointer;
                      typedef typename _Alloc_traits::const_pointer      const_pointer;
                      typedef typename _Alloc_traits::reference          reference;
                      typedef typename _Alloc_traits::const_reference    const_reference;
                      typedef typename _Rep_type::iterator               iterator;
                      typedef typename _Rep_type::const_iterator         const_iterator;
                      typedef typename _Rep_type::size_type              size_type;
                      typedef typename _Rep_type::difference_type        difference_type;
                      typedef typename _Rep_type::reverse_iterator       reverse_iterator;
                      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
                
                      // [23.3.1.1] construct/copy/destroy
                      // (get_allocator() is also listed in this section)
                
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
         108 ->       map()
                #if __cplusplus >= 201103L
                      noexcept(is_nothrow_default_constructible<allocator_type>::value)
                #endif
                      : _M_t() { }
                
                      /**
                       *  @brief  Creates a %map with no elements.
                       *  @param  __comp  A comparison object.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      map(const _Compare& __comp,
                	  const allocator_type& __a = allocator_type())
                      : _M_t(__comp, _Pair_alloc_type(__a)) { }
                
                      /**
                       *  @brief  %Map copy constructor.
                       *  @param  __x  A %map of identical element and allocator types.
                       *
                       *  The newly-created %map uses a copy of the allocation object
                       *  used by @a __x.
                       */
                      map(const map& __x)
                      : _M_t(__x._M_t) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Map move constructor.
                       *  @param  __x  A %map of identical element and allocator types.
                       *
                       *  The newly-created %map contains the exact contents of @a __x.
                       *  The contents of @a __x are a valid, but unspecified %map.
                       */
                      map(map&& __x)
                      noexcept(is_nothrow_copy_constructible<_Compare>::value)
                      : _M_t(std::move(__x._M_t)) { }
                
                      /**
                       *  @brief  Builds a %map from an initializer_list.
                       *  @param  __l  An initializer_list.
                       *  @param  __comp  A comparison object.
                       *  @param  __a  An allocator object.
                       *
                       *  Create a %map consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *  This is linear in N if the range is already sorted, and NlogN
                       *  otherwise (where N is @a __l.size()).
                       */
                      map(initializer_list<value_type> __l,
                	  const _Compare& __comp = _Compare(),
                	  const allocator_type& __a = allocator_type())
                      : _M_t(__comp, _Pair_alloc_type(__a))
                      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
                
                      /// Allocator-extended default constructor.
                      explicit
                      map(const allocator_type& __a)
                      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }
                
                      /// Allocator-extended copy constructor.
                      map(const map& __m, const allocator_type& __a)
                      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }
                
                      /// Allocator-extended move constructor.
                      map(map&& __m, const allocator_type& __a)
                      noexcept(is_nothrow_copy_constructible<_Compare>::value
                	       && _Alloc_traits::_S_always_equal())
                      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }
                
                      /// Allocator-extended initialier-list constructor.
                      map(initializer_list<value_type> __l, const allocator_type& __a)
                      : _M_t(_Compare(), _Pair_alloc_type(__a))
                      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
                
                      /// Allocator-extended range constructor.
                      template<typename _InputIterator>
                        map(_InputIterator __first, _InputIterator __last,
                	    const allocator_type& __a)
                	: _M_t(_Compare(), _Pair_alloc_type(__a))
                        { _M_t._M_insert_unique(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Builds a %map from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *
                       *  Create a %map consisting of copies of the elements from
                       *  [__first,__last).  This is linear in N if the range is
                       *  already sorted, and NlogN otherwise (where N is
                       *  distance(__first,__last)).
                       */
                      template<typename _InputIterator>
                        map(_InputIterator __first, _InputIterator __last)
                	: _M_t()
                        { _M_t._M_insert_unique(__first, __last); }
                
                      /**
                       *  @brief  Builds a %map from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __comp  A comparison functor.
                       *  @param  __a  An allocator object.
                       *
                       *  Create a %map consisting of copies of the elements from
                       *  [__first,__last).  This is linear in N if the range is
                       *  already sorted, and NlogN otherwise (where N is
                       *  distance(__first,__last)).
                       */
                      template<typename _InputIterator>
                        map(_InputIterator __first, _InputIterator __last,
                	    const _Compare& __comp,
                	    const allocator_type& __a = allocator_type())
                	: _M_t(__comp, _Pair_alloc_type(__a))
                        { _M_t._M_insert_unique(__first, __last); }
                
                      // FIXME There is no dtor declared, but we should have something
                      // generated by Doxygen.  I don't know what tags to add to this
                      // paragraph to make that happen:
                      /**
                       *  The dtor only erases the elements, and note that if the elements
                       *  themselves are pointers, the pointed-to memory is not touched in any
                       *  way.  Managing the pointer is the user's responsibility.
                       */
                
                      /**
                       *  @brief  %Map assignment operator.
                       *  @param  __x  A %map of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but unlike the copy
                       *  constructor, the allocator object is not copied.
                       */
                      map&
                      operator=(const map& __x)
                      {
                	_M_t = __x._M_t;
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /// Move assignment operator.
                      map&
                      operator=(map&&) = default;
                
                      /**
                       *  @brief  %Map list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %map with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %map and
                       *  that the resulting %map's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      map&
                      operator=(initializer_list<value_type> __l)
                      {
                	_M_t._M_assign_unique(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_t.get_allocator()); }
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first pair in the
                       *  %map.
                       *  Iteration is done in ascending order according to the keys.
                       */
                      iterator
         102 ->       begin() _GLIBCXX_NOEXCEPT
                      { return _M_t.begin(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first pair
                       *  in the %map.  Iteration is done in ascending order according to the
                       *  keys.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return _M_t.begin(); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  pair in the %map.  Iteration is done in ascending order
                       *  according to the keys.
                       */
                      iterator
       13797 ->       end() _GLIBCXX_NOEXCEPT
                      { return _M_t.end(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  pair in the %map.  Iteration is done in ascending order according to
                       *  the keys.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return _M_t.end(); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last pair in
                       *  the %map.  Iteration is done in descending order according to the
                       *  keys.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return _M_t.rbegin(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to the
                       *  last pair in the %map.  Iteration is done in descending order
                       *  according to the keys.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return _M_t.rbegin(); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first pair in the %map.  Iteration is done in descending order
                       *  according to the keys.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return _M_t.rend(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to one
                       *  before the first pair in the %map.  Iteration is done in descending
                       *  order according to the keys.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return _M_t.rend(); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first pair
                       *  in the %map.  Iteration is done in ascending order according to the
                       *  keys.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return _M_t.begin(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  pair in the %map.  Iteration is done in ascending order according to
                       *  the keys.
                       */
                      const_iterator
                      cend() const noexcept
                      { return _M_t.end(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to the
                       *  last pair in the %map.  Iteration is done in descending order
                       *  according to the keys.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return _M_t.rbegin(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to one
                       *  before the first pair in the %map.  Iteration is done in descending
                       *  order according to the keys.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return _M_t.rend(); }
                #endif
                
                      // capacity
                      /** Returns true if the %map is empty.  (Thus begin() would equal
                       *  end().)
                      */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return _M_t.empty(); }
                
                      /** Returns the size of the %map.  */
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_t.size(); }
                
                      /** Returns the maximum size of the %map.  */
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _M_t.max_size(); }
                
                      // [23.3.1.2] element access
                      /**
                       *  @brief  Subscript ( @c [] ) access to %map data.
                       *  @param  __k  The key for which data should be retrieved.
                       *  @return  A reference to the data of the (key,data) %pair.
                       *
                       *  Allows for easy lookup with the subscript ( @c [] )
                       *  operator.  Returns data associated with the key specified in
                       *  subscript.  If the key does not exist, a pair with that key
                       *  is created using default values, which is then returned.
                       *
                       *  Lookup requires logarithmic time.
                       */
                      mapped_type&
        5993 ->       operator[](const key_type& __k)
                      {
                	// concept requirements
                	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)
                
                	iterator __i = lower_bound(__k);
                	// __i->first is greater than or equivalent to __k.
                	if (__i == end() || key_comp()(__k, (*__i).first))
                #if __cplusplus >= 201103L
                	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
                					    std::tuple<const key_type&>(__k),
                					    std::tuple<>());
                #else
                          __i = insert(__i, value_type(__k, mapped_type()));
                #endif
                	return (*__i).second;
                      }
                
                #if __cplusplus >= 201103L
                      mapped_type&
                      operator[](key_type&& __k)
                      {
                	// concept requirements
                	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)
                
                	iterator __i = lower_bound(__k);
                	// __i->first is greater than or equivalent to __k.
                	if (__i == end() || key_comp()(__k, (*__i).first))
                	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
                					std::forward_as_tuple(std::move(__k)),
                					std::tuple<>());
                	return (*__i).second;
                      }
                #endif
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      /**
                       *  @brief  Access to %map data.
                       *  @param  __k  The key for which data should be retrieved.
                       *  @return  A reference to the data whose key is equivalent to @a __k, if
                       *           such a data is present in the %map.
                       *  @throw  std::out_of_range  If no such data is present.
                       */
                      mapped_type&
                      at(const key_type& __k)
                      {
                	iterator __i = lower_bound(__k);
                	if (__i == end() || key_comp()(__k, (*__i).first))
                	  __throw_out_of_range(__N("map::at"));
                	return (*__i).second;
                      }
                
                      const mapped_type&
                      at(const key_type& __k) const
                      {
                	const_iterator __i = lower_bound(__k);
                	if (__i == end() || key_comp()(__k, (*__i).first))
                	  __throw_out_of_range(__N("map::at"));
                	return (*__i).second;
                      }
                
                      // modifiers
                #if __cplusplus >= 201103L
                      /**
                       *  @brief Attempts to build and insert a std::pair into the %map.
                       *
                       *  @param __args  Arguments used to generate a new pair instance (see
                       *	        std::piecewise_contruct for passing arguments to each
                       *	        part of the pair constructor).
                       *
                       *  @return  A pair, of which the first element is an iterator that points
                       *           to the possibly inserted pair, and the second is a bool that
                       *           is true if the pair was actually inserted.
                       *
                       *  This function attempts to build and insert a (key, value) %pair into
                       *  the %map.
                       *  A %map relies on unique keys and thus a %pair is only inserted if its
                       *  first element (the key) is not already present in the %map.
                       *
                       *  Insertion requires logarithmic time.
                       */
                      template<typename... _Args>
                	std::pair<iterator, bool>
          79 -> 	emplace(_Args&&... __args)
                	{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief Attempts to build and insert a std::pair into the %map.
                       *
                       *  @param  __pos  An iterator that serves as a hint as to where the pair
                       *                should be inserted.
                       *  @param  __args  Arguments used to generate a new pair instance (see
                       *	         std::piecewise_contruct for passing arguments to each
                       *	         part of the pair constructor).
                       *  @return An iterator that points to the element with key of the
                       *          std::pair built from @a __args (may or may not be that
                       *          std::pair).
                       *
                       *  This function is not concerned about whether the insertion took place,
                       *  and thus does not return a boolean like the single-argument emplace()
                       *  does.
                       *  Note that the first parameter is only a hint and can potentially
                       *  improve the performance of the insertion process. A bad hint would
                       *  cause no gains in efficiency.
                       *
                       *  See
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *  for more on @a hinting.
                       *
                       *  Insertion requires logarithmic time (if the hint is not taken).
                       */
                      template<typename... _Args>
                	iterator
                	emplace_hint(const_iterator __pos, _Args&&... __args)
                	{
                	  return _M_t._M_emplace_hint_unique(__pos,
                					     std::forward<_Args>(__args)...);
                	}
                #endif
                
                      /**
                       *  @brief Attempts to insert a std::pair into the %map.
                
                       *  @param __x Pair to be inserted (see std::make_pair for easy
                       *	     creation of pairs).
                       *
                       *  @return  A pair, of which the first element is an iterator that 
                       *           points to the possibly inserted pair, and the second is 
                       *           a bool that is true if the pair was actually inserted.
                       *
                       *  This function attempts to insert a (key, value) %pair into the %map.
                       *  A %map relies on unique keys and thus a %pair is only inserted if its
                       *  first element (the key) is not already present in the %map.
                       *
                       *  Insertion requires logarithmic time.
                       */
                      std::pair<iterator, bool>
                      insert(const value_type& __x)
                      { return _M_t._M_insert_unique(__x); }
                
                #if __cplusplus >= 201103L
                      template<typename _Pair, typename = typename
                	       std::enable_if<std::is_constructible<value_type,
                						    _Pair&&>::value>::type>
                        std::pair<iterator, bool>
                        insert(_Pair&& __x)
                        { return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief Attempts to insert a list of std::pairs into the %map.
                       *  @param  __list  A std::initializer_list<value_type> of pairs to be
                       *                  inserted.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      void
                      insert(std::initializer_list<value_type> __list)
                      { insert(__list.begin(), __list.end()); }
                #endif
                
                      /**
                       *  @brief Attempts to insert a std::pair into the %map.
                       *  @param  __position  An iterator that serves as a hint as to where the
                       *                    pair should be inserted.
                       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
                       *               of pairs).
                       *  @return An iterator that points to the element with key of
                       *           @a __x (may or may not be the %pair passed in).
                       *
                
                       *  This function is not concerned about whether the insertion
                       *  took place, and thus does not return a boolean like the
                       *  single-argument insert() does.  Note that the first
                       *  parameter is only a hint and can potentially improve the
                       *  performance of the insertion process.  A bad hint would
                       *  cause no gains in efficiency.
                       *
                       *  See
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *  for more on @a hinting.
                       *
                       *  Insertion requires logarithmic time (if the hint is not taken).
                       */
                      iterator
                #if __cplusplus >= 201103L
                      insert(const_iterator __position, const value_type& __x)
                #else
                      insert(iterator __position, const value_type& __x)
                #endif
                      { return _M_t._M_insert_unique_(__position, __x); }
                
                #if __cplusplus >= 201103L
                      template<typename _Pair, typename = typename
                	       std::enable_if<std::is_constructible<value_type,
                						    _Pair&&>::value>::type>
                        iterator
                        insert(const_iterator __position, _Pair&& __x)
                        { return _M_t._M_insert_unique_(__position,
                					std::forward<_Pair>(__x)); }
                #endif
                
                      /**
                       *  @brief Template function that attempts to insert a range of elements.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                   inserted.
                       *  @param  __last  Iterator pointing to the end of the range.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      template<typename _InputIterator>
                        void
                        insert(_InputIterator __first, _InputIterator __last)
                        { _M_t._M_insert_unique(__first, __last); }
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      /**
                       *  @brief Erases an element from a %map.
                       *  @param  __position  An iterator pointing to the element to be erased.
                       *  @return An iterator pointing to the element immediately following
                       *          @a position prior to the element being erased. If no such 
                       *          element exists, end() is returned.
                       *
                       *  This function erases an element, pointed to by the given
                       *  iterator, from a %map.  Note that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                      erase(const_iterator __position)
                      { return _M_t.erase(__position); }
                
                      // LWG 2059
                      _GLIBCXX_ABI_TAG_CXX11
                      iterator
       ##### ->       erase(iterator __position)
                      { return _M_t.erase(__position); }
                #else
                      /**
                       *  @brief Erases an element from a %map.
                       *  @param  __position  An iterator pointing to the element to be erased.
                       *
                       *  This function erases an element, pointed to by the given
                       *  iterator, from a %map.  Note that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      void
                      erase(iterator __position)
                      { _M_t.erase(__position); }
                #endif
                
                      /**
                       *  @brief Erases elements according to the provided key.
                       *  @param  __x  Key of element to be erased.
                       *  @return  The number of elements erased.
                       *
                       *  This function erases all the elements located by the given key from
                       *  a %map.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      size_type
                      erase(const key_type& __x)
                      { return _M_t.erase(__x); }
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      /**
                       *  @brief Erases a [first,last) range of elements from a %map.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                   erased.
                       *  @param __last Iterator pointing to the end of the range to
                       *                be erased.
                       *  @return The iterator @a __last.
                       *
                       *  This function erases a sequence of elements from a %map.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(const_iterator __first, const_iterator __last)
                      { return _M_t.erase(__first, __last); }
                #else
                      /**
                       *  @brief Erases a [__first,__last) range of elements from a %map.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                   erased.
                       *  @param __last Iterator pointing to the end of the range to
                       *                be erased.
                       *
                       *  This function erases a sequence of elements from a %map.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      void
                      erase(iterator __first, iterator __last)
                      { _M_t.erase(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Swaps data with another %map.
                       *  @param  __x  A %map of the same element and allocator types.
                       *
                       *  This exchanges the elements between two maps in constant
                       *  time.  (It is only swapping a pointer, an integer, and an
                       *  instance of the @c Compare type (which itself is often
                       *  stateless and empty), so it should be quite fast.)  Note
                       *  that the global std::swap() function is specialized such
                       *  that std::swap(m1,m2) will feed to this function.
                       */
                      void
                      swap(map& __x)
                #if __cplusplus >= 201103L
                      noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                      { _M_t.swap(__x._M_t); }
                
                      /**
                       *  Erases all elements in a %map.  Note that this function only
                       *  erases the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_t.clear(); }
                
                      // observers
                      /**
                       *  Returns the key comparison object out of which the %map was
                       *  constructed.
                       */
                      key_compare
        5589 ->       key_comp() const
                      { return _M_t.key_comp(); }
                
                      /**
                       *  Returns a value comparison object, built from the key comparison
                       *  object out of which the %map was constructed.
                       */
                      value_compare
                      value_comp() const
                      { return value_compare(_M_t.key_comp()); }
                
                      // [23.3.1.3] map operations
                
                      //@{
                      /**
                       *  @brief Tries to locate an element in a %map.
                       *  @param  __x  Key of (key, value) %pair to be located.
                       *  @return  Iterator pointing to sought-after element, or end() if not
                       *           found.
                       *
                       *  This function takes a key and tries to locate the element with which
                       *  the key matches.  If successful the function returns an iterator
                       *  pointing to the sought after %pair.  If unsuccessful it returns the
                       *  past-the-end ( @c end() ) iterator.
                       */
                
                      iterator
        8198 ->       find(const key_type& __x)
                      { return _M_t.find(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
                	{ return _M_t._M_find_tr(__x); }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief Tries to locate an element in a %map.
                       *  @param  __x  Key of (key, value) %pair to be located.
                       *  @return  Read-only (constant) iterator pointing to sought-after
                       *           element, or end() if not found.
                       *
                       *  This function takes a key and tries to locate the element with which
                       *  the key matches.  If successful the function returns a constant
                       *  iterator pointing to the sought after %pair. If unsuccessful it
                       *  returns the past-the-end ( @c end() ) iterator.
                       */
                
                      const_iterator
                      find(const key_type& __x) const
                      { return _M_t.find(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
                	{ return _M_t._M_find_tr(__x); }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief  Finds the number of elements with given key.
                       *  @param  __x  Key of (key, value) pairs to be located.
                       *  @return  Number of elements with specified key.
                       *
                       *  This function only makes sense for multimaps; for map the result will
                       *  either be 0 (not present) or 1 (present).
                       */
                      size_type
                      count(const key_type& __x) const
                      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
                	{ return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief Finds the beginning of a subsequence matching given key.
                       *  @param  __x  Key of (key, value) pair to be located.
                       *  @return  Iterator pointing to first element equal to or greater
                       *           than key, or end().
                       *
                       *  This function returns the first element of a subsequence of elements
                       *  that matches the given key.  If unsuccessful it returns an iterator
                       *  pointing to the first element that has a greater value than given key
                       *  or end() if no such element exists.
                       */
                      iterator
        6020 ->       lower_bound(const key_type& __x)
                      { return _M_t.lower_bound(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	lower_bound(const _Kt& __x)
                	-> decltype(_M_t._M_lower_bound_tr(__x))
                	{ return _M_t._M_lower_bound_tr(__x); }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief Finds the beginning of a subsequence matching given key.
                       *  @param  __x  Key of (key, value) pair to be located.
                       *  @return  Read-only (constant) iterator pointing to first element
                       *           equal to or greater than key, or end().
                       *
                       *  This function returns the first element of a subsequence of elements
                       *  that matches the given key.  If unsuccessful it returns an iterator
                       *  pointing to the first element that has a greater value than given key
                       *  or end() if no such element exists.
                       */
                      const_iterator
                      lower_bound(const key_type& __x) const
                      { return _M_t.lower_bound(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	lower_bound(const _Kt& __x) const
                	-> decltype(_M_t._M_lower_bound_tr(__x))
                	{ return _M_t._M_lower_bound_tr(__x); }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief Finds the end of a subsequence matching given key.
                       *  @param  __x  Key of (key, value) pair to be located.
                       *  @return Iterator pointing to the first element
                       *          greater than key, or end().
                       */
                      iterator
                      upper_bound(const key_type& __x)
                      { return _M_t.upper_bound(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	upper_bound(const _Kt& __x)
                	-> decltype(_M_t._M_upper_bound_tr(__x))
                	{ return _M_t._M_upper_bound_tr(__x); }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief Finds the end of a subsequence matching given key.
                       *  @param  __x  Key of (key, value) pair to be located.
                       *  @return  Read-only (constant) iterator pointing to first iterator
                       *           greater than key, or end().
                       */
                      const_iterator
                      upper_bound(const key_type& __x) const
                      { return _M_t.upper_bound(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	upper_bound(const _Kt& __x) const
                	-> decltype(_M_t._M_upper_bound_tr(__x))
                	{ return _M_t._M_upper_bound_tr(__x); }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief Finds a subsequence matching given key.
                       *  @param  __x  Key of (key, value) pairs to be located.
                       *  @return  Pair of iterators that possibly points to the subsequence
                       *           matching given key.
                       *
                       *  This function is equivalent to
                       *  @code
                       *    std::make_pair(c.lower_bound(val),
                       *                   c.upper_bound(val))
                       *  @endcode
                       *  (but is faster than making the calls separately).
                       *
                       *  This function probably only makes sense for multimaps.
                       */
                      std::pair<iterator, iterator>
                      equal_range(const key_type& __x)
                      { return _M_t.equal_range(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	equal_range(const _Kt& __x)
                	-> decltype(_M_t._M_equal_range_tr(__x))
                	{ return _M_t._M_equal_range_tr(__x); }
                #endif
                      //@}
                
                      //@{
                      /**
                       *  @brief Finds a subsequence matching given key.
                       *  @param  __x  Key of (key, value) pairs to be located.
                       *  @return  Pair of read-only (constant) iterators that possibly points
                       *           to the subsequence matching given key.
                       *
                       *  This function is equivalent to
                       *  @code
                       *    std::make_pair(c.lower_bound(val),
                       *                   c.upper_bound(val))
                       *  @endcode
                       *  (but is faster than making the calls separately).
                       *
                       *  This function probably only makes sense for multimaps.
                       */
                      std::pair<const_iterator, const_iterator>
                      equal_range(const key_type& __x) const
                      { return _M_t.equal_range(__x); }
                
                #if __cplusplus > 201103L
                      template<typename _Kt>
                	auto
                	equal_range(const _Kt& __x) const
                	-> decltype(_M_t._M_equal_range_tr(__x))
                	{ return _M_t._M_equal_range_tr(__x); }
                #endif
                      //@}
                
                      template<typename _K1, typename _T1, typename _C1, typename _A1>
                        friend bool
                        operator==(const map<_K1, _T1, _C1, _A1>&,
                		   const map<_K1, _T1, _C1, _A1>&);
                
                      template<typename _K1, typename _T1, typename _C1, typename _A1>
                        friend bool
                        operator<(const map<_K1, _T1, _C1, _A1>&,
                		  const map<_K1, _T1, _C1, _A1>&);
                    };
                
                  /**
                   *  @brief  Map equality comparison.
                   *  @param  __x  A %map.
                   *  @param  __y  A %map of the same type as @a x.
                   *  @return  True iff the size and elements of the maps are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  maps.  Maps are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return __x._M_t == __y._M_t; }
                
                  /**
                   *  @brief  Map ordering relation.
                   *  @param  __x  A %map.
                   *  @param  __y  A %map of the same type as @a x.
                   *  @return  True iff @a x is lexicographically less than @a y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  maps.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                              const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return __x._M_t < __y._M_t; }
                
                  /// Based on operator==
                  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                              const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::map::swap().
                  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline void
                    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
                	 map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif /* _STL_MAP_H */


Top 10 Lines:

     Line      Count

      356      13797
      845       8198
      915       6020
      474       5993
      818       5589
      162        108
      338        102
      558         79
       96         11

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

    39897   Total number of line executions
  3989.70   Average executions per line


*** File /usr/include/c++/5/tuple:
                // <tuple> -*- C++ -*-
                
                // Copyright (C) 2007-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/tuple
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_TUPLE
                #define _GLIBCXX_TUPLE 1
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else
                
                #include <utility>
                #include <array>
                #include <bits/uses_allocator.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
                    struct _Head_base;
                
                  template<std::size_t _Idx, typename _Head>
                    struct _Head_base<_Idx, _Head, true>
                    : public _Head
                    {
         106 ->       constexpr _Head_base()
                      : _Head() { }
                
         306 ->       constexpr _Head_base(const _Head& __h)
                      : _Head(__h) { }
                
                      constexpr _Head_base(const _Head_base&) = default;
                      constexpr _Head_base(_Head_base&&) = default;
                
                      template<typename _UHead>
       23247 ->         constexpr _Head_base(_UHead&& __h)
                	: _Head(std::forward<_UHead>(__h)) { }
                
                      _Head_base(allocator_arg_t, __uses_alloc0)
                      : _Head() { }
                
                      template<typename _Alloc>
                	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
                	: _Head(allocator_arg, *__a._M_a) { }
                
                      template<typename _Alloc>
                	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
                	: _Head(*__a._M_a) { }
                
                      template<typename _UHead>
                	_Head_base(__uses_alloc0, _UHead&& __uhead)
                	: _Head(std::forward<_UHead>(__uhead)) { }
                
                      template<typename _Alloc, typename _UHead>
                	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
                	: _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }
                
                      template<typename _Alloc, typename _UHead>
                	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
                	: _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }
                
                      static constexpr _Head&
       32251 ->       _M_head(_Head_base& __b) noexcept { return __b; }
                
                      static constexpr const _Head&
                      _M_head(const _Head_base& __b) noexcept { return __b; }
                    };
                
                  template<std::size_t _Idx, typename _Head>
                    struct _Head_base<_Idx, _Head, false>
                    {
         104 ->       constexpr _Head_base()
                      : _M_head_impl() { }
                
        4973 ->       constexpr _Head_base(const _Head& __h)
                      : _M_head_impl(__h) { }
                
                      constexpr _Head_base(const _Head_base&) = default;
                      constexpr _Head_base(_Head_base&&) = default;
                
                      template<typename _UHead>
       29340 ->         constexpr _Head_base(_UHead&& __h)
                	: _M_head_impl(std::forward<_UHead>(__h)) { }
                
                      _Head_base(allocator_arg_t, __uses_alloc0)
                      : _M_head_impl() { }
                
                      template<typename _Alloc>
                	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
                	: _M_head_impl(allocator_arg, *__a._M_a) { }
                
                      template<typename _Alloc>
                	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
                	: _M_head_impl(*__a._M_a) { }
                
                      template<typename _UHead>
                	_Head_base(__uses_alloc0, _UHead&& __uhead)
                	: _M_head_impl(std::forward<_UHead>(__uhead)) { }
                
                      template<typename _Alloc, typename _UHead>
                	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
                	: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
                	{ }
                
                      template<typename _Alloc, typename _UHead>
                	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
                	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
                
                      static constexpr _Head&
       67243 ->       _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
                
                      static constexpr const _Head&
       24134 ->       _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
                
                      _Head _M_head_impl;
                    };
                
                  /**
                   * Contains the actual implementation of the @c tuple template, stored
                   * as a recursive inheritance hierarchy from the first element (most
                   * derived class) to the last (least derived class). The @c Idx
                   * parameter gives the 0-based index of the element stored at this
                   * point in the hierarchy; we use it to implement a constant-time
                   * get() operation.
                   */
                  template<std::size_t _Idx, typename... _Elements>
                    struct _Tuple_impl; 
                
                  template<typename _Tp>
                    struct __is_empty_non_tuple : is_empty<_Tp> { };
                
                  // Using EBO for elements that are tuples causes ambiguous base errors.
                  template<typename _El0, typename... _El>
                    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };
                
                  // Use the Empty Base-class Optimization for empty, non-final types.
                  template<typename _Tp>
                    using __empty_not_final
                    = typename conditional<__is_final(_Tp), false_type,
                			   __is_empty_non_tuple<_Tp>>::type;
                
                  /**
                   * Recursive tuple implementation. Here we store the @c Head element
                   * and derive from a @c Tuple_impl containing the remaining elements
                   * (which contains the @c Tail).
                   */
                  template<std::size_t _Idx, typename _Head, typename... _Tail>
                    struct _Tuple_impl<_Idx, _Head, _Tail...>
                    : public _Tuple_impl<_Idx + 1, _Tail...>,
                      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
                    {
                      template<std::size_t, typename...> friend class _Tuple_impl;
                
                      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
                      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;
                
                      static constexpr _Head&  
       62452 ->       _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
                
                      static constexpr const _Head&
       24127 ->       _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
                
                      static constexpr _Inherited&
         718 ->       _M_tail(_Tuple_impl& __t) noexcept { return __t; }
                
                      static constexpr const _Inherited&
                      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }
                
         106 ->       constexpr _Tuple_impl()
                      : _Inherited(), _Base() { }
                
                      explicit 
         200 ->       constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
                      : _Inherited(__tail...), _Base(__head) { }
                
                      template<typename _UHead, typename... _UTail, typename = typename
                               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type> 
                        explicit
       28368 ->         constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
                	: _Inherited(std::forward<_UTail>(__tail)...),
                	  _Base(std::forward<_UHead>(__head)) { }
                
                      constexpr _Tuple_impl(const _Tuple_impl&) = default;
                
                      constexpr
         716 ->       _Tuple_impl(_Tuple_impl&& __in)
                      noexcept(__and_<is_nothrow_move_constructible<_Head>,
                	              is_nothrow_move_constructible<_Inherited>>::value)
                      : _Inherited(std::move(_M_tail(__in))), 
                	_Base(std::forward<_Head>(_M_head(__in))) { }
                
                      template<typename... _UElements>
                        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
                	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
                	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
                
                      template<typename _UHead, typename... _UTails>
                        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
                	: _Inherited(std::move
                		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
                	  _Base(std::forward<_UHead>
                		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }
                
                      template<typename _Alloc>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
                	: _Inherited(__tag, __a),
                          _Base(__tag, __use_alloc<_Head>(__a)) { }
                
                      template<typename _Alloc>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                		    const _Head& __head, const _Tail&... __tail)
                	: _Inherited(__tag, __a, __tail...),
                          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }
                
                      template<typename _Alloc, typename _UHead, typename... _UTail,
                               typename = typename enable_if<sizeof...(_Tail)
                					     == sizeof...(_UTail)>::type>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            _UHead&& __head, _UTail&&... __tail)
                	: _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
                          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                	        std::forward<_UHead>(__head)) { }
                
                      template<typename _Alloc>
                        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            const _Tuple_impl& __in)
                	: _Inherited(__tag, __a, _M_tail(__in)), 
                          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }
                
                      template<typename _Alloc>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            _Tuple_impl&& __in)
                	: _Inherited(__tag, __a, std::move(_M_tail(__in))), 
                	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                	        std::forward<_Head>(_M_head(__in))) { }
                
                      template<typename _Alloc, typename... _UElements>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            const _Tuple_impl<_Idx, _UElements...>& __in)
                	: _Inherited(__tag, __a,
                		     _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
                	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                		_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
                
                      template<typename _Alloc, typename _UHead, typename... _UTails>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
                	: _Inherited(__tag, __a, std::move
                		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
                	  _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                                std::forward<_UHead>
                		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }
                
                      _Tuple_impl&
                      operator=(const _Tuple_impl& __in)
                      {
                	_M_head(*this) = _M_head(__in);
                	_M_tail(*this) = _M_tail(__in);
                	return *this;
                      }
                
                      _Tuple_impl&
                      operator=(_Tuple_impl&& __in)
                      noexcept(__and_<is_nothrow_move_assignable<_Head>,
                	              is_nothrow_move_assignable<_Inherited>>::value)
                      {
                	_M_head(*this) = std::forward<_Head>(_M_head(__in));
                	_M_tail(*this) = std::move(_M_tail(__in));
                	return *this;
                      }
                
                      template<typename... _UElements>
                        _Tuple_impl&
                        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
                        {
                	  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
                	  _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
                	  return *this;
                	}
                
                      template<typename _UHead, typename... _UTails>
                        _Tuple_impl&
                        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
                        {
                	  _M_head(*this) = std::forward<_UHead>
                	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
                	  _M_tail(*this) = std::move
                	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
                	  return *this;
                	}
                
                    protected:
                      void
                      _M_swap(_Tuple_impl& __in)
                      noexcept(noexcept(swap(std::declval<_Head&>(),
                			     std::declval<_Head&>()))
                	       && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
                      {
                	using std::swap;
                	swap(_M_head(*this), _M_head(__in));
                	_Inherited::_M_swap(_M_tail(__in));
                      }
                    };
                
                  // Basis case of inheritance recursion.
                  template<std::size_t _Idx, typename _Head>
                    struct _Tuple_impl<_Idx, _Head>
                    : private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
                    {
                      template<std::size_t, typename...> friend class _Tuple_impl;
                
                      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;
                
                      static constexpr _Head&
       36831 ->       _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
                
                      static constexpr const _Head&
                      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
                
         106 ->       constexpr _Tuple_impl()
                      : _Base() { }
                
                      explicit
        2628 ->       constexpr _Tuple_impl(const _Head& __head)
                      : _Base(__head) { }
                
                      template<typename _UHead>
                        explicit
       25031 ->         constexpr _Tuple_impl(_UHead&& __head)
                	: _Base(std::forward<_UHead>(__head)) { }
                
                      constexpr _Tuple_impl(const _Tuple_impl&) = default;
                
                      constexpr
         798 ->       _Tuple_impl(_Tuple_impl&& __in)
                      noexcept(is_nothrow_move_constructible<_Head>::value)
                      : _Base(std::forward<_Head>(_M_head(__in))) { }
                
                      template<typename _UHead>
                        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
                	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }
                
                      template<typename _UHead>
                        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
                	: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
                	{ }
                
                      template<typename _Alloc>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
                	: _Base(__tag, __use_alloc<_Head>(__a)) { }
                
                      template<typename _Alloc>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                		    const _Head& __head)
                	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }
                
                      template<typename _Alloc, typename _UHead>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            _UHead&& __head)
                	: _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                	        std::forward<_UHead>(__head)) { }
                
                      template<typename _Alloc>
                        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            const _Tuple_impl& __in)
                	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }
                
                      template<typename _Alloc>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            _Tuple_impl&& __in)
                	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                	        std::forward<_Head>(_M_head(__in))) { }
                
                      template<typename _Alloc, typename _UHead>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            const _Tuple_impl<_Idx, _UHead>& __in)
                	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                		_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }
                
                      template<typename _Alloc, typename _UHead>
                	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                	            _Tuple_impl<_Idx, _UHead>&& __in)
                	: _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
                	{ }
                
                      _Tuple_impl&
                      operator=(const _Tuple_impl& __in)
                      {
                	_M_head(*this) = _M_head(__in);
                	return *this;
                      }
                
                      _Tuple_impl&
                      operator=(_Tuple_impl&& __in)
                      noexcept(is_nothrow_move_assignable<_Head>::value)
                      {
                	_M_head(*this) = std::forward<_Head>(_M_head(__in));
                	return *this;
                      }
                
                      template<typename _UHead>
                        _Tuple_impl&
                        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
                        {
                	  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
                	  return *this;
                	}
                
                      template<typename _UHead>
                        _Tuple_impl&
                        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
                        {
                	  _M_head(*this)
                	    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
                	  return *this;
                	}
                
                    protected:
                      void
                      _M_swap(_Tuple_impl& __in)
                      noexcept(noexcept(swap(std::declval<_Head&>(), std::declval<_Head&>())))
                      {
                	using std::swap;
                	swap(_M_head(*this), _M_head(__in));
                      }
                    };
                
                  /// Primary class template, tuple
                  template<typename... _Elements> 
                    class tuple : public _Tuple_impl<0, _Elements...>
                    {
                      typedef _Tuple_impl<0, _Elements...> _Inherited;
                
                    public:
                      constexpr tuple()
                      : _Inherited() { }
                
                      explicit
         119 ->       constexpr tuple(const _Elements&... __elements)
                      : _Inherited(__elements...) { }
                
                      template<typename... _UElements, typename = typename
                        enable_if<__and_<is_convertible<_UElements,
                					_Elements>...>::value>::type>
                	explicit
        4546 ->         constexpr tuple(_UElements&&... __elements)
                	: _Inherited(std::forward<_UElements>(__elements)...) {	}
                
                      constexpr tuple(const tuple&) = default;
                
         571 ->       constexpr tuple(tuple&&) = default; 
                
                      template<typename... _UElements, typename = typename
                        enable_if<__and_<is_convertible<const _UElements&,
                					_Elements>...>::value>::type>
                        constexpr tuple(const tuple<_UElements...>& __in)
                        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
                        { }
                
                      template<typename... _UElements, typename = typename
                        enable_if<__and_<is_convertible<_UElements,
                					_Elements>...>::value>::type>
                        constexpr tuple(tuple<_UElements...>&& __in)
                        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }
                
                      // Allocator-extended constructors.
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a)
                	: _Inherited(__tag, __a) { }
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a,
                	      const _Elements&... __elements)
                	: _Inherited(__tag, __a, __elements...) { }
                
                      template<typename _Alloc, typename... _UElements, typename = typename
                	       enable_if<sizeof...(_UElements)
                			 == sizeof...(_Elements)>::type>
                	tuple(allocator_arg_t __tag, const _Alloc& __a,
                	      _UElements&&... __elements)
                	: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
                       	{ }
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
                	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
                	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
                
                      template<typename _Alloc, typename... _UElements, typename = typename
                	       enable_if<sizeof...(_UElements)
                			 == sizeof...(_Elements)>::type>
                	tuple(allocator_arg_t __tag, const _Alloc& __a,
                	      const tuple<_UElements...>& __in)
                	: _Inherited(__tag, __a,
                	             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
                	{ }
                
                      template<typename _Alloc, typename... _UElements, typename = typename
                	       enable_if<sizeof...(_UElements)
                			 == sizeof...(_Elements)>::type>
                	tuple(allocator_arg_t __tag, const _Alloc& __a,
                	      tuple<_UElements...>&& __in)
                	: _Inherited(__tag, __a,
                	             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
                	{ }
                
                      tuple&
                      operator=(const tuple& __in)
                      {
                	static_cast<_Inherited&>(*this) = __in;
                	return *this;
                      }
                
                      tuple&
                      operator=(tuple&& __in)
                      noexcept(is_nothrow_move_assignable<_Inherited>::value)
                      {
                	static_cast<_Inherited&>(*this) = std::move(__in);
                	return *this;
                      }
                
                      template<typename... _UElements, typename = typename
                	       enable_if<sizeof...(_UElements)
                			 == sizeof...(_Elements)>::type>
                        tuple&
                        operator=(const tuple<_UElements...>& __in)
                        {
                	  static_cast<_Inherited&>(*this) = __in;
                	  return *this;
                	}
                
                      template<typename... _UElements, typename = typename
                	       enable_if<sizeof...(_UElements)
                			 == sizeof...(_Elements)>::type>
                        tuple&
                        operator=(tuple<_UElements...>&& __in)
                        {
                	  static_cast<_Inherited&>(*this) = std::move(__in);
                	  return *this;
                	}
                
                      void
                      swap(tuple& __in)
                      noexcept(noexcept(__in._M_swap(__in)))
                      { _Inherited::_M_swap(__in); }
                    };
                
                  // Explicit specialization, zero-element tuple.
                  template<>  
                    class tuple<>
                    {
                    public:
                      void swap(tuple&) noexcept { /* no-op */ }
                    };
                
                  /// Partial specialization, 2-element tuple.
                  /// Includes construction and assignment from a pair.
                  template<typename _T1, typename _T2>
                    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
                    {
                      typedef _Tuple_impl<0, _T1, _T2> _Inherited;
                
                    public:
         104 ->       constexpr tuple()
                      : _Inherited() { }
                
                      explicit
                      constexpr tuple(const _T1& __a1, const _T2& __a2)
                      : _Inherited(__a1, __a2) { }
                
                      template<typename _U1, typename _U2, typename = typename
                	       enable_if<__and_<is_convertible<_U1, _T1>,
                				is_convertible<_U2, _T2>>::value>::type>
                        explicit
       22819 ->         constexpr tuple(_U1&& __a1, _U2&& __a2)
                	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
                
                      constexpr tuple(const tuple&) = default;
                
         217 ->       constexpr tuple(tuple&&) = default;
                
                      template<typename _U1, typename _U2, typename = typename
                	enable_if<__and_<is_convertible<const _U1&, _T1>,
                			 is_convertible<const _U2&, _T2>>::value>::type>
                        constexpr tuple(const tuple<_U1, _U2>& __in)
                	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }
                
                      template<typename _U1, typename _U2, typename = typename
                	       enable_if<__and_<is_convertible<_U1, _T1>,
                				is_convertible<_U2, _T2>>::value>::type>
                        constexpr tuple(tuple<_U1, _U2>&& __in)
                	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }
                
                      template<typename _U1, typename _U2, typename = typename
                	enable_if<__and_<is_convertible<const _U1&, _T1>,
                			 is_convertible<const _U2&, _T2>>::value>::type>
                        constexpr tuple(const pair<_U1, _U2>& __in)
                	: _Inherited(__in.first, __in.second) { }
                
                      template<typename _U1, typename _U2, typename = typename
                	       enable_if<__and_<is_convertible<_U1, _T1>,
                				is_convertible<_U2, _T2>>::value>::type>
                        constexpr tuple(pair<_U1, _U2>&& __in)
                	: _Inherited(std::forward<_U1>(__in.first),
                		     std::forward<_U2>(__in.second)) { }
                
                      // Allocator-extended constructors.
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a)
                	: _Inherited(__tag, __a) { }
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a,
                	      const _T1& __a1, const _T2& __a2)
                	: _Inherited(__tag, __a, __a1, __a2) { }
                
                      template<typename _Alloc, typename _U1, typename _U2>
                	tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
                	: _Inherited(__tag, __a, std::forward<_U1>(__a1),
                	             std::forward<_U2>(__a2)) { }
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
                	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
                
                      template<typename _Alloc>
                	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
                	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
                
                      template<typename _Alloc, typename _U1, typename _U2>
                	tuple(allocator_arg_t __tag, const _Alloc& __a,
                	      const tuple<_U1, _U2>& __in)
                	: _Inherited(__tag, __a,
                	             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
                	{ }
                
                      template<typename _Alloc, typename _U1, typename _U2>
                	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
                	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
                	{ }
                
                      template<typename _Alloc, typename _U1, typename _U2>
                        tuple(allocator_arg_t __tag, const _Alloc& __a,
                	      const pair<_U1, _U2>& __in)
                	: _Inherited(__tag, __a, __in.first, __in.second) { }
                
                      template<typename _Alloc, typename _U1, typename _U2>
                        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
                	: _Inherited(__tag, __a, std::forward<_U1>(__in.first),
                		     std::forward<_U2>(__in.second)) { }
                
                      tuple&
                      operator=(const tuple& __in)
                      {
                	static_cast<_Inherited&>(*this) = __in;
                	return *this;
                      }
                
                      tuple&
                      operator=(tuple&& __in)
                      noexcept(is_nothrow_move_assignable<_Inherited>::value)
                      {
                	static_cast<_Inherited&>(*this) = std::move(__in);
                	return *this;
                      }
                
                      template<typename _U1, typename _U2>
                        tuple&
                        operator=(const tuple<_U1, _U2>& __in)
                        {
                	  static_cast<_Inherited&>(*this) = __in;
                	  return *this;
                	}
                
                      template<typename _U1, typename _U2>
                        tuple&
                        operator=(tuple<_U1, _U2>&& __in)
                        {
                	  static_cast<_Inherited&>(*this) = std::move(__in);
                	  return *this;
                	}
                
                      template<typename _U1, typename _U2>
                        tuple&
                        operator=(const pair<_U1, _U2>& __in)
                        {
                	  this->_M_head(*this) = __in.first;
                	  this->_M_tail(*this)._M_head(*this) = __in.second;
                	  return *this;
                	}
                
                      template<typename _U1, typename _U2>
                        tuple&
                        operator=(pair<_U1, _U2>&& __in)
                        {
                	  this->_M_head(*this) = std::forward<_U1>(__in.first);
                	  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
                	  return *this;
                	}
                
                      void
                      swap(tuple& __in)
                      noexcept(noexcept(__in._M_swap(__in)))
                      { _Inherited::_M_swap(__in); }
                    };
                
                
                  /// Gives the type of the ith element of a given tuple type.
                  template<std::size_t __i, typename _Tp>
                    struct tuple_element;
                
                  /**
                   * Recursive case for tuple_element: strip off the first element in
                   * the tuple and retrieve the (i-1)th element of the remaining tuple.
                   */
                  template<std::size_t __i, typename _Head, typename... _Tail>
                    struct tuple_element<__i, tuple<_Head, _Tail...> >
                    : tuple_element<__i - 1, tuple<_Tail...> > { };
                
                  /**
                   * Basis case for tuple_element: The first element is the one we're seeking.
                   */
                  template<typename _Head, typename... _Tail>
                    struct tuple_element<0, tuple<_Head, _Tail...> >
                    {
                      typedef _Head type;
                    };
                
                  // Duplicate of C++14's tuple_element_t for internal use in C++11 mode
                  template<std::size_t __i, typename _Tp>
                    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;
                
                  template<std::size_t __i, typename _Tp>
                    struct tuple_element<__i, const _Tp>
                    {
                      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
                    };
                
                  template<std::size_t __i, typename _Tp>
                    struct tuple_element<__i, volatile _Tp>
                    {
                      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
                    };
                
                  template<std::size_t __i, typename _Tp>
                    struct tuple_element<__i, const volatile _Tp>
                    {
                      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
                    };
                
                #if __cplusplus > 201103L
                #define __cpp_lib_tuple_element_t 201402
                
                  template<std::size_t __i, typename _Tp>
                    using tuple_element_t = typename tuple_element<__i, _Tp>::type;
                #endif
                
                  /// Finds the size of a given tuple type.
                  template<typename _Tp>
                    struct tuple_size;
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2313. tuple_size should always derive from integral_constant<size_t, N>
                  template<typename _Tp>
                    struct tuple_size<const _Tp>
                    : integral_constant<size_t, tuple_size<_Tp>::value> { };
                
                  template<typename _Tp>
                    struct tuple_size<volatile _Tp>
                    : integral_constant<size_t, tuple_size<_Tp>::value> { };
                
                  template<typename _Tp>
                    struct tuple_size<const volatile _Tp>
                    : integral_constant<size_t, tuple_size<_Tp>::value> { };
                
                  /// class tuple_size
                  template<typename... _Elements>
                    struct tuple_size<tuple<_Elements...>>
                    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
                
                  template<std::size_t __i, typename _Head, typename... _Tail>
                    constexpr _Head&
       97807 ->     __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
                    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
                
                  template<std::size_t __i, typename _Head, typename... _Tail>
                    constexpr const _Head&
       24228 ->     __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
                    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
                
                  /// Return a reference to the ith element of a tuple.
                  template<std::size_t __i, typename... _Elements>
                    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
       98500 ->     get(tuple<_Elements...>& __t) noexcept
                    { return std::__get_helper<__i>(__t); }
                
                  /// Return a const reference to the ith element of a const tuple.
                  template<std::size_t __i, typename... _Elements>
                    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
       24411 ->     get(const tuple<_Elements...>& __t) noexcept
                    { return std::__get_helper<__i>(__t); }
                
                  /// Return an rvalue reference to the ith element of a tuple rvalue.
                  template<std::size_t __i, typename... _Elements>
                    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
                    get(tuple<_Elements...>&& __t) noexcept
                    {
                      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
                      return std::forward<__element_type&&>(std::get<__i>(__t));
                    }
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_tuples_by_type 201304
                
                  template<typename _Head, size_t __i, typename... _Tail>
                    constexpr _Head&
                    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
                    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
                
                  template<typename _Head, size_t __i, typename... _Tail>
                    constexpr const _Head&
                    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
                    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
                
                  /// Return a reference to the unique element of type _Tp of a tuple.
                  template <typename _Tp, typename... _Types>
                    constexpr _Tp&
                    get(tuple<_Types...>& __t) noexcept
                    { return std::__get_helper2<_Tp>(__t); }
                
                  /// Return a reference to the unique element of type _Tp of a tuple rvalue.
                  template <typename _Tp, typename... _Types>
                    constexpr _Tp&&
                    get(tuple<_Types...>&& __t) noexcept
                    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }
                
                  /// Return a const reference to the unique element of type _Tp of a tuple.
                  template <typename _Tp, typename... _Types>
                    constexpr const _Tp&
                    get(const tuple<_Types...>& __t) noexcept
                    { return std::__get_helper2<_Tp>(__t); }
                #endif
                
                  // This class performs the comparison operations on tuples
                  template<typename _Tp, typename _Up, size_t __i, size_t __size>
                    struct __tuple_compare
                    {
                      static constexpr bool
                      __eq(const _Tp& __t, const _Up& __u)
                      {
                	return bool(std::get<__i>(__t) == std::get<__i>(__u))
                	  && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
                      }
                   
                      static constexpr bool
                      __less(const _Tp& __t, const _Up& __u)
                      {
                	return bool(std::get<__i>(__t) < std::get<__i>(__u))
                	  || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
                	      && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
                      }
                    };
                
                  template<typename _Tp, typename _Up, size_t __size>
                    struct __tuple_compare<_Tp, _Up, __size, __size>
                    {
                      static constexpr bool
                      __eq(const _Tp&, const _Up&) { return true; }
                   
                      static constexpr bool
                      __less(const _Tp&, const _Up&) { return false; }
                    };
                
                  template<typename... _TElements, typename... _UElements>
                    constexpr bool
                    operator==(const tuple<_TElements...>& __t,
                	       const tuple<_UElements...>& __u)
                    {
                      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
                	  "tuple objects can only be compared if they have equal sizes.");
                      using __compare = __tuple_compare<tuple<_TElements...>,
                					tuple<_UElements...>,
                					0, sizeof...(_TElements)>;
                      return __compare::__eq(__t, __u);
                    }
                
                  template<typename... _TElements, typename... _UElements>
                    constexpr bool
                    operator<(const tuple<_TElements...>& __t,
                	      const tuple<_UElements...>& __u)
                    {
                      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
                	  "tuple objects can only be compared if they have equal sizes.");
                      using __compare = __tuple_compare<tuple<_TElements...>,
                					tuple<_UElements...>,
                					0, sizeof...(_TElements)>;
                      return __compare::__less(__t, __u);
                    }
                
                  template<typename... _TElements, typename... _UElements>
                    constexpr bool
                    operator!=(const tuple<_TElements...>& __t,
                	       const tuple<_UElements...>& __u)
                    { return !(__t == __u); }
                
                  template<typename... _TElements, typename... _UElements>
                    constexpr bool
                    operator>(const tuple<_TElements...>& __t,
                	      const tuple<_UElements...>& __u)
                    { return __u < __t; }
                
                  template<typename... _TElements, typename... _UElements>
                    constexpr bool
                    operator<=(const tuple<_TElements...>& __t,
                	       const tuple<_UElements...>& __u)
                    { return !(__u < __t); }
                
                  template<typename... _TElements, typename... _UElements>
                    constexpr bool
                    operator>=(const tuple<_TElements...>& __t,
                	       const tuple<_UElements...>& __u)
                    { return !(__t < __u); }
                
                  // NB: DR 705.
                  template<typename... _Elements>
                    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
                    make_tuple(_Elements&&... __args)
                    {
                      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
                	__result_type;
                      return __result_type(std::forward<_Elements>(__args)...);
                    }
                
                  template<typename... _Elements>
                    tuple<_Elements&&...>
        8506 ->     forward_as_tuple(_Elements&&... __args) noexcept
                    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }
                
                  template<typename>
                    struct __is_tuple_like_impl : false_type
                    { };
                
                  template<typename... _Tps>
                    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
                    { };
                
                  template<typename _T1, typename _T2>
                    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
                    { };
                
                  template<typename _Tp, std::size_t _Nm>
                    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
                    { };
                
                  // Internal type trait that allows us to sfinae-protect tuple_cat.
                  template<typename _Tp>
                    struct __is_tuple_like
                    : public __is_tuple_like_impl<typename std::remove_cv
                            <typename std::remove_reference<_Tp>::type>::type>::type
                    { };
                
                  template<size_t, typename, typename, size_t>
                    struct __make_tuple_impl;
                
                  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
                    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
                    : __make_tuple_impl<_Idx + 1,
                			tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
                			_Tuple, _Nm>
                    { };
                
                  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
                    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
                    {
                      typedef tuple<_Tp...> __type;
                    };
                
                  template<typename _Tuple>
                    struct __do_make_tuple
                    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
                    { };
                
                  // Returns the std::tuple equivalent of a tuple-like type.
                  template<typename _Tuple>
                    struct __make_tuple
                    : public __do_make_tuple<typename std::remove_cv
                            <typename std::remove_reference<_Tuple>::type>::type>
                    { };
                
                  // Combines several std::tuple's into a single one.
                  template<typename...>
                    struct __combine_tuples;
                
                  template<>
                    struct __combine_tuples<>
                    {
                      typedef tuple<> __type;
                    };
                
                  template<typename... _Ts>
                    struct __combine_tuples<tuple<_Ts...>>
                    {
                      typedef tuple<_Ts...> __type;
                    };
                
                  template<typename... _T1s, typename... _T2s, typename... _Rem>
                    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
                    {
                      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
                					_Rem...>::__type __type;
                    };
                
                  // Computes the result type of tuple_cat given a set of tuple-like types.
                  template<typename... _Tpls>
                    struct __tuple_cat_result
                    {
                      typedef typename __combine_tuples
                        <typename __make_tuple<_Tpls>::__type...>::__type __type;
                    };
                
                  // Helper to determine the index set for the first tuple-like
                  // type of a given set.
                  template<typename...>
                    struct __make_1st_indices;
                
                  template<>
                    struct __make_1st_indices<>
                    {
                      typedef std::_Index_tuple<> __type;
                    };
                
                  template<typename _Tp, typename... _Tpls>
                    struct __make_1st_indices<_Tp, _Tpls...>
                    {
                      typedef typename std::_Build_index_tuple<std::tuple_size<
                	typename std::remove_reference<_Tp>::type>::value>::__type __type;
                    };
                
                  // Performs the actual concatenation by step-wise expanding tuple-like
                  // objects into the elements,  which are finally forwarded into the
                  // result tuple.
                  template<typename _Ret, typename _Indices, typename... _Tpls>
                    struct __tuple_concater;
                
                  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
                    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
                    {
                      template<typename... _Us>
                        static constexpr _Ret
                        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
                        {
                	  typedef typename __make_1st_indices<_Tpls...>::__type __idx;
                	  typedef __tuple_concater<_Ret, __idx, _Tpls...>      __next;
                	  return __next::_S_do(std::forward<_Tpls>(__tps)...,
                			       std::forward<_Us>(__us)...,
                			       std::get<_Is>(std::forward<_Tp>(__tp))...);
                	}
                    };
                
                  template<typename _Ret>
                    struct __tuple_concater<_Ret, std::_Index_tuple<>>
                    {
                      template<typename... _Us>
                	static constexpr _Ret
                	_S_do(_Us&&... __us)
                        {
                	  return _Ret(std::forward<_Us>(__us)...);
                	}
                    };
                
                  /// tuple_cat
                  template<typename... _Tpls, typename = typename
                           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
                    constexpr auto
                    tuple_cat(_Tpls&&... __tpls)
                    -> typename __tuple_cat_result<_Tpls...>::__type
                    {
                      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
                      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
                      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
                      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
                    }
                
                  /// tie
                  template<typename... _Elements>
                    inline tuple<_Elements&...>
                    tie(_Elements&... __args) noexcept
                    { return tuple<_Elements&...>(__args...); }
                
                  /// swap
                  template<typename... _Elements>
                    inline void 
                    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                  // A class (and instance) which can be used in 'tie' when an element
                  // of a tuple is not required
                  struct _Swallow_assign
                  {
                    template<class _Tp>
                      const _Swallow_assign&
                      operator=(const _Tp&) const
                      { return *this; }
                  };
                
                  const _Swallow_assign ignore{};
                
                  /// Partial specialization for tuples
                  template<typename... _Types, typename _Alloc>
                    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
                
                  // See stl_pair.h...
                  template<class _T1, class _T2>
                    template<typename... _Args1, typename... _Args2>
                      inline
         172 ->       pair<_T1, _T2>::
                      pair(piecewise_construct_t,
                	   tuple<_Args1...> __first, tuple<_Args2...> __second)
                      : pair(__first, __second,
                	     typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
                	     typename _Build_index_tuple<sizeof...(_Args2)>::__type())
                      { }
                
                  template<class _T1, class _T2>
                    template<typename... _Args1, std::size_t... _Indexes1,
                             typename... _Args2, std::size_t... _Indexes2>
                      inline
         173 ->       pair<_T1, _T2>::
                      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
                	   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
                      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
                        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
                      { }
                
                  /// @}
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif // _GLIBCXX_TUPLE


Top 10 Lines:

     Line      Count

      832      98500
      821      97807
      142      67243
      190      62452
      347      36831
       95      32251
      114      29340
      211      28368
      361      25031
      838      24411

Execution Summary:

       34   Executable lines in this file
       34   Lines executed
   100.00   Percent of the file executed

   645958   Total number of line executions
 18998.76   Average executions per line


*** File /usr/include/c++/5/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <bits/c++config.h>
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  using std::size_t;
                  using std::ptrdiff_t;
                
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard. 
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef new_allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. propagate_on_container_move_assignment
                      typedef std::true_type propagate_on_container_move_assignment;
                #endif
                
        2123 ->       new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
        1199 ->       new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                
                      template<typename _Tp1>
                        new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                
        2394 ->       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      pointer
                      address(reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      const_pointer
                      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      pointer
        1723 ->       allocate(size_type __n, const void* = 0)
                      { 
                	if (__n > this->max_size())
                	  std::__throw_bad_alloc();
                
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
         934 ->       deallocate(pointer __p, size_type)
                      { ::operator delete(__p); }
                
                      size_type
        1966 ->       max_size() const _GLIBCXX_USE_NOEXCEPT
                      { return size_t(-1) / sizeof(_Tp); }
                
                #if __cplusplus >= 201103L
                      template<typename _Up, typename... _Args>
                        void
       10750 ->         construct(_Up* __p, _Args&&... __args)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                        void 
        7450 ->         destroy(_Up* __p) { __p->~_Up(); }
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void 
                      construct(pointer __p, const _Tp& __val) 
                      { ::new((void *)__p) _Tp(__val); }
                
                      void 
                      destroy(pointer __p) { __p->~_Tp(); }
                #endif
                    };
                
                  template<typename _Tp>
                    inline bool
                    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return true; }
                  
                  template<typename _Tp>
                    inline bool
                    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return false; }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      119      10750
      124       7450
       86       2394
       79       2123
      113       1966
       99       1723
       81       1199
      109        934

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

    28539   Total number of line executions
  3567.38   Average executions per line


*** File /home/sbillah/dmclock/support/src/run_every.cc:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #include <iostream>
                
                #include "run_every.h"
                
                
                // can define ADD_MOVE_SEMANTICS, although not fully debugged and tested
                
                
                namespace chrono = std::chrono;
                
                
                #ifdef ADD_MOVE_SEMANTICS
                crimson::RunEvery::RunEvery()
                {
                  // empty
                }
                
                
                crimson::RunEvery& crimson::RunEvery::operator=(crimson::RunEvery&& other)
                {
                  // finish run every thread
                  {
                    Guard g(mtx);
                    finishing = true;
                    cv.notify_one();
                  }
                  if (thd.joinable()) {
                    thd.join();
                  }
                
                  // transfer info over from previous thread
                  finishing.store(other.finishing);
                  wait_period = other.wait_period;
                  body = other.body;
                
                  // finish other thread
                  other.finishing.store(true);
                  other.cv.notify_one();
                
                  // start this thread
                  thd = std::thread(&RunEvery::run, this);
                
                  return *this;
                }
                #endif
                
                
          10 -> crimson::RunEvery::~RunEvery() {
                  finishing = true;
                  cv.notify_all();
                  thd.join();
                }
                
                
          45 -> void crimson::RunEvery::run() {
                  Lock l(mtx);
                  while(!finishing) {
                    TimePoint until = chrono::steady_clock::now() + wait_period;
                    while (!finishing && chrono::steady_clock::now() < until) {
                      cv.wait_until(l, until);
                    }
                    if (!finishing) {
                      body();
                    }
                  }
           2 -> }


Top 10 Lines:

     Line      Count

       62         45
       55         10
       73          2

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

       57   Total number of line executions
    19.00   Average executions per line


*** File /usr/include/c++/5/bits/move.h:
                // Move, forward and identity for C++0x + swap -*- C++ -*-
                
                // Copyright (C) 2007-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/move.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _MOVE_H
                #define _MOVE_H 1
                
                #include <bits/c++config.h>
                #include <bits/concept_check.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Used, in C++03 mode too, by allocators, etc.
                  /**
                   *  @brief Same as C++11 std::addressof
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    inline _Tp*
       21810 ->     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                    {
                      return reinterpret_cast<_Tp*>
                	(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                #include <type_traits> // Brings in std::declval too.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief  Forward an lvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
      411845 ->     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                    { return static_cast<_Tp&&>(__t); }
                
                  /**
                   *  @brief  Forward an rvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                    {
                      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                		    " substituting _Tp is an lvalue reference type");
                      return static_cast<_Tp&&>(__t);
                    }
                
                  /**
                   *  @brief  Convert a value to an rvalue.
                   *  @param  __t  A thing of arbitrary type.
                   *  @return The parameter cast to an rvalue-reference to allow moving it.
                  */
                  template<typename _Tp>
                    constexpr typename std::remove_reference<_Tp>::type&&
       70536 ->     move(_Tp&& __t) noexcept
                    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                
                
                  template<typename _Tp>
                    struct __move_if_noexcept_cond
                    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                                    is_copy_constructible<_Tp>>::type { };
                
                  /**
                   *  @brief  Conditionally convert a value to an rvalue.
                   *  @param  __x  A thing of arbitrary type.
                   *  @return The parameter, possibly cast to an rvalue-reference.
                   *
                   *  Same as std::move unless the type's move constructor could throw and the
                   *  type is copyable, in which case an lvalue-reference is returned instead.
                   */
                  template<typename _Tp>
                    constexpr typename
                    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                    move_if_noexcept(_Tp& __x) noexcept
                    { return std::move(__x); }
                
                  // declval, from type_traits.
                
                  /**
                   *  @brief Returns the actual address of the object or function
                   *         referenced by r, even in the presence of an overloaded
                   *         operator&.
                   *  @param  __r  Reference to an object or function.
                   *  @return   The actual address.
                  */
                  template<typename _Tp>
                    inline _Tp*
                    addressof(_Tp& __r) noexcept
                    { return std::__addressof(__r); }
                
                  // C++11 version of std::exchange for internal use.
                  template <typename _Tp, typename _Up = _Tp>
                    inline _Tp
                    __exchange(_Tp& __obj, _Up&& __new_val)
                    {
                      _Tp __old_val = std::move(__obj);
                      __obj = std::forward<_Up>(__new_val);
                      return __old_val;
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #define _GLIBCXX_MOVE(__val) std::move(__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                #else
                #define _GLIBCXX_MOVE(__val) (__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   Nothing.
                  */
                  template<typename _Tp>
                    inline void
        2488 ->     swap(_Tp& __a, _Tp& __b)
                #if __cplusplus >= 201103L
                    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                	            is_nothrow_move_assignable<_Tp>>::value)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                
                      _Tp __tmp = _GLIBCXX_MOVE(__a);
                      __a = _GLIBCXX_MOVE(__b);
                      __b = _GLIBCXX_MOVE(__tmp);
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 809. std::swap should be overloaded for array types.
                  /// Swap the contents of two arrays.
                  template<typename _Tp, size_t _Nm>
                    inline void
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                #if __cplusplus >= 201103L
                    noexcept(noexcept(swap(*__a, *__b)))
                #endif
                    {
                      for (size_t __n = 0; __n < _Nm; ++__n)
                	swap(__a[__n], __b[__n]);
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _MOVE_H */


Top 10 Lines:

     Line      Count

       76     411845
      101      70536
       47      21810
      176       2488

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

   506679   Total number of line executions
126669.75   Average executions per line


*** File /usr/include/c++/5/functional:
                // <functional> -*- C++ -*-
                
                // Copyright (C) 2001-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 */
                
                /** @file include/functional
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_FUNCTIONAL
                #define _GLIBCXX_FUNCTIONAL 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/stl_function.h>
                
                #if __cplusplus >= 201103L
                
                #include <typeinfo>
                #include <new>
                #include <tuple>
                #include <type_traits>
                #include <bits/functexcept.h>
                #include <bits/functional_hash.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _MemberPointer>
                    class _Mem_fn;
                  template<typename _Tp, typename _Class>
                    _Mem_fn<_Tp _Class::*>
                    mem_fn(_Tp _Class::*) noexcept;
                
                  /// If we have found a result_type, extract it.
                  template<typename _Functor, typename = __void_t<>>
                    struct _Maybe_get_result_type
                    { };
                
                  template<typename _Functor>
         621 ->     struct _Maybe_get_result_type<_Functor,
                				  __void_t<typename _Functor::result_type>>
                    { typedef typename _Functor::result_type result_type; };
                
                  /**
                   *  Base class for any function object that has a weak result type, as
                   *  defined in 20.8.2 [func.require] of C++11.
                  */
                  template<typename _Functor>
         622 ->     struct _Weak_result_type_impl
                    : _Maybe_get_result_type<_Functor>
                    { };
                
                  /// Retrieve the result type for a function type.
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
                    { typedef _Res result_type; };
                
                  /// Retrieve the result type for a function reference.
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
                    { typedef _Res result_type; };
                
                  /// Retrieve the result type for a function pointer.
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
                    { typedef _Res result_type; };
                
                  /// Retrieve result type for a member function pointer.
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
                    { typedef _Res result_type; };
                
                  /// Retrieve result type for a const member function pointer.
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
                    { typedef _Res result_type; };
                
                  /// Retrieve result type for a volatile member function pointer.
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
                    { typedef _Res result_type; };
                
                  /// Retrieve result type for a const volatile member function pointer.
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
                				  const volatile>
                    { typedef _Res result_type; };
                
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
                				  const volatile>
                    { typedef _Res result_type; };
                
                  /**
                   *  Strip top-level cv-qualifiers from the function object and let
                   *  _Weak_result_type_impl perform the real work.
                  */
                  template<typename _Functor>
         626 ->     struct _Weak_result_type
                    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
                    { };
                
                  /**
                   * Invoke a function object, which may be either a member pointer or a
                   * function object. The first parameter will tell which.
                   */
                  template<typename _Functor, typename... _Args>
                    inline
                    typename enable_if<
                	     (!is_member_pointer<_Functor>::value
                	      && !is_function<_Functor>::value
                	      && !is_function<typename remove_pointer<_Functor>::type>::value),
                	     typename result_of<_Functor&(_Args&&...)>::type
                	   >::type
                    __invoke(_Functor& __f, _Args&&... __args)
                    {
                      return __f(std::forward<_Args>(__args)...);
                    }
                
                  template<typename _Functor, typename... _Args>
                    inline
                    typename enable_if<
                             (is_member_pointer<_Functor>::value
                              && !is_function<_Functor>::value
                              && !is_function<typename remove_pointer<_Functor>::type>::value),
                             typename result_of<_Functor(_Args&&...)>::type
                           >::type
                    __invoke(_Functor& __f, _Args&&... __args)
                    {
                      return std::mem_fn(__f)(std::forward<_Args>(__args)...);
                    }
                
                  // To pick up function references (that will become function pointers)
                  template<typename _Functor, typename... _Args>
                    inline
                    typename enable_if<
                	     (is_pointer<_Functor>::value
                	      && is_function<typename remove_pointer<_Functor>::type>::value),
                	     typename result_of<_Functor(_Args&&...)>::type
                	   >::type
                    __invoke(_Functor __f, _Args&&... __args)
                    {
                      return __f(std::forward<_Args>(__args)...);
                    }
                
                  /**
                   *  Knowing which of unary_function and binary_function _Tp derives
                   *  from, derives from the same and ensures that reference_wrapper
                   *  will have a weak result type. See cases below.
                   */
                  template<bool _Unary, bool _Binary, typename _Tp>
                    struct _Reference_wrapper_base_impl;
                
                  // None of the nested argument types.
                  template<typename _Tp>
                    struct _Reference_wrapper_base_impl<false, false, _Tp>
                    : _Weak_result_type<_Tp>
                    { };
                
                  // Nested argument_type only.
                  template<typename _Tp>
                    struct _Reference_wrapper_base_impl<true, false, _Tp>
                    : _Weak_result_type<_Tp>
                    {
                      typedef typename _Tp::argument_type argument_type;
                    };
                
                  // Nested first_argument_type and second_argument_type only.
                  template<typename _Tp>
                    struct _Reference_wrapper_base_impl<false, true, _Tp>
                    : _Weak_result_type<_Tp>
                    {
                      typedef typename _Tp::first_argument_type first_argument_type;
                      typedef typename _Tp::second_argument_type second_argument_type;
                    };
                
                  // All the nested argument types.
                   template<typename _Tp>
                    struct _Reference_wrapper_base_impl<true, true, _Tp>
                    : _Weak_result_type<_Tp>
                    {
                      typedef typename _Tp::argument_type argument_type;
                      typedef typename _Tp::first_argument_type first_argument_type;
                      typedef typename _Tp::second_argument_type second_argument_type;
                    };
                
                  _GLIBCXX_HAS_NESTED_TYPE(argument_type)
                  _GLIBCXX_HAS_NESTED_TYPE(first_argument_type)
                  _GLIBCXX_HAS_NESTED_TYPE(second_argument_type)
                
                  /**
                   *  Derives from unary_function or binary_function when it
                   *  can. Specializations handle all of the easy cases. The primary
                   *  template determines what to do with a class type, which may
                   *  derive from both unary_function and binary_function.
                  */
                  template<typename _Tp>
                    struct _Reference_wrapper_base
                    : _Reference_wrapper_base_impl<
                      __has_argument_type<_Tp>::value,
                      __has_first_argument_type<_Tp>::value
                      && __has_second_argument_type<_Tp>::value,
                      _Tp>
                    { };
                
                  // - a function type (unary)
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res(_T1)>
                    : unary_function<_T1, _Res>
                    { };
                
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res(_T1) const>
                    : unary_function<_T1, _Res>
                    { };
                
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res(_T1) volatile>
                    : unary_function<_T1, _Res>
                    { };
                
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res(_T1) const volatile>
                    : unary_function<_T1, _Res>
                    { };
                
                  // - a function type (binary)
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res(_T1, _T2)>
                    : binary_function<_T1, _T2, _Res>
                    { };
                
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
                    : binary_function<_T1, _T2, _Res>
                    { };
                
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
                    : binary_function<_T1, _T2, _Res>
                    { };
                
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
                    : binary_function<_T1, _T2, _Res>
                    { };
                
                  // - a function pointer type (unary)
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res(*)(_T1)>
                    : unary_function<_T1, _Res>
                    { };
                
                  // - a function pointer type (binary)
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
                    : binary_function<_T1, _T2, _Res>
                    { };
                
                  // - a pointer to member function type (unary, no qualifiers)
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res (_T1::*)()>
                    : unary_function<_T1*, _Res>
                    { };
                
                  // - a pointer to member function type (binary, no qualifiers)
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
                    : binary_function<_T1*, _T2, _Res>
                    { };
                
                  // - a pointer to member function type (unary, const)
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res (_T1::*)() const>
                    : unary_function<const _T1*, _Res>
                    { };
                
                  // - a pointer to member function type (binary, const)
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
                    : binary_function<const _T1*, _T2, _Res>
                    { };
                
                  // - a pointer to member function type (unary, volatile)
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
                    : unary_function<volatile _T1*, _Res>
                    { };
                
                  // - a pointer to member function type (binary, volatile)
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
                    : binary_function<volatile _T1*, _T2, _Res>
                    { };
                
                  // - a pointer to member function type (unary, const volatile)
                  template<typename _Res, typename _T1>
                    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
                    : unary_function<const volatile _T1*, _Res>
                    { };
                
                  // - a pointer to member function type (binary, const volatile)
                  template<typename _Res, typename _T1, typename _T2>
                    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
                    : binary_function<const volatile _T1*, _T2, _Res>
                    { };
                
                  /**
                   *  @brief Primary class template for reference_wrapper.
                   *  @ingroup functors
                   *  @{
                   */
                  template<typename _Tp>
                    class reference_wrapper
                    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
                    {
                      _Tp* _M_data;
                
                    public:
                      typedef _Tp type;
                
                      reference_wrapper(_Tp& __indata) noexcept
                      : _M_data(std::__addressof(__indata))
                      { }
                
                      reference_wrapper(_Tp&&) = delete;
                
                      reference_wrapper(const reference_wrapper&) = default;
                
                      reference_wrapper&
                      operator=(const reference_wrapper&) = default;
                
                      operator _Tp&() const noexcept
                      { return this->get(); }
                
                      _Tp&
                      get() const noexcept
                      { return *_M_data; }
                
                      template<typename... _Args>
                	typename result_of<_Tp&(_Args&&...)>::type
                	operator()(_Args&&... __args) const
                	{
                	  return __invoke(get(), std::forward<_Args>(__args)...);
                	}
                    };
                
                
                  /// Denotes a reference should be taken to a variable.
                  template<typename _Tp>
                    inline reference_wrapper<_Tp>
                    ref(_Tp& __t) noexcept
                    { return reference_wrapper<_Tp>(__t); }
                
                  /// Denotes a const reference should be taken to a variable.
                  template<typename _Tp>
                    inline reference_wrapper<const _Tp>
                    cref(const _Tp& __t) noexcept
                    { return reference_wrapper<const _Tp>(__t); }
                
                  template<typename _Tp>
                    void ref(const _Tp&&) = delete;
                
                  template<typename _Tp>
                    void cref(const _Tp&&) = delete;
                
                  /// Partial specialization.
                  template<typename _Tp>
                    inline reference_wrapper<_Tp>
                    ref(reference_wrapper<_Tp> __t) noexcept
                    { return ref(__t.get()); }
                
                  /// Partial specialization.
                  template<typename _Tp>
                    inline reference_wrapper<const _Tp>
                    cref(reference_wrapper<_Tp> __t) noexcept
                    { return cref(__t.get()); }
                
                  // @} group functors
                
                  template<typename... _Types>
                    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
                    { };
                
                  template<typename _From, typename _To, bool = _From::value == _To::value>
                    struct _AllConvertible : false_type
                    { };
                
                  template<typename... _From, typename... _To>
                    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
                    : __and_<is_convertible<_From, _To>...>
                    { };
                
                  template<typename _Tp1, typename _Tp2>
                    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
                				    typename std::decay<_Tp2>::type>>;
                
                  /**
                   * Derives from @c unary_function or @c binary_function, or perhaps
                   * nothing, depending on the number of arguments provided. The
                   * primary template is the basis case, which derives nothing.
                   */
                  template<typename _Res, typename... _ArgTypes>
       11789 ->     struct _Maybe_unary_or_binary_function { };
                
                  /// Derives from @c unary_function, as appropriate.
                  template<typename _Res, typename _T1>
         795 ->     struct _Maybe_unary_or_binary_function<_Res, _T1>
                    : std::unary_function<_T1, _Res> { };
                
                  /// Derives from @c binary_function, as appropriate.
                  template<typename _Res, typename _T1, typename _T2>
        3181 ->     struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
                    : std::binary_function<_T1, _T2, _Res> { };
                
                  template<typename _Signature>
                    struct _Mem_fn_traits;
                
                  template<typename _Res, typename _Class, typename... _ArgTypes>
                    struct _Mem_fn_traits_base
                    {
                      using __result_type = _Res;
                      using __class_type =  _Class;
                      using __arg_types = _Pack<_ArgTypes...>;
                      using __maybe_type
                	= _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
                      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
                    };
                
                #define _GLIBCXX_MEM_FN_TRAITS2(_CV, _REF, _LVAL, _RVAL)		\
                  template<typename _Res, typename _Class, typename... _ArgTypes>	\
                    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) _CV _REF>	\
                    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>		\
                    {									\
                      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) _CV _REF;	\
                      using __lvalue = _LVAL;						\
                      using __rvalue = _RVAL;						\
                      using __vararg = false_type;					\
                    };									\
                  template<typename _Res, typename _Class, typename... _ArgTypes>	\
                    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) _CV _REF>	\
                    : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...>		\
                    {									\
                      using __pmf_type  = _Res (_Class::*)(_ArgTypes... ...) _CV _REF;	\
                      using __lvalue = _LVAL;						\
                      using __rvalue = _RVAL;						\
                      using __vararg = true_type;					\
                    };
                
                #define _GLIBCXX_MEM_FN_TRAITS(_REF, _LVAL, _RVAL)		\
                  _GLIBCXX_MEM_FN_TRAITS2(		, _REF, _LVAL, _RVAL)	\
                  _GLIBCXX_MEM_FN_TRAITS2(const		, _REF, _LVAL, _RVAL)	\
                  _GLIBCXX_MEM_FN_TRAITS2(volatile	, _REF, _LVAL, _RVAL)	\
                  _GLIBCXX_MEM_FN_TRAITS2(const volatile, _REF, _LVAL, _RVAL)
                
                _GLIBCXX_MEM_FN_TRAITS( , true_type, true_type)
                _GLIBCXX_MEM_FN_TRAITS(&, true_type, false_type)
                _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)
                
                #undef _GLIBCXX_MEM_FN_TRAITS
                #undef _GLIBCXX_MEM_FN_TRAITS2
                
                  template<typename _MemFunPtr,
                	   bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
                    class _Mem_fn_base
                    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
                    {
                      using _Traits = _Mem_fn_traits<_MemFunPtr>;
                
                      using _Class = typename _Traits::__class_type;
                      using _ArgTypes = typename _Traits::__arg_types;
                      using _Pmf = typename _Traits::__pmf_type;
                
                      using _Arity = typename _Traits::__arity;
                      using _Varargs = typename _Traits::__vararg;
                
                      template<typename _Func, typename... _BoundArgs>
                	friend struct _Bind_check_arity;
                
                      // for varargs functions we just check the number of arguments,
                      // otherwise we also check they are convertible.
                      template<typename _Args>
                	using _CheckArgs = typename conditional<_Varargs::value,
                	  __bool_constant<(_Args::value >= _ArgTypes::value)>,
                	  _AllConvertible<_Args, _ArgTypes>
                	>::type;
                
                    public:
                      using result_type = typename _Traits::__result_type;
                
         562 ->       explicit _Mem_fn_base(_Pmf __pmf) : _M_pmf(__pmf) { }
                
                      // Handle objects
                      template<typename... _Args, typename _Req
                               = _Require<typename _Traits::__lvalue,
                                          _CheckArgs<_Pack<_Args...>>>>
                	result_type
                	operator()(_Class& __object, _Args&&... __args) const
                	{ return (__object.*_M_pmf)(std::forward<_Args>(__args)...); }
                
                      template<typename... _Args, typename _Req
                               = _Require<typename _Traits::__rvalue,
                                          _CheckArgs<_Pack<_Args...>>>>
                	result_type
                	operator()(_Class&& __object, _Args&&... __args) const
                	{
                	  return (std::move(__object).*_M_pmf)(std::forward<_Args>(__args)...);
                	}
                
                      // Handle pointers
                      template<typename... _Args, typename _Req
                               = _Require<typename _Traits::__lvalue,
                                          _CheckArgs<_Pack<_Args...>>>>
                	result_type
        6955 -> 	operator()(_Class* __object, _Args&&... __args) const
                	{ return (__object->*_M_pmf)(std::forward<_Args>(__args)...); }
                
                      // Handle smart pointers, references and pointers to derived
                      template<typename _Tp, typename... _Args, typename _Req
                               = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,
                                          _CheckArgs<_Pack<_Args...>>>>
                	result_type
                	operator()(_Tp&& __object, _Args&&... __args) const
                	{
                	  return _M_call(std::forward<_Tp>(__object), &__object,
                	      std::forward<_Args>(__args)...);
                	}
                
                      // Handle reference wrappers
                      template<typename _Tp, typename... _Args, typename _Req
                               = _Require<is_base_of<_Class, _Tp>, typename _Traits::__lvalue,
                                          _CheckArgs<_Pack<_Args...>>>>
                	result_type
                	operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
                	{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }
                
                    private:
                      template<typename _Tp, typename... _Args>
                	result_type
                	_M_call(_Tp&& __object, const volatile _Class *,
                		_Args&&... __args) const
                	{
                	  return (std::forward<_Tp>(__object).*_M_pmf)
                	    (std::forward<_Args>(__args)...);
                	}
                
                      template<typename _Tp, typename... _Args>
                	result_type
                	_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
                	{ return ((*__ptr).*_M_pmf)(std::forward<_Args>(__args)...); }
                
                      _Pmf _M_pmf;
                    };
                
                  // Partial specialization for member object pointers.
                  template<typename _Res, typename _Class>
                    class _Mem_fn_base<_Res _Class::*, false>
                    {
                      using __pm_type = _Res _Class::*;
                
                      // This bit of genius is due to Peter Dimov, improved slightly by
                      // Douglas Gregor.
                      // Made less elegant to support perfect forwarding and noexcept.
                      template<typename _Tp>
                	auto
                	_M_call(_Tp&& __object, const _Class *) const noexcept
                	-> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())
                	{ return std::forward<_Tp>(__object).*_M_pm; }
                
                      template<typename _Tp, typename _Up>
                	auto
                	_M_call(_Tp&& __object, _Up * const *) const noexcept
                	-> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())
                	{ return (*std::forward<_Tp>(__object)).*_M_pm; }
                
                      template<typename _Tp>
                	auto
                	_M_call(_Tp&& __ptr, const volatile void*) const
                	noexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))
                	-> decltype((*__ptr).*std::declval<__pm_type&>())
                	{ return (*__ptr).*_M_pm; }
                
                      using _Arity = integral_constant<size_t, 0>;
                      using _Varargs = false_type;
                
                      template<typename _Func, typename... _BoundArgs>
                	friend struct _Bind_check_arity;
                
                    public:
                      explicit
                      _Mem_fn_base(_Res _Class::*__pm) noexcept : _M_pm(__pm) { }
                
                      // Handle objects
                      _Res&
                      operator()(_Class& __object) const noexcept
                      { return __object.*_M_pm; }
                
                      const _Res&
                      operator()(const _Class& __object) const noexcept
                      { return __object.*_M_pm; }
                
                      _Res&&
                      operator()(_Class&& __object) const noexcept
                      { return std::forward<_Class>(__object).*_M_pm; }
                
                      const _Res&&
                      operator()(const _Class&& __object) const noexcept
                      { return std::forward<const _Class>(__object).*_M_pm; }
                
                      // Handle pointers
                      _Res&
                      operator()(_Class* __object) const noexcept
                      { return __object->*_M_pm; }
                
                      const _Res&
                      operator()(const _Class* __object) const noexcept
                      { return __object->*_M_pm; }
                
                      // Handle smart pointers and derived
                      template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>
                	auto
                	operator()(_Tp&& __unknown) const
                	noexcept(noexcept(std::declval<_Mem_fn_base*>()->_M_call
                			  (std::forward<_Tp>(__unknown), &__unknown)))
                	-> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))
                	{ return _M_call(std::forward<_Tp>(__unknown), &__unknown); }
                
                      template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>
                	auto
                	operator()(reference_wrapper<_Tp> __ref) const
                	noexcept(noexcept(std::declval<_Mem_fn_base&>()(__ref.get())))
                	-> decltype((*this)(__ref.get()))
                	{ return (*this)(__ref.get()); }
                
                    private:
                      _Res _Class::*_M_pm;
                    };
                
                  template<typename _Res, typename _Class>
                    struct _Mem_fn<_Res _Class::*>
                    : _Mem_fn_base<_Res _Class::*>
                    {
         574 ->       using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
                    };
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2048.  Unnecessary mem_fn overloads
                  /**
                   *  @brief Returns a function object that forwards to the member
                   *  pointer @a pm.
                   *  @ingroup functors
                   */
                  template<typename _Tp, typename _Class>
                    inline _Mem_fn<_Tp _Class::*>
                    mem_fn(_Tp _Class::* __pm) noexcept
                    {
                      return _Mem_fn<_Tp _Class::*>(__pm);
                    }
                
                  /**
                   *  @brief Determines if the given type _Tp is a function object
                   *  should be treated as a subexpression when evaluating calls to
                   *  function objects returned by bind(). [TR1 3.6.1]
                   *  @ingroup binders
                   */
                  template<typename _Tp>
                    struct is_bind_expression
                    : public false_type { };
                
                  /**
                   *  @brief Determines if the given type _Tp is a placeholder in a
                   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]
                   *  @ingroup binders
                   */
                  template<typename _Tp>
                    struct is_placeholder
                    : public integral_constant<int, 0>
                    { };
                
                  /** @brief The type of placeholder objects defined by libstdc++.
                   *  @ingroup binders
                   */
                  template<int _Num> struct _Placeholder { };
                
                  _GLIBCXX_END_NAMESPACE_VERSION
                
                  /** @namespace std::placeholders
                   *  @brief ISO C++11 entities sub-namespace for functional.
                   *  @ingroup binders
                   */
                  namespace placeholders
                  {
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                  /* Define a large number of placeholders. There is no way to
                   * simplify this with variadic templates, because we're introducing
                   * unique names for each.
                   */
                    extern const _Placeholder<1> _1;
                    extern const _Placeholder<2> _2;
                    extern const _Placeholder<3> _3;
                    extern const _Placeholder<4> _4;
                    extern const _Placeholder<5> _5;
                    extern const _Placeholder<6> _6;
                    extern const _Placeholder<7> _7;
                    extern const _Placeholder<8> _8;
                    extern const _Placeholder<9> _9;
                    extern const _Placeholder<10> _10;
                    extern const _Placeholder<11> _11;
                    extern const _Placeholder<12> _12;
                    extern const _Placeholder<13> _13;
                    extern const _Placeholder<14> _14;
                    extern const _Placeholder<15> _15;
                    extern const _Placeholder<16> _16;
                    extern const _Placeholder<17> _17;
                    extern const _Placeholder<18> _18;
                    extern const _Placeholder<19> _19;
                    extern const _Placeholder<20> _20;
                    extern const _Placeholder<21> _21;
                    extern const _Placeholder<22> _22;
                    extern const _Placeholder<23> _23;
                    extern const _Placeholder<24> _24;
                    extern const _Placeholder<25> _25;
                    extern const _Placeholder<26> _26;
                    extern const _Placeholder<27> _27;
                    extern const _Placeholder<28> _28;
                    extern const _Placeholder<29> _29;
                  _GLIBCXX_END_NAMESPACE_VERSION
                  }
                
                  _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  Partial specialization of is_placeholder that provides the placeholder
                   *  number for the placeholder objects defined by libstdc++.
                   *  @ingroup binders
                   */
                  template<int _Num>
                    struct is_placeholder<_Placeholder<_Num> >
                    : public integral_constant<int, _Num>
                    { };
                
                  template<int _Num>
                    struct is_placeholder<const _Placeholder<_Num> >
                    : public integral_constant<int, _Num>
                    { };
                
                  /**
                   * Used by _Safe_tuple_element to indicate that there is no tuple
                   * element at this position.
                   */
                  struct _No_tuple_element;
                
                  /**
                   * Implementation helper for _Safe_tuple_element. This primary
                   * template handles the case where it is safe to use @c
                   * tuple_element.
                   */
                  template<std::size_t __i, typename _Tuple, bool _IsSafe>
                    struct _Safe_tuple_element_impl
                    : tuple_element<__i, _Tuple> { };
                
                  /**
                   * Implementation helper for _Safe_tuple_element. This partial
                   * specialization handles the case where it is not safe to use @c
                   * tuple_element. We just return @c _No_tuple_element.
                   */
                  template<std::size_t __i, typename _Tuple>
                    struct _Safe_tuple_element_impl<__i, _Tuple, false>
                    {
                      typedef _No_tuple_element type;
                    };
                
                  /**
                   * Like tuple_element, but returns @c _No_tuple_element when
                   * tuple_element would return an error.
                   */
                 template<std::size_t __i, typename _Tuple>
                   struct _Safe_tuple_element
                   : _Safe_tuple_element_impl<__i, _Tuple,
                			      (__i < tuple_size<_Tuple>::value)>
                   { };
                
                  /**
                   *  Maps an argument to bind() into an actual argument to the bound
                   *  function object [TR1 3.6.3/5]. Only the first parameter should
                   *  be specified: the rest are used to determine among the various
                   *  implementations. Note that, although this class is a function
                   *  object, it isn't entirely normal because it takes only two
                   *  parameters regardless of the number of parameters passed to the
                   *  bind expression. The first parameter is the bound argument and
                   *  the second parameter is a tuple containing references to the
                   *  rest of the arguments.
                   */
                  template<typename _Arg,
                	   bool _IsBindExp = is_bind_expression<_Arg>::value,
                	   bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
                    class _Mu;
                
                  /**
                   *  If the argument is reference_wrapper<_Tp>, returns the
                   *  underlying reference. [TR1 3.6.3/5 bullet 1]
                   */
                  template<typename _Tp>
                    class _Mu<reference_wrapper<_Tp>, false, false>
                    {
                    public:
                      typedef _Tp& result_type;
                
                      /* Note: This won't actually work for const volatile
                       * reference_wrappers, because reference_wrapper::get() is const
                       * but not volatile-qualified. This might be a defect in the TR.
                       */
                      template<typename _CVRef, typename _Tuple>
                	result_type
                	operator()(_CVRef& __arg, _Tuple&) const volatile
                	{ return __arg.get(); }
                    };
                
                  /**
                   *  If the argument is a bind expression, we invoke the underlying
                   *  function object with the same cv-qualifiers as we are given and
                   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]
                   */
                  template<typename _Arg>
                    class _Mu<_Arg, true, false>
                    {
                    public:
                      template<typename _CVArg, typename... _Args>
                	auto
                	operator()(_CVArg& __arg,
                		   tuple<_Args...>& __tuple) const volatile
                	-> decltype(__arg(declval<_Args>()...))
                	{
                	  // Construct an index tuple and forward to __call
                	  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
                	    _Indexes;
                	  return this->__call(__arg, __tuple, _Indexes());
                	}
                
                    private:
                      // Invokes the underlying function object __arg by unpacking all
                      // of the arguments in the tuple.
                      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
                	auto
                	__call(_CVArg& __arg, tuple<_Args...>& __tuple,
                	       const _Index_tuple<_Indexes...>&) const volatile
                	-> decltype(__arg(declval<_Args>()...))
                	{
                	  return __arg(std::forward<_Args>(std::get<_Indexes>(__tuple))...);
                	}
                    };
                
                  /**
                   *  If the argument is a placeholder for the Nth argument, returns
                   *  a reference to the Nth argument to the bind function object.
                   *  [TR1 3.6.3/5 bullet 3]
                   */
                  template<typename _Arg>
                    class _Mu<_Arg, false, true>
                    {
                    public:
                      template<typename _Signature> class result;
                
                      template<typename _CVMu, typename _CVArg, typename _Tuple>
                	class result<_CVMu(_CVArg, _Tuple)>
                	{
                	  // Add a reference, if it hasn't already been done for us.
                	  // This allows us to be a little bit sloppy in constructing
                	  // the tuple that we pass to result_of<...>.
                	  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
                						- 1), _Tuple>::type
                	    __base_type;
                
                	public:
                	  typedef typename add_rvalue_reference<__base_type>::type type;
                	};
                
                      template<typename _Tuple>
                	typename result<_Mu(_Arg, _Tuple)>::type
        9041 -> 	operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
                	{
                	  return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(
                	      ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
                	}
                    };
                
                  /**
                   *  If the argument is just a value, returns a reference to that
                   *  value. The cv-qualifiers on the reference are the same as the
                   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]
                   */
                  template<typename _Arg>
                    class _Mu<_Arg, false, false>
                    {
                    public:
                      template<typename _Signature> struct result;
                
                      template<typename _CVMu, typename _CVArg, typename _Tuple>
                	struct result<_CVMu(_CVArg, _Tuple)>
                	{
                	  typedef typename add_lvalue_reference<_CVArg>::type type;
                	};
                
                      // Pick up the cv-qualifiers of the argument
                      template<typename _CVArg, typename _Tuple>
                	_CVArg&&
        8808 -> 	operator()(_CVArg&& __arg, _Tuple&) const volatile
                	{ return std::forward<_CVArg>(__arg); }
                    };
                
                  /**
                   *  Maps member pointers into instances of _Mem_fn but leaves all
                   *  other function objects untouched. Used by std::bind(). The
                   *  primary template handles the non-member-pointer case.
                   */
                  template<typename _Tp>
                    struct _Maybe_wrap_member_pointer
                    {
                      typedef _Tp type;
                
                      static const _Tp&
           6 ->       __do_wrap(const _Tp& __x)
                      { return __x; }
                
                      static _Tp&&
                      __do_wrap(_Tp&& __x)
                      { return static_cast<_Tp&&>(__x); }
                    };
                
                  /**
                   *  Maps member pointers into instances of _Mem_fn but leaves all
                   *  other function objects untouched. Used by std::bind(). This
                   *  partial specialization handles the member pointer case.
                   */
                  template<typename _Tp, typename _Class>
                    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
                    {
                      typedef _Mem_fn<_Tp _Class::*> type;
                
                      static type
         567 ->       __do_wrap(_Tp _Class::* __pm)
                      { return type(__pm); }
                    };
                
                  // Specialization needed to prevent "forming reference to void" errors when
                  // bind<void>() is called, because argument deduction instantiates
                  // _Maybe_wrap_member_pointer<void> outside the immediate context where
                  // SFINAE applies.
                  template<>
                    struct _Maybe_wrap_member_pointer<void>
                    {
                      typedef void type;
                    };
                
                  // std::get<I> for volatile-qualified tuples
                  template<std::size_t _Ind, typename... _Tp>
                    inline auto
                    __volget(volatile tuple<_Tp...>& __tuple)
                    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
                    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }
                
                  // std::get<I> for const-volatile-qualified tuples
                  template<std::size_t _Ind, typename... _Tp>
                    inline auto
                    __volget(const volatile tuple<_Tp...>& __tuple)
                    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
                    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }
                
                  /// Type of the function object returned from bind().
                  template<typename _Signature>
                    struct _Bind;
                
                   template<typename _Functor, typename... _Bound_args>
          18 ->     class _Bind<_Functor(_Bound_args...)>
                    : public _Weak_result_type<_Functor>
                    {
                      typedef _Bind __self_type;
                      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
                	_Bound_indexes;
                
                      _Functor _M_f;
                      tuple<_Bound_args...> _M_bound_args;
                
                      // Call unqualified
                      template<typename _Result, typename... _Args, std::size_t... _Indexes>
                	_Result
        8777 -> 	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (std::get<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as const
                      template<typename _Result, typename... _Args, std::size_t... _Indexes>
                	_Result
                	__call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (std::get<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as volatile
                      template<typename _Result, typename... _Args, std::size_t... _Indexes>
                	_Result
                	__call_v(tuple<_Args...>&& __args,
                		 _Index_tuple<_Indexes...>) volatile
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (__volget<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as const volatile
                      template<typename _Result, typename... _Args, std::size_t... _Indexes>
                	_Result
                	__call_c_v(tuple<_Args...>&& __args,
                		   _Index_tuple<_Indexes...>) const volatile
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (__volget<_Indexes>(_M_bound_args), __args)...);
                	}
                
                     public:
                      template<typename... _Args>
           6 -> 	explicit _Bind(const _Functor& __f, _Args&&... __args)
                	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
                	{ }
                
                      template<typename... _Args>
         307 -> 	explicit _Bind(_Functor&& __f, _Args&&... __args)
                	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
                	{ }
                
           3 ->       _Bind(const _Bind&) = default;
                
         311 ->       _Bind(_Bind&& __b)
                      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
                      { }
                
                      // Call unqualified
                      template<typename... _Args, typename _Result
                	= decltype( std::declval<_Functor&>()(
                	      _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
                				  std::declval<tuple<_Args...>&>() )... ) )>
                	_Result
        8591 -> 	operator()(_Args&&... __args)
                	{
                	  return this->__call<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                
                      // Call as const
                      template<typename... _Args, typename _Result
                	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                		       typename add_const<_Functor>::type&>::type>()(
                	      _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
                				  std::declval<tuple<_Args...>&>() )... ) )>
                	_Result
                	operator()(_Args&&... __args) const
                	{
                	  return this->__call_c<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                
                      // Call as volatile
                      template<typename... _Args, typename _Result
                	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                                       typename add_volatile<_Functor>::type&>::type>()(
                	      _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
                				  std::declval<tuple<_Args...>&>() )... ) )>
                	_Result
                	operator()(_Args&&... __args) volatile
                	{
                	  return this->__call_v<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                
                      // Call as const volatile
                      template<typename... _Args, typename _Result
                	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                                       typename add_cv<_Functor>::type&>::type>()(
                	      _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
                				  std::declval<tuple<_Args...>&>() )... ) )>
                	_Result
                	operator()(_Args&&... __args) const volatile
                	{
                	  return this->__call_c_v<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                    };
                
                  /// Type of the function object returned from bind<R>().
                  template<typename _Result, typename _Signature>
                    struct _Bind_result;
                
                  template<typename _Result, typename _Functor, typename... _Bound_args>
                    class _Bind_result<_Result, _Functor(_Bound_args...)>
                    {
                      typedef _Bind_result __self_type;
                      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
                	_Bound_indexes;
                
                      _Functor _M_f;
                      tuple<_Bound_args...> _M_bound_args;
                
                      // sfinae types
                      template<typename _Res>
                	struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
                      template<typename _Res>
                	struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };
                
                      // Call unqualified
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	_Result
                	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
                	    typename __disable_if_void<_Res>::type = 0)
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (std::get<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call unqualified, return void
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	void
                	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
                	    typename __enable_if_void<_Res>::type = 0)
                	{
                	  _M_f(_Mu<_Bound_args>()
                	       (std::get<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as const
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	_Result
                	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
                	    typename __disable_if_void<_Res>::type = 0) const
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (std::get<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as const, return void
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	void
                	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
                	    typename __enable_if_void<_Res>::type = 0) const
                	{
                	  _M_f(_Mu<_Bound_args>()
                	       (std::get<_Indexes>(_M_bound_args),  __args)...);
                	}
                
                      // Call as volatile
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	_Result
                	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
                	    typename __disable_if_void<_Res>::type = 0) volatile
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (__volget<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as volatile, return void
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	void
                	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
                	    typename __enable_if_void<_Res>::type = 0) volatile
                	{
                	  _M_f(_Mu<_Bound_args>()
                	       (__volget<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as const volatile
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	_Result
                	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
                	    typename __disable_if_void<_Res>::type = 0) const volatile
                	{
                	  return _M_f(_Mu<_Bound_args>()
                		      (__volget<_Indexes>(_M_bound_args), __args)...);
                	}
                
                      // Call as const volatile, return void
                      template<typename _Res, typename... _Args, std::size_t... _Indexes>
                	void
                	__call(tuple<_Args...>&& __args,
                	       _Index_tuple<_Indexes...>,
                	    typename __enable_if_void<_Res>::type = 0) const volatile
                	{
                	  _M_f(_Mu<_Bound_args>()
                	       (__volget<_Indexes>(_M_bound_args), __args)...);
                	}
                
                    public:
                      typedef _Result result_type;
                
                      template<typename... _Args>
                	explicit _Bind_result(const _Functor& __f, _Args&&... __args)
                	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
                	{ }
                
                      template<typename... _Args>
                	explicit _Bind_result(_Functor&& __f, _Args&&... __args)
                	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
                	{ }
                
                      _Bind_result(const _Bind_result&) = default;
                
                      _Bind_result(_Bind_result&& __b)
                      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
                      { }
                
                      // Call unqualified
                      template<typename... _Args>
                	result_type
                	operator()(_Args&&... __args)
                	{
                	  return this->__call<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                
                      // Call as const
                      template<typename... _Args>
                	result_type
                	operator()(_Args&&... __args) const
                	{
                	  return this->__call<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                
                      // Call as volatile
                      template<typename... _Args>
                	result_type
                	operator()(_Args&&... __args) volatile
                	{
                	  return this->__call<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                
                      // Call as const volatile
                      template<typename... _Args>
                	result_type
                	operator()(_Args&&... __args) const volatile
                	{
                	  return this->__call<_Result>(
                	      std::forward_as_tuple(std::forward<_Args>(__args)...),
                	      _Bound_indexes());
                	}
                    };
                
                  /**
                   *  @brief Class template _Bind is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Signature>
                    struct is_bind_expression<_Bind<_Signature> >
                    : public true_type { };
                
                  /**
                   *  @brief Class template _Bind is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Signature>
                    struct is_bind_expression<const _Bind<_Signature> >
                    : public true_type { };
                
                  /**
                   *  @brief Class template _Bind is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Signature>
                    struct is_bind_expression<volatile _Bind<_Signature> >
                    : public true_type { };
                
                  /**
                   *  @brief Class template _Bind is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Signature>
                    struct is_bind_expression<const volatile _Bind<_Signature>>
                    : public true_type { };
                
                  /**
                   *  @brief Class template _Bind_result is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Result, typename _Signature>
                    struct is_bind_expression<_Bind_result<_Result, _Signature>>
                    : public true_type { };
                
                  /**
                   *  @brief Class template _Bind_result is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Result, typename _Signature>
                    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
                    : public true_type { };
                
                  /**
                   *  @brief Class template _Bind_result is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Result, typename _Signature>
                    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
                    : public true_type { };
                
                  /**
                   *  @brief Class template _Bind_result is always a bind expression.
                   *  @ingroup binders
                   */
                  template<typename _Result, typename _Signature>
                    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
                    : public true_type { };
                
                  template<typename _Func, typename... _BoundArgs>
                    struct _Bind_check_arity { };
                
                  template<typename _Ret, typename... _Args, typename... _BoundArgs>
                    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
                    {
                      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                                   "Wrong number of arguments for function");
                    };
                
                  template<typename _Ret, typename... _Args, typename... _BoundArgs>
                    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
                    {
                      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                                   "Wrong number of arguments for function");
                    };
                
                  template<typename _Tp, typename _Class, typename... _BoundArgs>
                    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
                    {
                      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
                      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
                      static_assert(_Varargs::value
                		    ? sizeof...(_BoundArgs) >= _Arity::value + 1
                		    : sizeof...(_BoundArgs) == _Arity::value + 1,
                		    "Wrong number of arguments for pointer-to-member");
                    };
                
                  // Trait type used to remove std::bind() from overload set via SFINAE
                  // when first argument has integer type, so that std::bind() will
                  // not be a better match than ::bind() from the BSD Sockets API.
                  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
                    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;
                
                  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
                    struct _Bind_helper
                    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
                    {
                      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
                	__maybe_type;
                      typedef typename __maybe_type::type __func_type;
                      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
                    };
                
                  // Partial specialization for is_socketlike == true, does not define
                  // nested type so std::bind() will not participate in overload resolution
                  // when the first argument might be a socket file descriptor.
                  template<typename _Func, typename... _BoundArgs>
                    struct _Bind_helper<true, _Func, _BoundArgs...>
                    { };
                
                  /**
                   *  @brief Function template for std::bind.
                   *  @ingroup binders
                   */
                  template<typename _Func, typename... _BoundArgs>
                    inline typename
                    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
         309 ->     bind(_Func&& __f, _BoundArgs&&... __args)
                    {
                      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
                      typedef typename __helper_type::__maybe_type __maybe_type;
                      typedef typename __helper_type::type __result_type;
                      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
                			   std::forward<_BoundArgs>(__args)...);
                    }
                
                  template<typename _Result, typename _Func, typename... _BoundArgs>
                    struct _Bindres_helper
                    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
                    {
                      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
                	__maybe_type;
                      typedef typename __maybe_type::type __functor_type;
                      typedef _Bind_result<_Result,
                			   __functor_type(typename decay<_BoundArgs>::type...)>
                	type;
                    };
                
                  /**
                   *  @brief Function template for std::bind<R>.
                   *  @ingroup binders
                   */
                  template<typename _Result, typename _Func, typename... _BoundArgs>
                    inline
                    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
                    bind(_Func&& __f, _BoundArgs&&... __args)
                    {
                      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
                      typedef typename __helper_type::__maybe_type __maybe_type;
                      typedef typename __helper_type::type __result_type;
                      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
                			   std::forward<_BoundArgs>(__args)...);
                    }
                
                  template<typename _Signature>
                    struct _Bind_simple;
                
                  template<typename _Callable, typename... _Args>
                    struct _Bind_simple<_Callable(_Args...)>
                    {
                      typedef typename result_of<_Callable(_Args...)>::type result_type;
                
                      template<typename _Tp, typename... _Up>
                        explicit
         263 ->         _Bind_simple(_Tp&& __f, _Up&&... __args)
                        : _M_bound(std::forward<_Tp>(__f), std::forward<_Up>(__args)...)
                        { }
                
                      _Bind_simple(const _Bind_simple&) = default;
         315 ->       _Bind_simple(_Bind_simple&&) = default;
                
                      result_type
         136 ->       operator()()
                      {
                        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
                        return _M_invoke(_Indices());
                      }
                
                    private:
                      template<std::size_t... _Indices>
                        typename result_of<_Callable(_Args...)>::type
         113 ->         _M_invoke(_Index_tuple<_Indices...>)
                        {
                	  // std::bind always forwards bound arguments as lvalues,
                	  // but this type can call functions which only accept rvalues.
                          return std::forward<_Callable>(std::get<0>(_M_bound))(
                              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
                        }
                
                      std::tuple<_Callable, _Args...> _M_bound;
                    };
                
                  template<typename _Func, typename... _BoundArgs>
                    struct _Bind_simple_helper
                    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
                    {
                      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
                        __maybe_type;
                      typedef typename __maybe_type::type __func_type;
                      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
                       	__type;
                    };
                
                  // Simplified version of std::bind for internal use, without support for
                  // unbound arguments, placeholders or nested bind expressions.
                  template<typename _Callable, typename... _Args>
                    typename _Bind_simple_helper<_Callable, _Args...>::__type
         253 ->     __bind_simple(_Callable&& __callable, _Args&&... __args)
                    {
                      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
                      typedef typename __helper_type::__maybe_type __maybe_type;
                      typedef typename __helper_type::__type __result_type;
                      return __result_type(
                          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
                          std::forward<_Args>(__args)...);
                    }
                
                  /**
                   *  @brief Exception class thrown when class template function's
                   *  operator() is called with an empty target.
                   *  @ingroup exceptions
                   */
                  class bad_function_call : public std::exception
                  {
                  public:
                    virtual ~bad_function_call() noexcept;
                
                    const char* what() const noexcept;
                  };
                
                  /**
                   *  Trait identifying "location-invariant" types, meaning that the
                   *  address of the object (or any of its members) will not escape.
                   *  Trivially copyable types are location-invariant and users can
                   *  specialize this trait for other types.
                   */
                  template<typename _Tp>
                    struct __is_location_invariant
                    : is_trivially_copyable<_Tp>::type
                    { };
                
                  class _Undefined_class;
                
                  union _Nocopy_types
                  {
                    void*       _M_object;
                    const void* _M_const_object;
                    void (*_M_function_pointer)();
                    void (_Undefined_class::*_M_member_pointer)();
                  };
                
                  union _Any_data
                  {
       27836 ->     void*       _M_access()       { return &_M_pod_data[0]; }
       35946 ->     const void* _M_access() const { return &_M_pod_data[0]; }
                
                    template<typename _Tp>
                      _Tp&
       20435 ->       _M_access()
                      { return *static_cast<_Tp*>(_M_access()); }
                
                    template<typename _Tp>
                      const _Tp&
       35984 ->       _M_access() const
                      { return *static_cast<const _Tp*>(_M_access()); }
                
                    _Nocopy_types _M_unused;
                    char _M_pod_data[sizeof(_Nocopy_types)];
                  };
                
                  enum _Manager_operation
                  {
                    __get_type_info,
                    __get_functor_ptr,
                    __clone_functor,
                    __destroy_functor
                  };
                
                  // Simple type wrapper that helps avoid annoying const problems
                  // when casting between void pointers and pointers-to-pointers.
                  template<typename _Tp>
                    struct _Simple_type_wrapper
                    {
                      _Simple_type_wrapper(_Tp __value) : __value(__value) { }
                
                      _Tp __value;
                    };
                
                  template<typename _Tp>
                    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
                    : __is_location_invariant<_Tp>
                    { };
                
                  // Converts a reference to a function object into a callable
                  // function object.
                  template<typename _Functor>
                    inline _Functor&
                    __callable_functor(_Functor& __f)
                    { return __f; }
                
                  template<typename _Member, typename _Class>
                    inline _Mem_fn<_Member _Class::*>
                    __callable_functor(_Member _Class::* &__p)
                    { return std::mem_fn(__p); }
                
                  template<typename _Member, typename _Class>
                    inline _Mem_fn<_Member _Class::*>
                    __callable_functor(_Member _Class::* const &__p)
                    { return std::mem_fn(__p); }
                
                  template<typename _Member, typename _Class>
                    inline _Mem_fn<_Member _Class::*>
                    __callable_functor(_Member _Class::* volatile &__p)
                    { return std::mem_fn(__p); }
                
                  template<typename _Member, typename _Class>
                    inline _Mem_fn<_Member _Class::*>
                    __callable_functor(_Member _Class::* const volatile &__p)
                    { return std::mem_fn(__p); }
                
                  template<typename _Signature>
                    class function;
                
                  /// Base class of all polymorphic function object wrappers.
                  class _Function_base
                  {
                  public:
                    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
                    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);
                
                    template<typename _Functor>
                      class _Base_manager
                      {
                      protected:
                	static const bool __stored_locally =
                	(__is_location_invariant<_Functor>::value
                	 && sizeof(_Functor) <= _M_max_size
                	 && __alignof__(_Functor) <= _M_max_align
                	 && (_M_max_align % __alignof__(_Functor) == 0));
                
                	typedef integral_constant<bool, __stored_locally> _Local_storage;
                
                	// Retrieve a pointer to the function object
                	static _Functor*
       34479 -> 	_M_get_pointer(const _Any_data& __source)
                	{
                	  const _Functor* __ptr =
                	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
                	    /* have stored a pointer */ : __source._M_access<_Functor*>();
                	  return const_cast<_Functor*>(__ptr);
                	}
                
                	// Clone a location-invariant function object that fits within
                	// an _Any_data structure.
                	static void
         276 -> 	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
                	{
                	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
                	}
                
                	// Clone a function object that is not location-invariant or
                	// that cannot fit into an _Any_data structure.
                	static void
        1108 -> 	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
                	{
                	  __dest._M_access<_Functor*>() =
                	    new _Functor(*__source._M_access<_Functor*>());
                	}
                
                	// Destroying a location-invariant object may still require
                	// destruction.
                	static void
        7315 -> 	_M_destroy(_Any_data& __victim, true_type)
                	{
                	  __victim._M_access<_Functor>().~_Functor();
                	}
                
                	// Destroying an object located on the heap.
                	static void
        7045 -> 	_M_destroy(_Any_data& __victim, false_type)
                	{
                	  delete __victim._M_access<_Functor*>();
                	}
                
                      public:
                	static bool
       16255 -> 	_M_manager(_Any_data& __dest, const _Any_data& __source,
                		   _Manager_operation __op)
                	{
                	  switch (__op)
                	    {
                #if __cpp_rtti
                	    case __get_type_info:
                	      __dest._M_access<const type_info*>() = &typeid(_Functor);
                	      break;
                #endif
                	    case __get_functor_ptr:
                	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
                	      break;
                
                	    case __clone_functor:
                	      _M_clone(__dest, __source, _Local_storage());
                	      break;
                
                	    case __destroy_functor:
                	      _M_destroy(__dest, _Local_storage());
                	      break;
                	    }
                	  return false;
                	}
                
                	static void
       12160 -> 	_M_init_functor(_Any_data& __functor, _Functor&& __f)
                	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
                
                	template<typename _Signature>
                	  static bool
         200 -> 	  _M_not_empty_function(const function<_Signature>& __f)
                	  { return static_cast<bool>(__f); }
                
                	template<typename _Tp>
                	  static bool
         108 -> 	  _M_not_empty_function(_Tp* const& __fp)
                	  { return __fp; }
                
                	template<typename _Class, typename _Tp>
                	  static bool
                	  _M_not_empty_function(_Tp _Class::* const& __mp)
                	  { return __mp; }
                
                	template<typename _Tp>
                	  static bool
       11724 -> 	  _M_not_empty_function(const _Tp&)
                	  { return true; }
                
                      private:
                	static void
        7206 -> 	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
                	{ new (__functor._M_access()) _Functor(std::move(__f)); }
                
                	static void
        4620 -> 	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
                	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
                      };
                
                    template<typename _Functor>
                      class _Ref_manager : public _Base_manager<_Functor*>
                      {
                	typedef _Function_base::_Base_manager<_Functor*> _Base;
                
                      public:
                	static bool
                	_M_manager(_Any_data& __dest, const _Any_data& __source,
                		   _Manager_operation __op)
                	{
                	  switch (__op)
                	    {
                #if __cpp_rtti
                	    case __get_type_info:
                	      __dest._M_access<const type_info*>() = &typeid(_Functor);
                	      break;
                #endif
                	    case __get_functor_ptr:
                	      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
                	      return is_const<_Functor>::value;
                	      break;
                
                	    default:
                	      _Base::_M_manager(__dest, __source, __op);
                	    }
                	  return false;
                	}
                
                	static void
                	_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
                	{
                	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
                	}
                      };
                
       14162 ->     _Function_base() : _M_manager(nullptr) { }
                
       15881 ->     ~_Function_base()
                    {
                      if (_M_manager)
                	_M_manager(_M_functor, _M_functor, __destroy_functor);
                    }
                
                
       38626 ->     bool _M_empty() const { return !_M_manager; }
                
                    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
                				  _Manager_operation);
                
                    _Any_data     _M_functor;
                    _Manager_type _M_manager;
                  };
                
                  template<typename _Signature, typename _Functor>
                    class _Function_handler;
                
                  template<typename _Res, typename _Functor, typename... _ArgTypes>
                    class _Function_handler<_Res(_ArgTypes...), _Functor>
                    : public _Function_base::_Base_manager<_Functor>
                    {
                      typedef _Function_base::_Base_manager<_Functor> _Base;
                
                    public:
                      static _Res
       11215 ->       _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
                      {
                	return (*_Base::_M_get_pointer(__functor))(
                	    std::forward<_ArgTypes>(__args)...);
                      }
                    };
                
                  template<typename _Functor, typename... _ArgTypes>
                    class _Function_handler<void(_ArgTypes...), _Functor>
                    : public _Function_base::_Base_manager<_Functor>
                    {
                      typedef _Function_base::_Base_manager<_Functor> _Base;
                
                     public:
                      static void
       24097 ->       _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
                      {
                	(*_Base::_M_get_pointer(__functor))(
                	    std::forward<_ArgTypes>(__args)...);
                      }
                    };
                
                  template<typename _Res, typename _Functor, typename... _ArgTypes>
                    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
                    : public _Function_base::_Ref_manager<_Functor>
                    {
                      typedef _Function_base::_Ref_manager<_Functor> _Base;
                
                     public:
                      static _Res
                      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
                      {
                	return std::__callable_functor(**_Base::_M_get_pointer(__functor))(
                	      std::forward<_ArgTypes>(__args)...);
                      }
                    };
                
                  template<typename _Functor, typename... _ArgTypes>
                    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
                    : public _Function_base::_Ref_manager<_Functor>
                    {
                      typedef _Function_base::_Ref_manager<_Functor> _Base;
                
                     public:
                      static void
                      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
                      {
                	std::__callable_functor(**_Base::_M_get_pointer(__functor))(
                	    std::forward<_ArgTypes>(__args)...);
                      }
                    };
                
                  template<typename _Class, typename _Member, typename _Res,
                	   typename... _ArgTypes>
                    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
                    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
                    {
                      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
                	_Base;
                
                     public:
                      static _Res
                      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
                      {
                	return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
                	    std::forward<_ArgTypes>(__args)...);
                      }
                    };
                
                  template<typename _Class, typename _Member, typename... _ArgTypes>
                    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
                    : public _Function_base::_Base_manager<
                		 _Simple_type_wrapper< _Member _Class::* > >
                    {
                      typedef _Member _Class::* _Functor;
                      typedef _Simple_type_wrapper<_Functor> _Wrapper;
                      typedef _Function_base::_Base_manager<_Wrapper> _Base;
                
                    public:
                      static bool
                      _M_manager(_Any_data& __dest, const _Any_data& __source,
                		 _Manager_operation __op)
                      {
                	switch (__op)
                	  {
                #if __cpp_rtti
                	  case __get_type_info:
                	    __dest._M_access<const type_info*>() = &typeid(_Functor);
                	    break;
                #endif
                	  case __get_functor_ptr:
                	    __dest._M_access<_Functor*>() =
                	      &_Base::_M_get_pointer(__source)->__value;
                	    break;
                
                	  default:
                	    _Base::_M_manager(__dest, __source, __op);
                	  }
                	return false;
                      }
                
                      static void
                      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
                      {
                	std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
                	    std::forward<_ArgTypes>(__args)...);
                      }
                    };
                
                  template<typename _From, typename _To>
                    using __check_func_return_type
                      = __or_<is_void<_To>, is_convertible<_From, _To>>;
                
                  /**
                   *  @brief Primary class template for std::function.
                   *  @ingroup functors
                   *
                   *  Polymorphic function wrapper.
                   */
                  template<typename _Res, typename... _ArgTypes>
       14815 ->     class function<_Res(_ArgTypes...)>
                    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
                      private _Function_base
                    {
                      typedef _Res _Signature_type(_ArgTypes...);
                
                      template<typename _Func,
                	       typename _Res2 = typename result_of<_Func(_ArgTypes...)>::type>
                	struct _Callable : __check_func_return_type<_Res2, _Res> { };
                
                      // Used so the return type convertibility checks aren't done when
                      // performing overload resolution for copy construction/assignment.
                      template<typename _Tp>
                	struct _Callable<function, _Tp> : false_type { };
                
                      template<typename _Cond, typename _Tp>
                	using _Requires = typename enable_if<_Cond::value, _Tp>::type;
                
                    public:
                      typedef _Res result_type;
                
                      // [3.7.2.1] construct/copy/destroy
                
                      /**
                       *  @brief Default construct creates an empty function call wrapper.
                       *  @post @c !(bool)*this
                       */
          85 ->       function() noexcept
                      : _Function_base() { }
                
                      /**
                       *  @brief Creates an empty function call wrapper.
                       *  @post @c !(bool)*this
                       */
                      function(nullptr_t) noexcept
                      : _Function_base() { }
                
                      /**
                       *  @brief %Function copy constructor.
                       *  @param __x A %function object with identical call signature.
                       *  @post @c bool(*this) == bool(__x)
                       *
                       *  The newly-created %function contains a copy of the target of @a
                       *  __x (if it has one).
                       */
                      function(const function& __x);
                
                      /**
                       *  @brief %Function move constructor.
                       *  @param __x A %function object rvalue with identical call signature.
                       *
                       *  The newly-created %function contains the target of @a __x
                       *  (if it has one).
                       */
         609 ->       function(function&& __x) : _Function_base()
                      {
                	__x.swap(*this);
                      }
                
                      // TODO: needs allocator_arg_t
                
                      /**
                       *  @brief Builds a %function that targets a copy of the incoming
                       *  function object.
                       *  @param __f A %function object that is callable with parameters of
                       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
                       *  to @c Res.
                       *
                       *  The newly-created %function object will target a copy of 
                       *  @a __f. If @a __f is @c reference_wrapper<F>, then this function
                       *  object will contain a reference to the function object @c
                       *  __f.get(). If @a __f is a NULL function pointer or NULL
                       *  pointer-to-member, the newly-created object will be empty.
                       *
                       *  If @a __f is a non-NULL function pointer or an object of type @c
                       *  reference_wrapper<F>, this function will not throw.
                       */
                      template<typename _Functor,
                	       typename = _Requires<__not_<is_same<_Functor, function>>, void>,
                	       typename = _Requires<_Callable<_Functor>, void>>
                	function(_Functor);
                
                      /**
                       *  @brief %Function assignment operator.
                       *  @param __x A %function with identical call signature.
                       *  @post @c (bool)*this == (bool)x
                       *  @returns @c *this
                       *
                       *  The target of @a __x is copied to @c *this. If @a __x has no
                       *  target, then @c *this will be empty.
                       *
                       *  If @a __x targets a function pointer or a reference to a function
                       *  object, then this operation will not throw an %exception.
                       */
                      function&
          71 ->       operator=(const function& __x)
                      {
                	function(__x).swap(*this);
                	return *this;
                      }
                
                      /**
                       *  @brief %Function move-assignment operator.
                       *  @param __x A %function rvalue with identical call signature.
                       *  @returns @c *this
                       *
                       *  The target of @a __x is moved to @c *this. If @a __x has no
                       *  target, then @c *this will be empty.
                       *
                       *  If @a __x targets a function pointer or a reference to a function
                       *  object, then this operation will not throw an %exception.
                       */
                      function&
                      operator=(function&& __x)
                      {
                	function(std::move(__x)).swap(*this);
                	return *this;
                      }
                
                      /**
                       *  @brief %Function assignment to zero.
                       *  @post @c !(bool)*this
                       *  @returns @c *this
                       *
                       *  The target of @c *this is deallocated, leaving it empty.
                       */
                      function&
                      operator=(nullptr_t) noexcept
                      {
                	if (_M_manager)
                	  {
                	    _M_manager(_M_functor, _M_functor, __destroy_functor);
                	    _M_manager = nullptr;
                	    _M_invoker = nullptr;
                	  }
                	return *this;
                      }
                
                      /**
                       *  @brief %Function assignment to a new target.
                       *  @param __f A %function object that is callable with parameters of
                       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
                       *  to @c Res.
                       *  @return @c *this
                       *
                       *  This  %function object wrapper will target a copy of @a
                       *  __f. If @a __f is @c reference_wrapper<F>, then this function
                       *  object will contain a reference to the function object @c
                       *  __f.get(). If @a __f is a NULL function pointer or NULL
                       *  pointer-to-member, @c this object will be empty.
                       *
                       *  If @a __f is a non-NULL function pointer or an object of type @c
                       *  reference_wrapper<F>, this function will not throw.
                       */
                      template<typename _Functor>
                	_Requires<_Callable<typename decay<_Functor>::type>, function&>
                	operator=(_Functor&& __f)
                	{
                	  function(std::forward<_Functor>(__f)).swap(*this);
                	  return *this;
                	}
                
                      /// @overload
                      template<typename _Functor>
                	function&
                	operator=(reference_wrapper<_Functor> __f) noexcept
                	{
                	  function(__f).swap(*this);
                	  return *this;
                	}
                
                      // [3.7.2.2] function modifiers
                
                      /**
                       *  @brief Swap the targets of two %function objects.
                       *  @param __x A %function with identical call signature.
                       *
                       *  Swap the targets of @c this function object and @a __f. This
                       *  function will not throw an %exception.
                       */
         679 ->       void swap(function& __x)
                      {
                	std::swap(_M_functor, __x._M_functor);
                	std::swap(_M_manager, __x._M_manager);
                	std::swap(_M_invoker, __x._M_invoker);
                      }
                
                      // TODO: needs allocator_arg_t
                      /*
                      template<typename _Functor, typename _Alloc>
                	void
                	assign(_Functor&& __f, const _Alloc& __a)
                	{
                	  function(allocator_arg, __a,
                		   std::forward<_Functor>(__f)).swap(*this);
                	}
                      */
                
                      // [3.7.2.3] function capacity
                
                      /**
                       *  @brief Determine if the %function wrapper has a target.
                       *
                       *  @return @c true when this %function object contains a target,
                       *  or @c false when it is empty.
                       *
                       *  This function will not throw an %exception.
                       */
        1614 ->       explicit operator bool() const noexcept
                      { return !_M_empty(); }
                
                      // [3.7.2.4] function invocation
                
                      /**
                       *  @brief Invokes the function targeted by @c *this.
                       *  @returns the result of the target.
                       *  @throws bad_function_call when @c !(bool)*this
                       *
                       *  The function call operator invokes the target function object
                       *  stored by @c this.
                       */
                      _Res operator()(_ArgTypes... __args) const;
                
                #if __cpp_rtti
                      // [3.7.2.5] function target access
                      /**
                       *  @brief Determine the type of the target of this function object
                       *  wrapper.
                       *
                       *  @returns the type identifier of the target function object, or
                       *  @c typeid(void) if @c !(bool)*this.
                       *
                       *  This function will not throw an %exception.
                       */
                      const type_info& target_type() const noexcept;
                
                      /**
                       *  @brief Access the stored target function object.
                       *
                       *  @return Returns a pointer to the stored target function object,
                       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL
                       *  pointer.
                       *
                       * This function will not throw an %exception.
                       */
                      template<typename _Functor>       _Functor* target() noexcept;
                
                      /// @overload
                      template<typename _Functor> const _Functor* target() const noexcept;
                #endif
                
                    private:
                      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
                      _Invoker_type _M_invoker;
                  };
                
                  // Out-of-line member definitions.
                  template<typename _Res, typename... _ArgTypes>
        1381 ->     function<_Res(_ArgTypes...)>::
                    function(const function& __x)
                    : _Function_base()
                    {
                      if (static_cast<bool>(__x))
                	{
                	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
                	  _M_invoker = __x._M_invoker;
                	  _M_manager = __x._M_manager;
                	}
                    }
                
                  template<typename _Res, typename... _ArgTypes>
                    template<typename _Functor, typename, typename>
       12203 ->       function<_Res(_ArgTypes...)>::
                      function(_Functor __f)
                      : _Function_base()
                      {
                	typedef _Function_handler<_Signature_type, _Functor> _My_handler;
                
                	if (_My_handler::_M_not_empty_function(__f))
                	  {
                	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
                	    _M_invoker = &_My_handler::_M_invoke;
                	    _M_manager = &_My_handler::_M_manager;
                	  }
                      }
                
                  template<typename _Res, typename... _ArgTypes>
                    _Res
       36921 ->     function<_Res(_ArgTypes...)>::
                    operator()(_ArgTypes... __args) const
                    {
                      if (_M_empty())
                	__throw_bad_function_call();
                      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
                    }
                
                #if __cpp_rtti
                  template<typename _Res, typename... _ArgTypes>
                    const type_info&
                    function<_Res(_ArgTypes...)>::
                    target_type() const noexcept
                    {
                      if (_M_manager)
                	{
                	  _Any_data __typeinfo_result;
                	  _M_manager(__typeinfo_result, _M_functor, __get_type_info);
                	  return *__typeinfo_result._M_access<const type_info*>();
                	}
                      else
                	return typeid(void);
                    }
                
                  template<typename _Res, typename... _ArgTypes>
                    template<typename _Functor>
                      _Functor*
                      function<_Res(_ArgTypes...)>::
                      target() noexcept
                      {
                	if (typeid(_Functor) == target_type() && _M_manager)
                	  {
                	    _Any_data __ptr;
                	    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
                		&& !is_const<_Functor>::value)
                	      return 0;
                	    else
                	      return __ptr._M_access<_Functor*>();
                	  }
                	else
                	  return 0;
                      }
                
                  template<typename _Res, typename... _ArgTypes>
                    template<typename _Functor>
                      const _Functor*
                      function<_Res(_ArgTypes...)>::
                      target() const noexcept
                      {
                	if (typeid(_Functor) == target_type() && _M_manager)
                	  {
                	    _Any_data __ptr;
                	    _M_manager(__ptr, _M_functor, __get_functor_ptr);
                	    return __ptr._M_access<const _Functor*>();
                	  }
                	else
                	  return 0;
                      }
                #endif
                
                  // [20.7.15.2.6] null pointer comparisons
                
                  /**
                   *  @brief Compares a polymorphic function object wrapper against 0
                   *  (the NULL pointer).
                   *  @returns @c true if the wrapper has no target, @c false otherwise
                   *
                   *  This function will not throw an %exception.
                   */
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
                    { return !static_cast<bool>(__f); }
                
                  /// @overload
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
                    { return !static_cast<bool>(__f); }
                
                  /**
                   *  @brief Compares a polymorphic function object wrapper against 0
                   *  (the NULL pointer).
                   *  @returns @c false if the wrapper has no target, @c true otherwise
                   *
                   *  This function will not throw an %exception.
                   */
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
                    { return static_cast<bool>(__f); }
                
                  /// @overload
                  template<typename _Res, typename... _Args>
                    inline bool
                    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
                    { return static_cast<bool>(__f); }
                
                  // [20.7.15.2.7] specialized algorithms
                
                  /**
                   *  @brief Swap the targets of two polymorphic function object wrappers.
                   *
                   *  This function will not throw an %exception.
                   */
                  template<typename _Res, typename... _Args>
                    inline void
                    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif // _GLIBCXX_FUNCTIONAL


Top 10 Lines:

     Line      Count

     1834      38626
     2262      36921
     1608      35984
     1599      35946
     1689      34479
     1598      27836
     1869      24097
     1603      20435
     1731      16255
     1827      15881

Execution Summary:

       56   Executable lines in this file
       56   Lines executed
   100.00   Percent of the file executed

   458605   Total number of line executions
  8189.38   Average executions per line


*** File /home/sbillah/dmclock/sim/test_dmclock_main.cc:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #include "test_dmclock.h"
                
                #ifdef PROFILE
                #include "profile.h"
                #endif
                
                
                namespace dmc = crimson::dmclock;
                namespace test = crimson::test_dmc;
                namespace sim = crimson::qos_simulation;
                
                using namespace std::placeholders;
                
                
                namespace crimson {
                    namespace test_dmc {
                        void server_data(std::ostream& out,
                                         test::MySim* sim,
                                         test::MySim::ServerFilter server_disp_filter,
                                         int head_w, int data_w, int data_prec);
                
                        void client_data(std::ostream& out,
                                         test::MySim* sim,
                                         test::MySim::ClientFilter client_disp_filter,
                                         int head_w, int data_w, int data_prec);
                    }
                }
                
                
       ##### -> int main(int argc, char* argv[]) {
                    // server params
                
                    const uint server_count = 100; //
                    const uint server_iops = 40;
                    const uint server_threads = 1;
                    const bool server_soft_limit = true;
                
                    // client params
                
                    const uint client_total_ops = 1000;
                    const uint client_count = 10; // few clients
                    const uint client_server_select_range = 10;
                    const uint client_wait_count = 1;
                    const uint client_iops_goal = 50;
                    const uint client_outstanding_ops = 100;
                    const std::chrono::seconds client_wait(10);
                
                    // client info
                  
                    const double client_reservation = 20.0;
                    const double client_limit = 60.0;
                    const double client_weight = 1.0;
                
                    test::dmc::ClientInfo client_info(client_reservation,
                                                      client_weight,
                                                      client_limit);
                
          79 ->     auto client_info_f = [=](const ClientId& c) -> test::dmc::ClientInfo {
                        return client_info;
                    };
                
         190 ->     auto client_disp_filter = [=] (const ClientId& i) -> bool {
                        return i < 3 || i >= (client_count - 3);
                    };
                
         300 ->     auto server_disp_filter = [=] (const ServerId& i) -> bool {
                        return i < 3 || i >= (server_count - 3);
                    };
                
                
                    test::MySim *simulation;
                  
                
                    // lambda to post a request to the identified server; called by client
                    test::SubmitFunc server_post_f =
                        [&simulation](const ServerId& server,
                                      const sim::TestRequest& request,
                                      const ClientId& client_id,
        1745 ->                       const test::dmc::ReqParams& req_params) {
                        test::DmcServer& s = simulation->get_server(server);
                        s.post(request, client_id, req_params);
                    };
                
                    static std::vector<sim::CliInst> no_wait =
                        { { sim::req_op, client_total_ops, client_iops_goal, client_outstanding_ops } };
                    static std::vector<sim::CliInst> wait =
                        { { sim::wait_op, client_wait },
                          { sim::req_op, client_total_ops, client_iops_goal, client_outstanding_ops } };
                
                    simulation = new test::MySim();
                
                    test::MySim::ClientBasedServerSelectFunc server_select_f =
                      simulation->make_server_select_alt_range(client_server_select_range);
                
                    test::DmcServer::ClientRespFunc client_response_f =
                        [&simulation](ClientId client_id,
                                      const sim::TestResponse& resp,
                                      const ServerId& server_id,
        3327 ->                       const dmc::PhaseType& phase) {
                        simulation->get_client(client_id).receive_response(resp,
                                                                           server_id,
                                                                           phase);
                    };
                
                    test::CreateQueueF create_queue_f =
                        [&](test::DmcQueue::CanHandleRequestFunc can_f,
         100 ->             test::DmcQueue::HandleRequestFunc handle_f) -> test::DmcQueue* {
                        return new test::DmcQueue(client_info_f, can_f, handle_f, server_soft_limit);
                    };
                
                  
         100 ->     auto create_server_f = [&](ServerId id) -> test::DmcServer* {
                        return new test::DmcServer(id,
                                                   server_iops, server_threads,
                                                   client_response_f,
                                                   test::dmc_server_accumulate_f,
                                                   create_queue_f);
                    };
                
           7 ->     auto create_client_f = [&](ClientId id) -> test::DmcClient* {
                        return new test::DmcClient(id,
                                                   server_post_f,
                                                   std::bind(server_select_f, _1, id),
                                                   test::dmc_client_accumulate_f,
                                                   id < (client_count - client_wait_count)
                                                   ? no_wait : wait);
                    };
                
                    simulation->add_servers(server_count, create_server_f);
                    simulation->add_clients(client_count, create_client_f);
                
                    simulation->run();
                    simulation->display_stats(std::cout,
                                              &test::server_data, &test::client_data,
                                              server_disp_filter, client_disp_filter);
                } // main
                
                
                void test::client_data(std::ostream& out,
                		 test::MySim* sim,
                		 test::MySim::ClientFilter client_disp_filter,
           1 -> 		 int head_w, int data_w, int data_prec) {
                    // report how many ops were done by reservation and proportion for
                    // each client
                
                    int total_r = 0;
                    out << std::setw(head_w) << "res_ops:";
                    for (uint i = 0; i < sim->get_client_count(); ++i) {
                        const auto& client = sim->get_client(i);
                        auto r = client.get_accumulator().reservation_count;
                        total_r += r;
                        if (!client_disp_filter(i)) continue;
                        out << std::setw(data_w) << r;
                    }
                    out << std::setw(data_w) << std::setprecision(data_prec) <<
                        std::fixed << total_r << std::endl;
                
                    int total_p = 0;
                    out << std::setw(head_w) << "prop_ops:";
                    for (uint i = 0; i < sim->get_client_count(); ++i) {
                        const auto& client = sim->get_client(i);
                        auto p = client.get_accumulator().proportion_count;
                        total_p += p;
                        if (!client_disp_filter(i)) continue;
                        out << std::setw(data_w) << p;
                    }
                    out << std::setw(data_w) << std::setprecision(data_prec) <<
                        std::fixed << total_p << std::endl;
                }
                
                
                void test::server_data(std::ostream& out,
                		 test::MySim* sim,
                		 test::MySim::ServerFilter server_disp_filter,
           1 -> 		 int head_w, int data_w, int data_prec) {
                    out << std::setw(head_w) << "res_ops:";
                    int total_r = 0;
                    for (uint i = 0; i < sim->get_server_count(); ++i) {
                        const auto& server = sim->get_server(i);
                        auto rc = server.get_accumulator().reservation_count;
                        total_r += rc;
                        if (!server_disp_filter(i)) continue;
                        out << std::setw(data_w) << rc;
                    }
                    out << std::setw(data_w) << std::setprecision(data_prec) <<
                        std::fixed << total_r << std::endl;
                
                    out << std::setw(head_w) << "prop_ops:";
                    int total_p = 0;
                    for (uint i = 0; i < sim->get_server_count(); ++i) {
                        const auto& server = sim->get_server(i);
                        auto pc = server.get_accumulator().proportion_count;
                        total_p += pc;
                        if (!server_disp_filter(i)) continue;
                        out << std::setw(data_w) << pc;
                    }
                    out << std::setw(data_w) << std::setprecision(data_prec) <<
                        std::fixed << total_p << std::endl;
                
                #ifdef PROFILE
                    crimson::ProfileCombiner<std::chrono::nanoseconds> art_combiner;
                    crimson::ProfileCombiner<std::chrono::nanoseconds> rct_combiner;
                    for (uint i = 0; i < sim->get_server_count(); ++i) {
                      const auto& q = sim->get_server(i).get_priority_queue();
                      const auto& art = q.add_request_timer;
                      art_combiner.combine(art);
                      const auto& rct = q.request_complete_timer;
                      rct_combiner.combine(rct);
                    }
                    out << "Server add_request_timer: count:" << art_combiner.get_count() <<
                      ", mean:" << art_combiner.get_mean() <<
                      ", std_dev:" << art_combiner.get_std_dev() <<
                      ", low:" << art_combiner.get_low() <<
                      ", high:" << art_combiner.get_high() << std::endl;
                    out << "Server request_complete_timer: count:" << rct_combiner.get_count() <<
                      ", mean:" << rct_combiner.get_mean() <<
                      ", std_dev:" << rct_combiner.get_std_dev() <<
                      ", low:" << rct_combiner.get_low() <<
                      ", high:" << rct_combiner.get_high() << std::endl;
                    out << "Server combined mean: " <<
                      (art_combiner.get_mean() + rct_combiner.get_mean()) <<
                      std::endl;
                #endif
           2 -> }


Top 10 Lines:

     Line      Count

      107       3327
       87       1745
       74        300
       70        190
      115        100
      120        100
       66         79
      128          7
      232          2
      150          1

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

     5852   Total number of line executions
   487.67   Average executions per line


*** File /usr/include/c++/5/ext/atomicity.h:
                // Support for atomic operations -*- C++ -*-
                
                // Copyright (C) 2004-2015 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/atomicity.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _GLIBCXX_ATOMICITY_H
                #define _GLIBCXX_ATOMICITY_H	1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/gthr.h>
                #include <bits/atomic_word.h>
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Functions for portable atomic access.
                  // To abstract locking primitives across all thread policies, use:
                  // __exchange_and_add_dispatch
                  // __atomic_add_dispatch
                #ifdef _GLIBCXX_ATOMIC_BUILTINS
                  static inline _Atomic_word 
                  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
          84 ->   { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
                
                  static inline void
                  __atomic_add(volatile _Atomic_word* __mem, int __val)
         161 ->   { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
                #else
                  _Atomic_word
                  __attribute__ ((__unused__))
                  __exchange_and_add(volatile _Atomic_word*, int) throw ();
                
                  void
                  __attribute__ ((__unused__))
                  __atomic_add(volatile _Atomic_word*, int) throw ();
                #endif
                
                  static inline _Atomic_word
                  __exchange_and_add_single(_Atomic_word* __mem, int __val)
       ##### ->   {
                    _Atomic_word __result = *__mem;
                    *__mem += __val;
                    return __result;
                  }
                
                  static inline void
                  __atomic_add_single(_Atomic_word* __mem, int __val)
       ##### ->   { *__mem += __val; }
                
                  static inline _Atomic_word
                  __attribute__ ((__unused__))
                  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
          80 ->   {
                #ifdef __GTHREADS
                    if (__gthread_active_p())
                      return __exchange_and_add(__mem, __val);
                    else
                      return __exchange_and_add_single(__mem, __val);
                #else
                    return __exchange_and_add_single(__mem, __val);
                #endif
                  }
                
                  static inline void
                  __attribute__ ((__unused__))
                  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
         166 ->   {
                #ifdef __GTHREADS
                    if (__gthread_active_p())
                      __atomic_add(__mem, __val);
                    else
                      __atomic_add_single(__mem, __val);
                #else
                    __atomic_add_single(__mem, __val);
                #endif
                  }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                // Even if the CPU doesn't need a memory barrier, we need to ensure
                // that the compiler doesn't reorder memory accesses across the
                // barriers.
                #ifndef _GLIBCXX_READ_MEM_BARRIER
                #define _GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory")
                #endif
                #ifndef _GLIBCXX_WRITE_MEM_BARRIER
                #define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory")
                #endif
                
                #endif 


Top 10 Lines:

     Line      Count

       93        166
       53        161
       49         84
       79         80

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

      491   Total number of line executions
    81.83   Average executions per line


*** File /usr/include/x86_64-linux-gnu/c++/5/bits/gthr-default.h:
                /* Threads compatibility routines for libgcc2 and libobjc.  */
                /* Compile this one with gcc.  */
                /* Copyright (C) 1997-2015 Free Software Foundation, Inc.
                
                This file is part of GCC.
                
                GCC is free software; you can redistribute it and/or modify it under
                the terms of the GNU General Public License as published by the Free
                Software Foundation; either version 3, or (at your option) any later
                version.
                
                GCC is distributed in the hope that it will be useful, but WITHOUT ANY
                WARRANTY; without even the implied warranty of MERCHANTABILITY or
                FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
                for more details.
                
                Under Section 7 of GPL version 3, you are granted additional
                permissions described in the GCC Runtime Library Exception, version
                3.1, as published by the Free Software Foundation.
                
                You should have received a copy of the GNU General Public License and
                a copy of the GCC Runtime Library Exception along with this program;
                see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                <http://www.gnu.org/licenses/>.  */
                
                #ifndef _GLIBCXX_GCC_GTHR_POSIX_H
                #define _GLIBCXX_GCC_GTHR_POSIX_H
                
                /* POSIX threads specific definitions.
                   Easy, since the interface is just one-to-one mapping.  */
                
                #define __GTHREADS 1
                #define __GTHREADS_CXX0X 1
                
                #include <pthread.h>
                
                #if ((defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)) \
                     || !defined(_GTHREAD_USE_MUTEX_TIMEDLOCK))
                # include <unistd.h>
                # if defined(_POSIX_TIMEOUTS) && _POSIX_TIMEOUTS >= 0
                #  define _GTHREAD_USE_MUTEX_TIMEDLOCK 1
                # else
                #  define _GTHREAD_USE_MUTEX_TIMEDLOCK 0
                # endif
                #endif
                
                typedef pthread_t __gthread_t;
                typedef pthread_key_t __gthread_key_t;
                typedef pthread_once_t __gthread_once_t;
                typedef pthread_mutex_t __gthread_mutex_t;
                typedef pthread_mutex_t __gthread_recursive_mutex_t;
                typedef pthread_cond_t __gthread_cond_t;
                typedef struct timespec __gthread_time_t;
                
                /* POSIX like conditional variables are supported.  Please look at comments
                   in gthr.h for details. */
                #define __GTHREAD_HAS_COND	1
                
                #define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER
                #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function
                #define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT
                #if defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)
                #define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER
                #elif defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
                #define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
                #else
                #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
                #endif
                #define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER
                #define __GTHREAD_TIME_INIT {0,0}
                
                #ifdef _GTHREAD_USE_MUTEX_INIT_FUNC
                # undef __GTHREAD_MUTEX_INIT
                #endif
                #ifdef _GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC
                # undef __GTHREAD_RECURSIVE_MUTEX_INIT
                # undef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION
                # define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
                #endif
                #ifdef _GTHREAD_USE_COND_INIT_FUNC
                # undef __GTHREAD_COND_INIT
                # define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init_function
                #endif
                
                #if __GXX_WEAK__ && _GLIBCXX_GTHREAD_USE_WEAK
                # ifndef __gthrw_pragma
                #  define __gthrw_pragma(pragma)
                # endif
                # define __gthrw2(name,name2,type) \
                  static __typeof(type) name __attribute__ ((__weakref__(#name2))); \
                  __gthrw_pragma(weak type)
                # define __gthrw_(name) __gthrw_ ## name
                #else
                # define __gthrw2(name,name2,type)
                # define __gthrw_(name) name
                #endif
                
                /* Typically, __gthrw_foo is a weak reference to symbol foo.  */
                #define __gthrw(name) __gthrw2(__gthrw_ ## name,name,name)
                
                __gthrw(pthread_once)
                __gthrw(pthread_getspecific)
                __gthrw(pthread_setspecific)
                
                __gthrw(pthread_create)
                __gthrw(pthread_join)
                __gthrw(pthread_equal)
                __gthrw(pthread_self)
                __gthrw(pthread_detach)
                #ifndef __BIONIC__
                __gthrw(pthread_cancel)
                #endif
                __gthrw(sched_yield)
                
                __gthrw(pthread_mutex_lock)
                __gthrw(pthread_mutex_trylock)
                #if _GTHREAD_USE_MUTEX_TIMEDLOCK
                __gthrw(pthread_mutex_timedlock)
                #endif
                __gthrw(pthread_mutex_unlock)
                __gthrw(pthread_mutex_init)
                __gthrw(pthread_mutex_destroy)
                
                __gthrw(pthread_cond_init)
                __gthrw(pthread_cond_broadcast)
                __gthrw(pthread_cond_signal)
                __gthrw(pthread_cond_wait)
                __gthrw(pthread_cond_timedwait)
                __gthrw(pthread_cond_destroy)
                
                __gthrw(pthread_key_create)
                __gthrw(pthread_key_delete)
                __gthrw(pthread_mutexattr_init)
                __gthrw(pthread_mutexattr_settype)
                __gthrw(pthread_mutexattr_destroy)
                
                
                #if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)
                /* Objective-C.  */
                __gthrw(pthread_exit)
                #ifdef _POSIX_PRIORITY_SCHEDULING
                #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
                __gthrw(sched_get_priority_max)
                __gthrw(sched_get_priority_min)
                #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
                #endif /* _POSIX_PRIORITY_SCHEDULING */
                __gthrw(pthread_attr_destroy)
                __gthrw(pthread_attr_init)
                __gthrw(pthread_attr_setdetachstate)
                #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
                __gthrw(pthread_getschedparam)
                __gthrw(pthread_setschedparam)
                #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
                #endif /* _LIBOBJC || _LIBOBJC_WEAK */
                
                #if __GXX_WEAK__ && _GLIBCXX_GTHREAD_USE_WEAK
                
                /* On Solaris 2.6 up to 9, the libc exposes a POSIX threads interface even if
                   -pthreads is not specified.  The functions are dummies and most return an
                   error value.  However pthread_once returns 0 without invoking the routine
                   it is passed so we cannot pretend that the interface is active if -pthreads
                   is not specified.  On Solaris 2.5.1, the interface is not exposed at all so
                   we need to play the usual game with weak symbols.  On Solaris 10 and up, a
                   working interface is always exposed.  On FreeBSD 6 and later, libc also
                   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up
                   to 9 does.  FreeBSD >= 700014 even provides a pthread_cancel stub in libc,
                   which means the alternate __gthread_active_p below cannot be used there.  */
                
                #if defined(__FreeBSD__) || (defined(__sun) && defined(__svr4__))
                
                static volatile int __gthread_active = -1;
                
                static void
                __gthread_trigger (void)
                {
                  __gthread_active = 1;
                }
                
                static inline int
                __gthread_active_p (void)
                {
                  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;
                  static pthread_once_t __gthread_active_once = PTHREAD_ONCE_INIT;
                
                  /* Avoid reading __gthread_active twice on the main code path.  */
                  int __gthread_active_latest_value = __gthread_active;
                
                  /* This test is not protected to avoid taking a lock on the main code
                     path so every update of __gthread_active in a threaded program must
                     be atomic with regard to the result of the test.  */
                  if (__builtin_expect (__gthread_active_latest_value < 0, 0))
                    {
                      if (__gthrw_(pthread_once))
                	{
                	  /* If this really is a threaded program, then we must ensure that
                	     __gthread_active has been set to 1 before exiting this block.  */
                	  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);
                	  __gthrw_(pthread_once) (&__gthread_active_once, __gthread_trigger);
                	  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);
                	}
                
                      /* Make sure we'll never enter this block again.  */
                      if (__gthread_active < 0)
                	__gthread_active = 0;
                
                      __gthread_active_latest_value = __gthread_active;
                    }
                
                  return __gthread_active_latest_value != 0;
                }
                
                #else /* neither FreeBSD nor Solaris */
                
                /* For a program to be multi-threaded the only thing that it certainly must
                   be using is pthread_create.  However, there may be other libraries that
                   intercept pthread_create with their own definitions to wrap pthreads
                   functionality for some purpose.  In those cases, pthread_create being
                   defined might not necessarily mean that libpthread is actually linked
                   in.
                
                   For the GNU C library, we can use a known internal name.  This is always
                   available in the ABI, but no other library would define it.  That is
                   ideal, since any public pthread function might be intercepted just as
                   pthread_create might be.  __pthread_key_create is an "internal"
                   implementation symbol, but it is part of the public exported ABI.  Also,
                   it's among the symbols that the static libpthread.a always links in
                   whenever pthread_create is used, so there is no danger of a false
                   negative result in any statically-linked, multi-threaded program.
                
                   For others, we choose pthread_cancel as a function that seems unlikely
                   to be redefined by an interceptor library.  The bionic (Android) C
                   library does not provide pthread_cancel, so we do use pthread_create
                   there (and interceptor libraries lose).  */
                
                #ifdef __GLIBC__
                __gthrw2(__gthrw_(__pthread_key_create),
                	 __pthread_key_create,
                	 pthread_key_create)
                # define GTHR_ACTIVE_PROXY	__gthrw_(__pthread_key_create)
                #elif defined (__BIONIC__)
                # define GTHR_ACTIVE_PROXY	__gthrw_(pthread_create)
                #else
                # define GTHR_ACTIVE_PROXY	__gthrw_(pthread_cancel)
                #endif
                
                static inline int
                __gthread_active_p (void)
       94837 -> {
                  static void *const __gthread_active_ptr
                    = __extension__ (void *) &GTHR_ACTIVE_PROXY;
                  return __gthread_active_ptr != 0;
                }
                
                #endif /* FreeBSD or Solaris */
                
                #else /* not __GXX_WEAK__ */
                
                /* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread
                   calls in shared flavors of the HP-UX C library.  Most of the stubs
                   have no functionality.  The details are described in the "libc cumulative
                   patch" for each subversion of HP-UX 11.  There are two special interfaces
                   provided for checking whether an application is linked to a shared pthread
                   library or not.  However, these interfaces aren't available in early
                   libpthread libraries.  We also need a test that works for archive
                   libraries.  We can't use pthread_once as some libc versions call the
                   init function.  We also can't use pthread_create or pthread_attr_init
                   as these create a thread and thereby prevent changing the default stack
                   size.  The function pthread_default_stacksize_np is available in both
                   the archive and shared versions of libpthread.   It can be used to
                   determine the default pthread stack size.  There is a stub in some
                   shared libc versions which returns a zero size if pthreads are not
                   active.  We provide an equivalent stub to handle cases where libc
                   doesn't provide one.  */
                
                #if defined(__hppa__) && defined(__hpux__)
                
                static volatile int __gthread_active = -1;
                
                static inline int
                __gthread_active_p (void)
                {
                  /* Avoid reading __gthread_active twice on the main code path.  */
                  int __gthread_active_latest_value = __gthread_active;
                  size_t __s;
                
                  if (__builtin_expect (__gthread_active_latest_value < 0, 0))
                    {
                      pthread_default_stacksize_np (0, &__s);
                      __gthread_active = __s ? 1 : 0;
                      __gthread_active_latest_value = __gthread_active;
                    }
                
                  return __gthread_active_latest_value != 0;
                }
                
                #else /* not hppa-hpux */
                
                static inline int
                __gthread_active_p (void)
                {
                  return 1;
                }
                
                #endif /* hppa-hpux */
                
                #endif /* __GXX_WEAK__ */
                
                #ifdef _LIBOBJC
                
                /* This is the config.h file in libobjc/ */
                #include <config.h>
                
                #ifdef HAVE_SCHED_H
                # include <sched.h>
                #endif
                
                /* Key structure for maintaining thread specific storage */
                static pthread_key_t _objc_thread_storage;
                static pthread_attr_t _objc_thread_attribs;
                
                /* Thread local storage for a single thread */
                static void *thread_local_storage = NULL;
                
                /* Backend initialization functions */
                
                /* Initialize the threads subsystem.  */
                static inline int
                __gthread_objc_init_thread_system (void)
                {
                  if (__gthread_active_p ())
                    {
                      /* Initialize the thread storage key.  */
                      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0)
                	{
                	  /* The normal default detach state for threads is
                	   * PTHREAD_CREATE_JOINABLE which causes threads to not die
                	   * when you think they should.  */
                	  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0
                	      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs,
                					      PTHREAD_CREATE_DETACHED) == 0)
                	    return 0;
                	}
                    }
                
                  return -1;
                }
                
                /* Close the threads subsystem.  */
                static inline int
                __gthread_objc_close_thread_system (void)
                {
                  if (__gthread_active_p ()
                      && __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0
                      && __gthrw_(pthread_attr_destroy) (&_objc_thread_attribs) == 0)
                    return 0;
                
                  return -1;
                }
                
                /* Backend thread functions */
                
                /* Create a new thread of execution.  */
                static inline objc_thread_t
                __gthread_objc_thread_detach (void (*func)(void *), void *arg)
                {
                  objc_thread_t thread_id;
                  pthread_t new_thread_handle;
                
                  if (!__gthread_active_p ())
                    return NULL;
                
                  if (!(__gthrw_(pthread_create) (&new_thread_handle, &_objc_thread_attribs,
                				  (void *) func, arg)))
                    thread_id = (objc_thread_t) new_thread_handle;
                  else
                    thread_id = NULL;
                
                  return thread_id;
                }
                
                /* Set the current thread's priority.  */
                static inline int
                __gthread_objc_thread_set_priority (int priority)
                {
                  if (!__gthread_active_p ())
                    return -1;
                  else
                    {
                #ifdef _POSIX_PRIORITY_SCHEDULING
                #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
                      pthread_t thread_id = __gthrw_(pthread_self) ();
                      int policy;
                      struct sched_param params;
                      int priority_min, priority_max;
                
                      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0)
                	{
                	  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)
                	    return -1;
                
                	  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)
                	    return -1;
                
                	  if (priority > priority_max)
                	    priority = priority_max;
                	  else if (priority < priority_min)
                	    priority = priority_min;
                	  params.sched_priority = priority;
                
                	  /*
                	   * The solaris 7 and several other man pages incorrectly state that
                	   * this should be a pointer to policy but pthread.h is universally
                	   * at odds with this.
                	   */
                	  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0)
                	    return 0;
                	}
                #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
                #endif /* _POSIX_PRIORITY_SCHEDULING */
                      return -1;
                    }
                }
                
                /* Return the current thread's priority.  */
                static inline int
                __gthread_objc_thread_get_priority (void)
                {
                #ifdef _POSIX_PRIORITY_SCHEDULING
                #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
                  if (__gthread_active_p ())
                    {
                      int policy;
                      struct sched_param params;
                
                      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &policy, &params) == 0)
                	return params.sched_priority;
                      else
                	return -1;
                    }
                  else
                #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
                #endif /* _POSIX_PRIORITY_SCHEDULING */
                    return OBJC_THREAD_INTERACTIVE_PRIORITY;
                }
                
                /* Yield our process time to another thread.  */
                static inline void
                __gthread_objc_thread_yield (void)
                {
                  if (__gthread_active_p ())
                    __gthrw_(sched_yield) ();
                }
                
                /* Terminate the current thread.  */
                static inline int
                __gthread_objc_thread_exit (void)
                {
                  if (__gthread_active_p ())
                    /* exit the thread */
                    __gthrw_(pthread_exit) (&__objc_thread_exit_status);
                
                  /* Failed if we reached here */
                  return -1;
                }
                
                /* Returns an integer value which uniquely describes a thread.  */
                static inline objc_thread_t
                __gthread_objc_thread_id (void)
                {
                  if (__gthread_active_p ())
                    return (objc_thread_t) __gthrw_(pthread_self) ();
                  else
                    return (objc_thread_t) 1;
                }
                
                /* Sets the thread's local storage pointer.  */
                static inline int
                __gthread_objc_thread_set_data (void *value)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);
                  else
                    {
                      thread_local_storage = value;
                      return 0;
                    }
                }
                
                /* Returns the thread's local storage pointer.  */
                static inline void *
                __gthread_objc_thread_get_data (void)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_getspecific) (_objc_thread_storage);
                  else
                    return thread_local_storage;
                }
                
                /* Backend mutex functions */
                
                /* Allocate a mutex.  */
                static inline int
                __gthread_objc_mutex_allocate (objc_mutex_t mutex)
                {
                  if (__gthread_active_p ())
                    {
                      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));
                
                      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL))
                	{
                	  objc_free (mutex->backend);
                	  mutex->backend = NULL;
                	  return -1;
                	}
                    }
                
                  return 0;
                }
                
                /* Deallocate a mutex.  */
                static inline int
                __gthread_objc_mutex_deallocate (objc_mutex_t mutex)
                {
                  if (__gthread_active_p ())
                    {
                      int count;
                
                      /*
                       * Posix Threads specifically require that the thread be unlocked
                       * for __gthrw_(pthread_mutex_destroy) to work.
                       */
                
                      do
                	{
                	  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);
                	  if (count < 0)
                	    return -1;
                	}
                      while (count);
                
                      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))
                	return -1;
                
                      objc_free (mutex->backend);
                      mutex->backend = NULL;
                    }
                  return 0;
                }
                
                /* Grab a lock on a mutex.  */
                static inline int
                __gthread_objc_mutex_lock (objc_mutex_t mutex)
                {
                  if (__gthread_active_p ()
                      && __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend) != 0)
                    {
                      return -1;
                    }
                
                  return 0;
                }
                
                /* Try to grab a lock on a mutex.  */
                static inline int
                __gthread_objc_mutex_trylock (objc_mutex_t mutex)
                {
                  if (__gthread_active_p ()
                      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0)
                    {
                      return -1;
                    }
                
                  return 0;
                }
                
                /* Unlock the mutex */
                static inline int
                __gthread_objc_mutex_unlock (objc_mutex_t mutex)
                {
                  if (__gthread_active_p ()
                      && __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend) != 0)
                    {
                      return -1;
                    }
                
                  return 0;
                }
                
                /* Backend condition mutex functions */
                
                /* Allocate a condition.  */
                static inline int
                __gthread_objc_condition_allocate (objc_condition_t condition)
                {
                  if (__gthread_active_p ())
                    {
                      condition->backend = objc_malloc (sizeof (pthread_cond_t));
                
                      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition->backend, NULL))
                	{
                	  objc_free (condition->backend);
                	  condition->backend = NULL;
                	  return -1;
                	}
                    }
                
                  return 0;
                }
                
                /* Deallocate a condition.  */
                static inline int
                __gthread_objc_condition_deallocate (objc_condition_t condition)
                {
                  if (__gthread_active_p ())
                    {
                      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend))
                	return -1;
                
                      objc_free (condition->backend);
                      condition->backend = NULL;
                    }
                  return 0;
                }
                
                /* Wait on the condition */
                static inline int
                __gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition->backend,
                			      (pthread_mutex_t *) mutex->backend);
                  else
                    return 0;
                }
                
                /* Wake up all threads waiting on this condition.  */
                static inline int
                __gthread_objc_condition_broadcast (objc_condition_t condition)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend);
                  else
                    return 0;
                }
                
                /* Wake up one thread waiting on this condition.  */
                static inline int
                __gthread_objc_condition_signal (objc_condition_t condition)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition->backend);
                  else
                    return 0;
                }
                
                #else /* _LIBOBJC */
                
                static inline int
                __gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
                		  void *__args)
                {
                  return __gthrw_(pthread_create) (__threadid, NULL, __func, __args);
                }
                
                static inline int
                __gthread_join (__gthread_t __threadid, void **__value_ptr)
                {
                  return __gthrw_(pthread_join) (__threadid, __value_ptr);
                }
                
                static inline int
                __gthread_detach (__gthread_t __threadid)
                {
                  return __gthrw_(pthread_detach) (__threadid);
                }
                
                static inline int
                __gthread_equal (__gthread_t __t1, __gthread_t __t2)
         809 -> {
                  return __gthrw_(pthread_equal) (__t1, __t2);
                }
                
                static inline __gthread_t
                __gthread_self (void)
                {
                  return __gthrw_(pthread_self) ();
                }
                
                static inline int
                __gthread_yield (void)
                {
                  return __gthrw_(sched_yield) ();
                }
                
                static inline int
                __gthread_once (__gthread_once_t *__once, void (*__func) (void))
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_once) (__once, __func);
                  else
                    return -1;
                }
                
                static inline int
                __gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
                {
                  return __gthrw_(pthread_key_create) (__key, __dtor);
                }
                
                static inline int
                __gthread_key_delete (__gthread_key_t __key)
                {
                  return __gthrw_(pthread_key_delete) (__key);
                }
                
                static inline void *
                __gthread_getspecific (__gthread_key_t __key)
                {
                  return __gthrw_(pthread_getspecific) (__key);
                }
                
                static inline int
                __gthread_setspecific (__gthread_key_t __key, const void *__ptr)
                {
                  return __gthrw_(pthread_setspecific) (__key, __ptr);
                }
                
                static inline void
                __gthread_mutex_init_function (__gthread_mutex_t *__mutex)
                {
                  if (__gthread_active_p ())
                    __gthrw_(pthread_mutex_init) (__mutex, NULL);
                }
                
                static inline int
                __gthread_mutex_destroy (__gthread_mutex_t *__mutex)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_mutex_destroy) (__mutex);
                  else
                    return 0;
                }
                
                static inline int
                __gthread_mutex_lock (__gthread_mutex_t *__mutex)
       46399 -> {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_mutex_lock) (__mutex);
                  else
                    return 0;
                }
                
                static inline int
                __gthread_mutex_trylock (__gthread_mutex_t *__mutex)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_mutex_trylock) (__mutex);
                  else
                    return 0;
                }
                
                #if _GTHREAD_USE_MUTEX_TIMEDLOCK
                static inline int
                __gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
                			   const __gthread_time_t *__abs_timeout)
                {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);
                  else
                    return 0;
                }
                #endif
                
                static inline int
                __gthread_mutex_unlock (__gthread_mutex_t *__mutex)
       48400 -> {
                  if (__gthread_active_p ())
                    return __gthrw_(pthread_mutex_unlock) (__mutex);
                  else
                    return 0;
                }
                
                #if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \
                  || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)
                static inline int
                __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
                {
                  if (__gthread_active_p ())
                    {
                      pthread_mutexattr_t __attr;
                      int __r;
                
                      __r = __gthrw_(pthread_mutexattr_init) (&__attr);
                      if (!__r)
                	__r = __gthrw_(pthread_mutexattr_settype) (&__attr,
                						   PTHREAD_MUTEX_RECURSIVE);
                      if (!__r)
                	__r = __gthrw_(pthread_mutex_init) (__mutex, &__attr);
                      if (!__r)
                	__r = __gthrw_(pthread_mutexattr_destroy) (&__attr);
                      return __r;
                    }
                  return 0;
                }
                #endif
                
                static inline int
                __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
                {
                  return __gthread_mutex_lock (__mutex);
                }
                
                static inline int
                __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
                {
                  return __gthread_mutex_trylock (__mutex);
                }
                
                #if _GTHREAD_USE_MUTEX_TIMEDLOCK
                static inline int
                __gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
                				     const __gthread_time_t *__abs_timeout)
                {
                  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
                }
                #endif
                
                static inline int
                __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
                {
                  return __gthread_mutex_unlock (__mutex);
                }
                
                static inline int
                __gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
                {
                  return __gthread_mutex_destroy (__mutex);
                }
                
                #ifdef _GTHREAD_USE_COND_INIT_FUNC
                static inline void
                __gthread_cond_init_function (__gthread_cond_t *__cond)
                {
                  if (__gthread_active_p ())
                    __gthrw_(pthread_cond_init) (__cond, NULL);
                }
                #endif
                
                static inline int
                __gthread_cond_broadcast (__gthread_cond_t *__cond)
                {
                  return __gthrw_(pthread_cond_broadcast) (__cond);
                }
                
                static inline int
                __gthread_cond_signal (__gthread_cond_t *__cond)
                {
                  return __gthrw_(pthread_cond_signal) (__cond);
                }
                
                static inline int
                __gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
                {
                  return __gthrw_(pthread_cond_wait) (__cond, __mutex);
                }
                
                static inline int
                __gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
                			  const __gthread_time_t *__abs_timeout)
       12982 -> {
                  return __gthrw_(pthread_cond_timedwait) (__cond, __mutex, __abs_timeout);
                }
                
                static inline int
                __gthread_cond_wait_recursive (__gthread_cond_t *__cond,
                			       __gthread_recursive_mutex_t *__mutex)
                {
                  return __gthread_cond_wait (__cond, __mutex);
                }
                
                static inline int
                __gthread_cond_destroy (__gthread_cond_t* __cond)
                {
                  return __gthrw_(pthread_cond_destroy) (__cond);
                }
                
                #endif /* _LIBOBJC */
                
                #endif /* ! _GLIBCXX_GCC_GTHR_POSIX_H */


Top 10 Lines:

     Line      Count

      248      94837
      776      48400
      746      46399
      870      12982
      679        809

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

   203427   Total number of line executions
 40685.40   Average executions per line


*** File /home/sbillah/dmclock/sim/test_dmclock.cc:
                // -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
                // vim: ts=8 sw=2 smarttab
                
                /*
                 * Copyright (C) 2016 Red Hat Inc.
                 */
                
                
                #include "dmclock_recs.h"
                #include "dmclock_server.h"
                #include "dmclock_client.h"
                
                #include "sim_recs.h"
                #include "sim_server.h"
                #include "sim_client.h"
                
                #include "test_dmclock.h"
                
                
                namespace test = crimson::test_dmc;
                
                
                void test::dmc_server_accumulate_f(test::DmcAccum& a,
        2423 -> 				   const test::dmc::PhaseType& phase) {
                  if (test::dmc::PhaseType::reservation == phase) {
                    ++a.reservation_count;
                  } else {
                    ++a.proportion_count;
                  }
                }
                
                
                void test::dmc_client_accumulate_f(test::DmcAccum& a,
        2230 -> 				   const test::dmc::PhaseType& phase) {
                  if (test::dmc::PhaseType::reservation == phase) {
                    ++a.reservation_count;
                  } else {
                    ++a.proportion_count;
                  }
           2 -> }


Top 10 Lines:

     Line      Count

       24       2423
       34       2230
       40          2

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

     4655   Total number of line executions
  1551.67   Average executions per line
